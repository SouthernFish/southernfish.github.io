<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-07-28T10:27:55.454Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-行为型模式</title>
    <link href="https://southernfish.github.io/2025/07/28/java/java-design-pattern-behavioral/"/>
    <id>https://southernfish.github.io/2025/07/28/java/java-design-pattern-behavioral/</id>
    <published>2025-07-28T12:00:00.000Z</published>
    <updated>2025-07-28T10:27:55.454Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><p><strong>行为型模式</strong>（Behavioral Patterns）：主要<strong>用于描述对象之间的通信和责任分配</strong>，包括多个不同的模式，如“策略模式”、“模板方法模式”、“观察者模式”、“迭代器模式”、“职责链模式”、“命令模式”、“访问者模式”、“备忘录模式”和“解释器模式”等。这些模式通常用于实现不同的算法、流程和通信方式，以实现系统的更高灵活性和可维护性。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130448194">设计模式——模板模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130451520">设计模式——观察者模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130412327?spm=1001.2014.3001.5502">设计模式——责任链模式</a></p></blockquote><h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>模板方法模式（Template Method Pattern），又叫模板模式（Template Pattern），在一个<strong>抽象类</strong>公开<strong>定义了</strong>执行它的方法的<strong>模板</strong>。它的<strong>子类可以按需要重写方法实现</strong>，但调用将以抽象类中定义的方式进行</li><li>简单说，模板方法模式定义一个操作中的算法的骨架，而<strong>将一些步骤延迟到子类中</strong>，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</li></ul><p><strong>实现方式：</strong>抽象类有一个模板方法和其他行为方法，模板方法按流程调用各行为方法（抽象或非抽象）；具体子类重写抽象的行为方法。</p><p><strong>模板方法模式的角色和职责</strong></p><ul><li><p><code>AbstractClass</code>抽象类中实现了模板方法，定义了算法的骨架，具体子类需要去实现其抽象方法或重写其中方法</p></li><li><p><code>ConcreteClass</code>实现了抽象方法，已完成算法中特定子类的步骤</p></li></ul><p><strong>注意事项和细节</strong></p><ol><li><strong>基本思想</strong>：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改</li><li>实现了最大化<strong>代码复用</strong>。父类的模板方法和已实现的某些步骤会被子类继承而直接使用</li><li>既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现</li><li><strong>不足之处</strong>：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大</li><li>一般<strong>模板方法都加上final关键字</strong>，防止子类重写模板方法</li><li><strong>使用场景</strong>：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理</li></ol><h2 id="模板模式解决豆浆制作问题"><a href="#模板模式解决豆浆制作问题" class="headerlink" title="模板模式解决豆浆制作问题"></a>模板模式解决豆浆制作问题</h2><p>编写制作豆浆的程序，说明如下：</p><ol><li>制作豆浆的流程选材 → 添加配料 → 浸泡  → 放到豆浆机打碎</li><li>通过添加不同的配料，可以制作出不同口味的豆浆</li><li>选材、浸泡和放到豆浆机打碎这几个步骤是一个模板方法，对于制作每种口味的豆浆都是一样的</li><li>请使用模板方法模式完成</li></ol><blockquote><p>说明：因为模板方法模式比较简单，很容易就想到这个方案，因此就直接使用，不再使用传统的方案来引出模板方法模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法，定义为final禁止覆写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作开始&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        useSoyBean();</span><br><span class="line">        addIngredients();</span><br><span class="line">        soak();</span><br><span class="line">        mash();</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作结束&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同包可见、对其他包下的子类可见。</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">useSoyBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step1. 选用上好的黄豆.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加原材料是抽象方法，因为不同豆浆原材料不一样</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addIngredients</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">soak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step3. 对黄豆和配料进行水洗浸泡.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">mash</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step4. 将充分浸泡过的黄豆和配料放入豆浆机中，开始打豆浆.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 花生豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PeanutSoyaMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============花生豆浆============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addIngredients</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Step2. 加入上好的花生.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 红豆豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedBeanSoyaMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============红豆豆浆============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addIngredients</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Step2. 加入上好的红豆.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 芝麻豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SesameSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SesameSoyaMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============芝麻豆浆============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addIngredients</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Step2. 加入上好的芝麻.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端调用模板方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SoyaMilk</span> <span class="variable">peanutSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PeanutSoyaMilk</span>();</span><br><span class="line">peanutSoyaMilk.make();</span><br><span class="line"><span class="type">SoyaMilk</span> <span class="variable">redBeanSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedBeanSoyaMilk</span>();</span><br><span class="line">redBeanSoyaMilk.make();</span><br><span class="line"><span class="type">SoyaMilk</span> <span class="variable">sesameSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SesameSoyaMilk</span>();</span><br><span class="line">sesameSoyaMilk.make();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">============花生豆浆============</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作开始&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment">Step1. 选用上好的黄豆.</span></span><br><span class="line"><span class="comment">Step2. 加入上好的花生.</span></span><br><span class="line"><span class="comment">Step3. 对黄豆和配料进行水洗浸泡.</span></span><br><span class="line"><span class="comment">Step4. 将充分浸泡过的黄豆和配料放入豆浆机中，开始打豆浆.</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作结束&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment">============红豆豆浆============</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">============芝麻豆浆============</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h2><p>在模板方法模式的父类中，我们可以定义一个<strong>方法，它默认不做任何事，子类可以视情况要不要覆盖它</strong>，该方法称为“钩子”</p><p>用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的模板方法进行改造</p><p><strong>抽象类和具体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 如果钩子方法决定加配料，就加配料；否则不执行加配料操作。</span></span><br><span class="line">        <span class="keyword">if</span> (customAddIngredients()) &#123;</span><br><span class="line">            addIngredients();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 钩子方法，决定是否需要添加配料。默认情况是加配料。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">customAddIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PureSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PureSoyaMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============纯豆浆============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 空实现即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Boolean <span class="title function_">customAddIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端，测试钩子方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SoyaMilk</span> <span class="variable">pureSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PureSoyaMilk</span>();</span><br><span class="line">pureSoyaMilk.make();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">============纯豆浆============</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作开始&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment">Step1. 选用上好的黄豆.</span></span><br><span class="line"><span class="comment">Step3. 对黄豆和配料进行水洗浸泡.</span></span><br><span class="line"><span class="comment">Step4. 将充分浸泡过的黄豆和配料放入豆浆机中，开始打豆浆.</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt;&gt;&gt;&gt;豆浆制作结束&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Spring-框架AbstractApplicationContext抽象类"><a href="#Spring-框架AbstractApplicationContext抽象类" class="headerlink" title="Spring 框架AbstractApplicationContext抽象类"></a>Spring 框架AbstractApplicationContext抽象类</h2><p>AbstractApplicationContext.java中有一个refresh()方法就是模板方法，它用于根据流程调用aop代理创建、bean生命周期初始化、属性注入等启动并初始化Spring应用上下文的方法。</p><blockquote><p><strong>AbstractApplicationContext</strong>抽象类是ApplicationContext接口的一种默认实现，提供了一些<strong>通用的应用上下文功能</strong>，同时也为其他具体的应用上下文实现类提供了一些可扩展的方法。</p><p><strong>应用上下文：</strong>负责管理各种bean以及它们之间的关系，并对它们进行生命周期的管理。 </p></blockquote><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250728171446139.png" alt="image-20250728171446139"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            postProcessBeanFactory(beanFactory);     <span class="comment">// 钩子方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            initMessageSource();</span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            onRefresh();                             <span class="comment">// 钩子方法</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            destroyBeans();</span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    refreshBeanFactory(); <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory(); <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUC包下的AQS抽象队列同步器"><a href="#JUC包下的AQS抽象队列同步器" class="headerlink" title="JUC包下的AQS抽象队列同步器"></a>JUC包下的AQS抽象队列同步器</h2><p>AQS是基于模板方法模式进行设计的。锁的实现类需要继承AQS并重写它指定的方法。</p><p>AQS的模板方法将“<strong>管理同步状态的逻辑</strong>”提炼出来形成标准流程，这些方法主要包括：独占式获取同步状态、独占式释放同步状态、共享式获取同步状态、共享式释放同步状态。 </p><p><strong>AQS（AbstractQueuedSynchronizer抽象队列同步器）</strong>：</p><p>AQS是实现锁或者其他同步器（用于协调线程之间对共享资源的访问）的核心框架。AQS是一个抽象类，在<code>JUC.locks</code>包下，它通过内部的状态变量和同步队列来实现线程的同步（允许多个线程协作共享访问共享资源）。很多锁和同步器都是基于AQS实现的。ReentrantLock，ThreadPoolExecutor，CountDownLatch等都是基于AQS实现。</p><ul><li><p><strong>ReentrantLock：</strong>可重入锁，同一个线程在持有锁的情况下，可以重复地获取该锁，无需等待，只需记录重入次数。能防止死锁，因为不用线程自己等待自己释放锁。是Lock接口的实现类。可以通过构造参数true或false指定公平锁或非公平锁，可以通过newCondition()方法创建多个Condition对象分组唤醒等待线程。</p><ul><li><p><strong>公平锁：</strong>按加锁顺序获取锁。线程竞争锁时判断AQS队列里有没有等待线程，有就加入队尾。</p></li><li><p><strong>非公平锁（默认）：</strong>可能某个线程会不断获取锁，牺牲公平的情况下提高了效率。不管AQS队列里有没有等待线程，都会先尝试获取锁；如果抢占不到，再加入队尾。如果线程刚好在上个线程释放时拿到锁，就不用像公平锁那样还要阻塞等待、放队尾、唤醒，这些操作涉及到对内核的切换，对性能有影响。</p></li><li><p><strong>Condition对象：</strong>用于线程间通信，通过await()和signal(),signalAll()让线程等待或唤醒。通常用lock锁创建Condition对象，即lock.newCondition();</p></li></ul></li><li><p><strong>CountDownLatch：</strong>计数器，它允许一个或多个线程等待其他线程完成操作后再执行。countDown()方法让计数器减一，await()方法阻塞当前线程直到计数器减为0。</p></li><li><p><strong>ThreadPoolExecutor。</strong></p></li></ul><p><strong>state变量和等待队列：</strong></p><ul><li><strong>state变量：</strong>在AQS中，volatile类型的state变量表示锁的状态，通过CAS原子操作这个状态变量来保证线程安全。初始是0，代表没拿到锁，1代表拿到锁。</li><li><strong>同步队列：</strong>在AQS中，FIFO（先入先出）队列用来管理等待锁的线程，队列每个节点记录等待锁的线程的地址、状态、等待锁的条件。先入先出确保同步器的公平性，也就是先等待的线程先获得锁。队列底层是双向链表。</li></ul><p><strong>实现线程同步的原理：</strong>线程通过CAS原子性修改state变量，修改成功则获得锁，失败则插入队尾等待。  </p><p><strong>基于模板方法：</strong>AQS是基于模板方法模式进行设计的。锁的实现类需要继承AQS并重写它指定的方法。</p><p><strong>模板方法：</strong>抽象类有一个模板方法和其他行为方法，模板方法按流程调用各行为方法（抽象或非抽象）；具体子类重写抽象的行为方法。 </p><hr><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="天气预报需求"><a href="#天气预报需求" class="headerlink" title="天气预报需求"></a>天气预报需求</h2><p>具体要求如下：</p><ol><li>气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去（比如发布到自己的网站或第三方）</li><li>需要<strong>设计开放型 API</strong>，便于其他<strong>第三方也能接入气象站获取数据</strong></li><li>提供温度、气压和湿度的接口</li><li><strong>测量数据更新时，要能实时的通知给第三方</strong></li></ol><h2 id="天气预报需求方案之普通方案"><a href="#天气预报需求方案之普通方案" class="headerlink" title="天气预报需求方案之普通方案"></a>天气预报需求方案之普通方案</h2><p><strong>WeatherData类</strong></p><p>通过对气象站项目的分析，我们可以初步设计出一个天气数据类WeatherData类</p><ol><li>通过<code>getXxx</code>方法，可以让第三方接入，并得到相关信息</li><li>当数据有更新时，气象站通过调用<strong>dataChange()去更新数据</strong>，当第三方再次获取时，就能得到最新数据，当然也可以推送</li></ol><p>CurrentConditions（当前的天气情况）可以理解成是我们气象局的网站</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的天气情况：可以理解成是气象局的网站</span></span><br><span class="line"><span class="comment">// 当前天气状况类，即气象网，用于展示天气数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditions</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line">    <span class="comment">// 更新天气情况，通过推送的方式，由 WeatherData 调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新最新天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">// 展示最新天气数据</span></span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公告板展示天气情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============最新天气============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前温度：&quot;</span> + <span class="built_in">this</span>.temperature + <span class="string">&quot; ℃ ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前气压：&quot;</span> + <span class="built_in">this</span>.pressure + <span class="string">&quot; kPa ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前湿度：&quot;</span> + <span class="built_in">this</span>.humidity + <span class="string">&quot; %RH ***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 天气数据类</span></span><br><span class="line"><span class="comment">// 包含最新的天气信息情况，含有 CurrentConditions 对象，当数据更新时，主动调用 CurrentConditions 的 update() 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line">    <span class="keyword">private</span> CurrentConditions conditions;</span><br><span class="line">    <span class="comment">// 传入 CurrentConditions 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">(CurrentConditions conditions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conditions = conditions;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temperature, pressure, humidity getter</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推送天气数据到网站</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataChange</span><span class="params">()</span> &#123;</span><br><span class="line">        conditions.update(getTemperature(), getPressure(), getHumidity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当天气数据发生变化时进行更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        dataChange();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建气象网站对象</span></span><br><span class="line"><span class="type">CurrentConditions</span> <span class="variable">currentConditions</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditions</span>();</span><br><span class="line"><span class="comment">// 创建气象数据对象，并传入气象网站对象</span></span><br><span class="line"><span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>(currentConditions);</span><br><span class="line"><span class="comment">// 天气发生变化时，更新最新的气象数据</span></span><br><span class="line">weatherData.setData(<span class="number">10f</span>, <span class="number">150f</span>, <span class="number">40f</span>);</span><br><span class="line"><span class="comment">//weatherData.setData(15f, 130f, 60f);</span></span><br><span class="line"><span class="comment">//weatherData.setData(13f, 160f, 20f);</span></span><br><span class="line"><span class="comment">// 结果输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">============最新天气============</span></span><br><span class="line"><span class="comment">*** 当前温度：10.0 ℃ ***</span></span><br><span class="line"><span class="comment">*** 当前气压：150.0 kPa ***</span></span><br><span class="line"><span class="comment">*** 当前湿度：40.0 %RH ***</span></span><br><span class="line"><span class="comment">============最新天气============</span></span><br><span class="line"><span class="comment">*** 当前温度：15.0 ℃ ***</span></span><br><span class="line"><span class="comment">*** 当前气压：130.0 kPa ***</span></span><br><span class="line"><span class="comment">*** 当前湿度：60.0 %RH ***</span></span><br><span class="line"><span class="comment">============最新天气============</span></span><br><span class="line"><span class="comment">*** 当前温度：13.0 ℃ ***</span></span><br><span class="line"><span class="comment">*** 当前气压：160.0 kPa ***</span></span><br><span class="line"><span class="comment">*** 当前湿度：20.0 %RH ***</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>问题分析</strong></p><ol><li>其他第三方接入气象站获取数据的问题</li><li>无法在运行时动态的添加第三方（如xx网站）</li><li>违反<code>OCP</code>原则 =&gt; <strong>观察者模式</strong></li></ol><p>在<code>WeatherData</code>中增加第三方时，都需要创建对应的第三方公台板对象并加入到<code>dataChange()</code>方法中，既不是动态加入，也不利于维护</p><h2 id="观察者模式介绍"><a href="#观察者模式介绍" class="headerlink" title="观察者模式介绍"></a>观察者模式介绍</h2><p>观察者模式是一种<strong>行为型设计模式（</strong>用于描述对象之间的通信和责任分配<strong>）</strong>，它定义了对象之间<strong>一对多</strong>的依赖关系，使得当主题对象状态发生改变时，所有依赖于它的观察者对象都能够<strong>得到通知并自动更新</strong>。该模式的核心是抽象对象与观察者之间的耦合度达到了最小化，从而使系统更加灵活且易于扩展。</p><p><strong>实现方法：</strong></p><ol><li>主题对象实现主题接口的注册、移除、通知方法，并管理资源和观察者列表；</li><li>观察者对象实现观察者接口的更新方法，并管理资源；</li><li>主题对象通知方法：遍历观察者列表执行更新方法。</li></ol><p>在观察者模式中，<strong>主题对象</strong>（也称为被观察者）<strong>维护一个观察者列表</strong>，并提供方法用于<strong>添加、删除和通知观察者</strong>。当主题状态发生改变时，它会遍历观察者列表并调用每个观察者的更新方法，从而通知它们状态已经改变。</p><ul><li>主题接口：有注册、移除和通知功能；</li><li>主题实现类：实现主题接口，管理资源和观察者列表；</li><li>观察者接口：发起更新资源请求；</li><li>观察者实现类：发起更新资源请求、使用资源</li></ul><p><strong>优点：</strong></p><ol><li><strong>降低了对象之间的耦合度</strong>，因为主题对象不需要知道观察者的具体实现，只需要知道观察者实现了一个特定接口即可。</li><li>可以<strong>动态扩展观察者列表</strong>，方便灵活。</li><li>实现了对象之间的<strong>一对多</strong>依赖关系，提高了系统的<strong>可维护性和可重用性</strong>。遵守了<strong>ocp原则（开闭原则</strong>：对扩展开放，对修改关闭）。</li></ol><p><strong>缺点</strong>：</p><ol><li>当观察者过多时，通知过程需要花费较多的时间，会影响系统的性能。</li><li>如果观察者与主题对象之间存在<strong>循环依赖</strong>，可能会出现<strong>死循环</strong>。</li></ol><p>观察者模式在Java中的应用非常广泛，例如Swing中的Listener、Servlet中的Listener、Spring中的事件监听、JDK的Observable等等。</p><h2 id="观察者模式优化天气预报案例"><a href="#观察者模式优化天气预报案例" class="headerlink" title="观察者模式优化天气预报案例"></a>观察者模式优化天气预报案例</h2><p>Subject接口：主体接口，有注册、移除和通知功能；</p><p>WeatherData类：主体实现类，实现Subject接口，聚合观察者列表，管理天气信息和观察者列表；</p><p>Observer接口：观察者接口，发起更新天气信息请求；</p><p>CurrentCondition类：观察者实现类，发起更新天气信息请求和使用天气</p><p><strong>主题Subject</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主体对象接口，有注册、移除和通知功能；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;    <span class="comment">// 注册某观察者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;    <span class="comment">// 移除某观察者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;                <span class="comment">// 通知</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主体对象实现，聚合观察者列表，管理天气信息和观察者列表；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        observerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temperature, pressure, humidity getter</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推送天气数据到网站</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataChange</span><span class="params">()</span> &#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当天气数据发生变化时进行更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        dataChange();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册某观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observerList.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除某观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o!= <span class="literal">null</span> &amp;&amp; observerList.contains(o)) &#123;</span><br><span class="line">            observerList.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observerList) &#123;</span><br><span class="line">            observer.update(temperature, pressure, humidity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察者对象Observer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者接口，发起更新天气信息请求；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Float temperature, Float pressure, Float humidity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者实现，发起更新天气信息请求和使用天气</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditions</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新最新天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">// 展示最新天气数据</span></span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公告板展示天气情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============最新天气============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前温度：&quot;</span> + <span class="built_in">this</span>.temperature + <span class="string">&quot; ℃ ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前气压：&quot;</span> + <span class="built_in">this</span>.pressure + <span class="string">&quot; kPa ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 当前湿度：&quot;</span> + <span class="built_in">this</span>.humidity + <span class="string">&quot; %RH ***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建气象网站对象</span></span><br><span class="line"><span class="type">CurrentConditions</span> <span class="variable">currentConditions</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditions</span>();</span><br><span class="line"><span class="comment">// 创建气象数据对象</span></span><br><span class="line"><span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line"><span class="comment">// 注册气象网站对象</span></span><br><span class="line">weatherData.registerObserver(currentConditions);</span><br><span class="line"><span class="comment">// 天气发生变化时，更新最新的气象数据</span></span><br><span class="line">weatherData.setData(<span class="number">10f</span>, <span class="number">150f</span>, <span class="number">40f</span>);</span><br><span class="line"><span class="comment">//============最新天气============</span></span><br><span class="line"><span class="comment">//*** 当前温度：10.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 当前气压：150.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 当前湿度：40.0 %RH ***</span></span><br></pre></td></tr></table></figure><p><strong>观察者模式的好处</strong></p><ul><li>观察者模式设计后，会以集合的方式来管理用户<code>Observer</code>，包括注册、移除和通知</li><li>这样<strong>增加观察者</strong>（新的公告板）时，就不需要去修改核心类<code>WeatherData</code>不会修改代码，遵守了 OCP 原则（开闭原则）</li></ul><p>新增<code>SinaWebSite</code>和<code>BaiDuWebSite</code>两个三方网站，接口气象局。此时三方只需实现相应接口即可，<code>WeatherData</code>不需要有任何的改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增的三方观察者对象——新浪网</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinaWebSite</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line">    <span class="comment">// 更新天气情况，通过推送的方式，由 WeatherData 调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新最新天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">// 展示最新天气数据</span></span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公告板展示天气情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============新浪网-最新天气============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 新浪网-当前温度：&quot;</span> + <span class="built_in">this</span>.temperature + <span class="string">&quot; ℃ ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 新浪网-当前气压：&quot;</span> + <span class="built_in">this</span>.pressure + <span class="string">&quot; kPa ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 新浪网-当前湿度：&quot;</span> + <span class="built_in">this</span>.humidity + <span class="string">&quot; %RH ***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增的三方观察者对象——百度网</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaiDuWebSite</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Float temperature;</span><br><span class="line">    <span class="keyword">private</span> Float pressure;</span><br><span class="line">    <span class="keyword">private</span> Float humidity;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 更新天气情况，通过推送的方式，由 WeatherData 调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Float temperature, Float pressure, Float humidity)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新最新天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">// 展示最新天气数据</span></span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 公告板展示天气情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============百度网-最新天气============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 百度网-当前温度：&quot;</span> + <span class="built_in">this</span>.temperature + <span class="string">&quot; ℃ ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 百度网-当前气压：&quot;</span> + <span class="built_in">this</span>.pressure + <span class="string">&quot; kPa ***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*** 百度网-当前湿度：&quot;</span> + <span class="built_in">this</span>.humidity + <span class="string">&quot; %RH ***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>调用测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增三方气象网站，只需注册即可</span></span><br><span class="line">weatherData.registerObserver(<span class="keyword">new</span> <span class="title class_">SinaWebSite</span>());</span><br><span class="line">weatherData.registerObserver(<span class="keyword">new</span> <span class="title class_">BaiDuWebSite</span>());</span><br><span class="line"><span class="comment">// 天气发生变化时，更新最新的气象数据</span></span><br><span class="line">weatherData.setData(<span class="number">15f</span>, <span class="number">120f</span>, <span class="number">80f</span>);</span><br><span class="line"><span class="comment">//============最新天气============</span></span><br><span class="line"><span class="comment">//*** 当前温度：15.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 当前气压：120.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 当前湿度：80.0 %RH ***</span></span><br><span class="line"><span class="comment">//============新浪网-最新天气============</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前温度：15.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前气压：120.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前湿度：80.0 %RH ***</span></span><br><span class="line"><span class="comment">//============百度网-最新天气============</span></span><br><span class="line"><span class="comment">//*** 百度网-当前温度：15.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 百度网-当前气压：120.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 百度网-当前湿度：80.0 %RH ***</span></span><br></pre></td></tr></table></figure><p>当三方网站不再需要时，只要做相应的移除即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除气象网站</span></span><br><span class="line">weatherData.removeObserver(currentConditions);</span><br><span class="line">weatherData.setData(<span class="number">20f</span>, <span class="number">160f</span>, <span class="number">30f</span>);</span><br><span class="line"><span class="comment">//============新浪网-最新天气============</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前温度：20.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前气压：160.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 新浪网-当前湿度：30.0 %RH ***</span></span><br><span class="line"><span class="comment">//============百度网-最新天气============</span></span><br><span class="line"><span class="comment">//*** 百度网-当前温度：20.0 ℃ ***</span></span><br><span class="line"><span class="comment">//*** 百度网-当前气压：160.0 kPa ***</span></span><br><span class="line"><span class="comment">//*** 百度网-当前湿度：30.0 %RH ***</span></span><br></pre></td></tr></table></figure><h2 id="JDK-的Observable类和Observer类"><a href="#JDK-的Observable类和Observer类" class="headerlink" title="JDK 的Observable类和Observer类"></a>JDK 的Observable类和Observer类</h2><p>JDK提供观察者模式基础功能的主题抽象类和观察者接口：</p><p><strong>Observable抽象类</strong> </p><p>JDK中的Observable抽象类可<strong>作为实现观察者模式的一种工具</strong>，<strong>用于构建主题</strong>（被观察者）<strong>对象</strong>，并且可将多个观察者对象添加到主题。主题发生变化时，调用Observable类的notifyObservers()方法，可以通知所有观察者对象进行更新，从而实现一对多依赖关系。</p><p>Observable类的主要作用是<strong>简化</strong>观察者模式的实现过程，<strong>将观察者模式的基础部分已经实现</strong>，程序员只需要编写具体的业务逻辑即可。addObserver()、deleteObserver()和notifyObservers()。</p><p>但需要注意，JDK中的Observable类并<strong>不是非常灵活和易于扩展</strong>，它<strong>只提供了简单的实现方式</strong>。因此，在实际的项目中有时会采用其他方案实现观察者模式，例如使用事件模型、Spring框架中的<code>ApplicationEvent</code>等。</p><p>总之，JDK中的Observable类可以作为一种工具来支持观察者模式的实现，它简化了观察者模式的编写，提高了代码的可读性和可维护性。但实际应用中需要根据实际情况选择最适合的实现方案。</p><p><strong>Observer类</strong></p><p>Observer即观察者接口，具有update()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs = <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Observable</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer var1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.obs.contains(var1)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.obs.addElement(var1);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deleteObserver</span><span class="params">(Observer var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obs.removeElement(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.notifyObservers((Object)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>责任链模式类似一个链表，每个具体处理人层层判断对请求的处理权限，没权限的话把请求交给下一个具体处理人。</p><p><strong>抽象处理人：</strong>成员变量是资源和下一个抽象处理人，通过setNext()设置下一个抽象处理人（后面会多态形式传参具体处理人），通过process()方法处理资源。</p><p><strong>具体处理人：</strong>层层判断处理权限，没权限的话把请求交给下一个具体处理人，有权限就process()方法处理资源。</p><p><strong>测试方法：</strong>创建每个具体处理人对象，通过setNext()按处理人权限把每个对象串起来。</p><h2 id="传统方案，OA系统的采购审批项目"><a href="#传统方案，OA系统的采购审批项目" class="headerlink" title="传统方案，OA系统的采购审批项目"></a>传统方案，OA系统的采购审批项目</h2><p>学校 OA 系统的采购审批项目，需求是</p><ol><li><p>采购员采购教学器材</p></li><li><p>如果金额小于等于 5000，由教学主任审批（0 &lt; x ≤ 5000）</p></li><li><p>如果金额小于等于 10000，由院长审批（5000 &lt; x ≤ 10000）</p></li><li><p>如果金额小于等于 30000，由副校长审批（10000&lt; x ≤ 30000）</p></li><li><p>如果金额超过 30000 以上，有校长审批（30000  &lt; x）</p></li></ol><p><strong>传统方案解决 OA 系统审批问题分析</strong></p><p><strong>传统方式是：</strong>接收到一个<strong>采购请求</strong>后，<strong>根据采购金额来调用</strong>对应的<code>Approver</code>（审批人）完成审批</p><p><strong>传统方式的问题分析：</strong>客户端这里会使用到分支判断（比如<code>switch</code>）来对不同的采购请求处理，这样就存在如下问题</p><ol><li>如果<strong>各个级别的人员审批金额发生变化</strong>，在客户端的也需要变化</li><li>客户端必须明确的知道有多少个审批级别和访问</li></ol><p>这样对一个采购请求进行处理和<code>Approver</code>（审批人）就存在<strong>强耦合</strong>关系，不利于代码的扩展和维护</p><p><strong>解决方案：职责链模式</strong></p><h2 id="职责链模式基本介绍"><a href="#职责链模式基本介绍" class="headerlink" title="职责链模式基本介绍"></a>职责链模式基本介绍</h2><p>职责链模式（Chain of Responsibility Pattern），又叫责任链模式：<strong>为请求创建了一个接收者对象的链</strong>。</p><ol><li>这种模式对请求的发送者和接收者进行<strong>解耦</strong></li><li>职责链模式通常<strong>每个接收者都包含对另一个接收者的引用</strong>。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。如果最后接收者也无法处理，就返回“无法处理”，或者抛出异常。</li></ol><p><strong>原理类图</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250728174508547.png" alt="image-20250728174508547"></p><p>职责链模式使<strong>多个对象都有机会处理请求</strong>，从而避免请求的发送者和接收者之间的耦合关系</p><p>将这个<strong>对象连成一条链</strong>，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><ul><li><strong>Handler抽象处理者：</strong>是一个抽象类或接口，里面包含一个处理请求的抽象方法，和另外一个Handler作为成员变量。Handler依赖请求，客户端把请求发给Handler。上面案例里每个审批者抽象的接口是Handler。</li><li><strong>ConcreteHandler具体处理者：</strong>是Handler的实现类，处理自己负责的请求，同时可以访问它的<strong>后继者</strong>（即下一个处理者） ；如果可以处理请求，则进行处理，否则交给后继者去处理，从而形成一个职责链。上面案例里每个审批者都是一个具体处理者。</li><li><strong>Request请求：</strong>含有很多属性，表示一个请求。上面案例里采购员采购是一个请求。</li></ul><p><strong>注意事项和细节</strong></p><ul><li>将<strong>请求和处理分开</strong>，实现解耦，提高系统的灵活性</li><li>简化了对象，使对象不需要知道链的结构，<strong>对象自己不知道下一个结点是谁</strong>（迪米特法则/最少知道原则）</li><li><strong>性能会受到影响</strong>，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在<code>Handler</code>中设置一个最大节点数量，在<code>setNext()</code>方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li><li><strong>调试不方便</strong>。采用了类似递归的方式，调试时逻辑可能比较复杂</li><li><strong>最佳应用场景：</strong>有多个对象可以处理同一个请求时，比如：<strong>多级请求、请假 / 加薪等审批流程</strong>、Java Web 中 Tomcat 对<code>Encoding</code>的处理、拦截器</li></ul><h2 id="职责链模式解决-OA-系统采购审批项目"><a href="#职责链模式解决-OA-系统采购审批项目" class="headerlink" title="职责链模式解决 OA 系统采购审批项目"></a>职责链模式解决 OA 系统采购审批项目</h2><p><strong>购买请求类：</strong>有id和价格两个成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采购申请类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PurchaseRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PurchaseRequest</span><span class="params">(Integer id, Float price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// id,price getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象审批人类：</strong>成员变量有姓名和下一个抽象审批人，方法有处理请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象审批人对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Approver nextApprover;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Approver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置后继者,@param nextApprover</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextApprover</span><span class="params">(Approver nextApprover)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextApprover = nextApprover;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理请求的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体审批人对象：</strong>主任、院长等具体审批人，继承抽象审批人，实现处理请求的方法，如果请求中金额自己能审批则审批，如果金额不能审批则把请求交给下一个具体人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 教学主任审批人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeachDirectorApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeachDirectorApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求编号：&quot;</span> + purchaseRequest.getId() + <span class="string">&quot;，处理人：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextApprover.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 院长审批人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentHeadApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepartmentHeadApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="number">5000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求编号：&quot;</span> + purchaseRequest.getId() + <span class="string">&quot;，处理人：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextApprover.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 副校长审批人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViceChancellorApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViceChancellorApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="number">10000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="number">30000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求编号：&quot;</span> + purchaseRequest.getId() + <span class="string">&quot;，处理人：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextApprover.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 校长审批人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChancellorApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChancellorApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="number">30000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求编号：&quot;</span> + purchaseRequest.getId() + <span class="string">&quot;，处理人：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextApprover.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个请求。id是1，价格是31000.0f</span></span><br><span class="line"><span class="type">PurchaseRequest</span> <span class="variable">purchaseRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PurchaseRequest</span>(<span class="number">1</span>, <span class="number">31000.0f</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建相关的审批人</span></span><br><span class="line"><span class="type">TeachDirectorApprover</span> <span class="variable">teachDirectorApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeachDirectorApprover</span>(<span class="string">&quot;童主任&quot;</span>);</span><br><span class="line"><span class="type">DepartmentHeadApprover</span> <span class="variable">departmentHeadApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentHeadApprover</span>(<span class="string">&quot;王院长&quot;</span>);</span><br><span class="line"><span class="type">ViceChancellorApprover</span> <span class="variable">viceChancellorApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViceChancellorApprover</span>(<span class="string">&quot;钱副校长&quot;</span>);</span><br><span class="line"><span class="type">ChancellorApprover</span> <span class="variable">chancellorApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChancellorApprover</span>(<span class="string">&quot;郑校长&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置后继者（处理人形成环形）</span></span><br><span class="line">teachDirectorApprover.setNextApprover(departmentHeadApprover);</span><br><span class="line">departmentHeadApprover.setNextApprover(viceChancellorApprover);</span><br><span class="line">viceChancellorApprover.setNextApprover(chancellorApprover);</span><br><span class="line">chancellorApprover.setNextApprover(teachDirectorApprover);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 发起一个请求</span></span><br><span class="line">teachDirectorApprover.processRequest(purchaseRequest); <span class="comment">// 请求编号：1，处理人：郑校长</span></span><br></pre></td></tr></table></figure><h2 id="职责链模式在-SpringMVC-框架应用的源码分析"><a href="#职责链模式在-SpringMVC-框架应用的源码分析" class="headerlink" title="职责链模式在 SpringMVC 框架应用的源码分析"></a>职责链模式在 SpringMVC 框架应用的源码分析</h2><p><code>SpringMVC</code>中<code>HandlerExecutionChain</code>类就使用到了职责链模式</p><p>首先，需要回顾下<code>SpringMVC</code>基本的请求流程，如下图所示</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250728175219902.png" alt="image-20250728175219902"></p><p>首先，当用户会发起一个request请求到后台，这个request请求首先会经过DispatcherServlet，DispatcherServlet对象首先会遍历接收到的HandlerMapping集合，然后再找到对应的HandlerMapping集合，并得到HandlerExecutionChain对象。这个HandlerExecutionChain对象内部包含了一些拦截器。拿到HandlerInterceptor拦截器过后，有以下几个操作</p><ul><li><p>首先会调用<code>HandlerInterceptor</code>中的<code>preHandle()</code>方法</p></li><li><p>然后会调用<code>HandlerInterceptor</code>中的<code>postHandle()</code>方法</p></li><li><p>最后会调用<code>HandlerInterceptor</code>中的<code>afterCompletion()</code>方法</p></li></ul><p>现在对<code>SpringMVC</code>进行源码分析，首先需要引入<code>SpringMVC</code>相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">org.springframework.version</span>&gt;</span>4.3.7.RELEASE<span class="tag">&lt;/<span class="name">org.springframework.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，探究其如何调用<code>HandlerInterceptor</code>拦截器中的这三个方法</p><ol><li><p><strong>在DispatcherServlet中找到doDispatch()方法，发现该方法中定义了一个HandlerExecutionChain对象</strong></p><p>源码分析mappedHandler是如何调用preHandle()、postHandle()和afterCompletion()三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!mappedHandler.applyPreHandle(processedRequest, response))&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span>(asyncManager.isConcurrentHandlingStarted())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">applyDefaultViewName(processedRequest，mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest,response, mv);</span><br></pre></td></tr></table></figure><p>在后续的代码逻辑中，调用了getHandler()方法，接收一个processedRequest请求对象作为参数，得到初始化的HandlerExecutionChain对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    processedRequest =checkMultipart(request);</span><br><span class="line">    multipartRequestParsed =(processedRequest !=request);</span><br><span class="line">    <span class="comment">// Determine handler for the current request</span></span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler == nulll mappedHandler.getHandler()== <span class="literal">null</span>) &#123;</span><br><span class="line">        noHandlerFound(processedRequest,response);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终找到两段代码，很像上述所说的preHandle()和postHandle()两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br></pre></td></tr></table></figure><p>首先会执行mappedHandler的applyPreHandle()方法：如果返回为false，则判断成立，后续代码不再执行；否则继续往下执行，调用mappedHandler的applyPostHandle()方法</p></li><li><p><strong>先看下<code>applyPreHandle()</code>方法的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line"> <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">         <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">         <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">             triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>applyPreHandle</code>方法内部首先会拿到一组<code>interceptors</code>拦截器，当拦截器数组不为空时，进行如下处理：</p><ul><li>首先对<code>interceptors</code>拦截器进行了<code>for</code>循环遍历，拿到每一个具体的<code>interceptor</code>拦截器</li><li>接着调用了<code>interceptor</code>的<code>preHandle()</code>方法，如果返回<code>false</code>，则执行<code>triggerAfterCompletion()</code>方法并进行<code>return</code>，此方法结束；否则继续执行相关处理</li></ul></li><li><p><strong>接着看下<code>triggerAfterCompletion()</code>方法的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Exception ex)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中逻辑跟applyPreHandle()方法很相似：先对一组interceptors拦截器进行遍历，再执行interceptor单个拦截器的afterCompletion()方法</p></li><li><p><strong>最后看下applyPostHandle()方法的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">            interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中逻辑跟上述方法也基本一致：先对一组interceptors拦截器进行遍历，再执行interceptor单个拦截器的postHandle()方法。</p></li></ol><p><strong>总结</strong></p><ul><li>SpringMVC请求的流程图中，执行了拦截器相关方法，如interceptor.preHandler()</li><li>在处理SpringMVC请求时，使用到职责链模式和适配器模式</li><li>HandlerExecutionChain：主要负责请求拦截器的执行和请求处理，但是本身不处理请求，只是将请求分配给 链上注册处理器 执行。这是职责链实现方式，减少职责链本身与处理逻辑之间的耦合，规范了处理流程</li><li>HandlerExecutionChain：维护了Handlerlnterceptor的集合，可以向其中注册相应的拦截器</li></ul><h2 id="职责链模式在Sentinel中的应用"><a href="#职责链模式在Sentinel中的应用" class="headerlink" title="职责链模式在Sentinel中的应用"></a>职责链模式在Sentinel中的应用</h2><p><strong>责任链模式：</strong>sentinel在内部创建了一个责任链，责任链是由一系列ProcessorSlot接口的实现类组成的，每个ProcessorSlot对象负责不同的功能，外部请求想要访问资源需要责任链层层校验和处理。每个具体处理人有权限（例如配置过降级规则DegradeSlot有权限）则校验，没权限则交给下一个具体处理人。只有校验通过才可以访问资源，如果校验失败，会抛出BlockException异常。</p><p><strong>校验顺序：</strong>降级、黑白名单、构建ClusterNode对象（统计QPS,RT等）、校验QPS,RT等、流控、打印日志</p><p><strong>ProcessorSlot接口（抽象处理人）：</strong>是一个基于责任链模式的接口，定义了一个entry()方法，用于处理入口参数和出口参数的限流和降级逻辑；一个exit()方法，用于将权限交给下一个抽象处理人（实际会传参具体处理人）。</p><p><strong>ProcessorSlot实现类（具体处理人）：</strong></p><ul><li><strong>DegradeSlot：</strong>用于服务降级。如果发现服务超时次数或者报错次数超过限制，DegradeSlot将禁止再次访问服务，等待一段时间后，DegradeSlot试探性的放过一个请求，然后根据该请求的处理情况，决定是否再次降级。</li><li><strong>AuthoritySlot：</strong>黑白名单校验，按照字符串匹配，如果在黑名单，则禁止访问。</li><li><strong>ClusterBuilderSlot：</strong>构建ClusterNode对象，该对象用于统计访问资源的QPS、线程数、异常、响应时间等，每个资源对应一个ClusterNode对象。</li><li><strong>SystemSlot：</strong>校验QPS、并发线程数、系统负载、CPU使用率、平均响应时间是否超过限制，使用滑动窗口算法统计上述数据。</li><li><strong>StatisticSlot：</strong>用于多维度（入口流量、调用者、当前被访问资源）统计响应时间、并发线程数、处理失败个数、处理成功个数等。</li><li><strong>FlowSlot：</strong>用于流控，可以根据QPS或者每秒并发线程数控制，当QPS或者并发线程数超过设定值，便会抛出FlowException异常。FlowSlot依赖于StatisticSlot的统计数据。</li><li><strong>NodeSelectorSlot：</strong>收集资源路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级、数据统计。</li><li><strong>LogSlot：</strong>打印日志。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 &lt;em&gt;Gang of Four&lt;/em&gt; (&lt;em&gt;GoF&lt;/em&gt;) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型模式</title>
    <link href="https://southernfish.github.io/2025/07/28/java/java-design-pattern-structural/"/>
    <id>https://southernfish.github.io/2025/07/28/java/java-design-pattern-structural/</id>
    <published>2025-07-28T07:56:36.000Z</published>
    <updated>2025-07-28T10:27:55.454Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><p><strong>结构型模式</strong>（Structural Patterns）：主要<strong>用于描述对象之间的组合关系</strong>，包括多个不同的模式，如“代理模式”、“适配器模式”、“桥接模式”、“装饰者模式”、“外观模式”、“享元模式”和“组合模式”等。这些模式可以帮助我们更好地设计程序结构，提高代码灵活性和可维护性。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130440147">设计模式——代理模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/143056317">【设计模式】结合Tomcat源码，分析外观模式/门面模式的特性和应用场景</a></p></blockquote><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="代理模式的基本介绍"><a href="#代理模式的基本介绍" class="headerlink" title="代理模式的基本介绍"></a>代理模式的基本介绍</h2><p>代理模式：为一个对象提供一个<strong>替身</strong>，以控制对这个对象的访问。即<strong>通过代理对象访问目标对象</strong></p><p>代理模式是结构型设计模式（用于描述对象之间的组合关系）。</p><p><strong>好处：</strong>可以在目标对象实现的基础上，增强额外的功能操作，即<strong>扩展目标对象的功能</strong></p><p>被代理的对象可以是<strong>远程对象</strong>、创建开销大的对象或需要<strong>安全控制</strong>的对象（代理时对目标对象进行安全控制）</p><p>我们并不希望客户端直接调用目标对象，而是通过代理对象对目标对象实现安全控制或增强功能。所以客户端直接依赖代理对象，代理对象依赖目标对象.</p><p>代理模式有不同的形式，主要有三种：<strong>静态代理、JDK动态代理、Cglib 代理</strong></p><p><strong>静态代理：</strong></p><p>目标对象与代理对象实现租同的接口或继承相同的父类，在编译时生成代理对象。</p><p>目标对象实现代理接口，代理对象实现并聚合代理接口，重写方法编写增强后逻辑。</p><p><strong>JDK动态代理：</strong></p><p>通过Java<strong>反射机制</strong>在运行时动态地在内存中生成代理对象。 目标对象需要实现代理接口。目标对象实现代理接口，<strong>代理工厂</strong>通过Proxy类的静态方法<code>newProxyInstance()</code>，利用反射机制返回代理对象实例。 </p><p><strong><code>newProxyInstance()</code>三个参数</strong>：目标对象的类加载器、目标对象的接口、实现<code>InvocationHandler</code>接口并重写<code>invoke()</code>方法，编写代理对象逻辑。</p><p><strong>应用</strong>：<strong>Spring AOP</strong>采用了动态代理的方式，在运行时动态的创建代理对象来实现增强。</p><p><strong>Cglib 代理：</strong></p><p>在<strong>内存</strong>中构建一个<strong>子类对象</strong>以实现对目标对象功能扩展。目标对象不需要实现代理接口。底层通过ASM框架转换字节码并生成新的类。</p><p>代理工厂类实现<code>MethodInterceptor</code>接口并重写<code>intercept()</code>方法编写代理逻辑，通过<code>cglib包</code>的<code>Enhancer</code>类设置父类字节码文件和创建子类对象来返回代理对象实例。</p><p>ASM框架是一个强大的Java字节码操作框架，可以让程序员通过代码生成和转换现有字节码来操作Java类。ASM可以直接生成字节码，也可以通过访问现有字节码来修改它。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理在使里时，需要定义接口或者父类，<strong>目标对象与代理对象实现租同的接口</strong>或继承相同的<strong>父类</strong>。</p><p><strong>实现方式：</strong>目标对象实现代理接口，代理对象实现并聚合代理接口，重写方法编写增强后逻辑。</p><p><strong>优缺点</strong></p><ul><li><p><strong>优点</strong>：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展</p></li><li><p><strong>缺点</strong>：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类。<strong>耦合性较高</strong>，一旦<strong>接口增加方法，目标对象与代理对象都要维护</strong></p></li></ul><p><strong>案例</strong></p><ol><li>定义一个<strong>接口：ITeacherDao</strong></li><li><strong>目标对象TeacherDao</strong>实现接口ITeacherDao</li><li>使用静态代理方式，就需要在代理对象TeacherDaoProxy中也实现ITeacherDao</li><li>调用的时候通过调用代理对象的方法来调用目标对象</li><li><strong>特别提醒</strong>：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;                        <span class="comment">// 代理对象和原始对象重写这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 目标对象，即被代理对象。实现代理借口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师授课中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理对象。实现代理借口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ITeacherDao iTeacherDao;    <span class="comment">// 接口引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeacherDaoProxy</span><span class="params">(ITeacherDao iTeacherDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.iTeacherDao = iTeacherDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备授课...&quot;</span>);</span><br><span class="line">        iTeacherDao.teach();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束授课...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建被代理对象</span></span><br><span class="line"><span class="type">TeacherDao</span> <span class="variable">teacherDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();</span><br><span class="line"><span class="comment">//创建代理对象，聚合被代理对象</span></span><br><span class="line"><span class="type">TeacherDaoProxy</span> <span class="variable">teacherDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDaoProxy</span>(teacherDao);</span><br><span class="line"><span class="comment">//通过代理对象，调用被代理对象的方法</span></span><br><span class="line">teacherDaoProxy.teach();</span><br></pre></td></tr></table></figure><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>Java中的动态代理是一种机制，它通过<strong>在程序运行时动态地生成代理对象</strong>，并在代理对象上进行方法调用，实现对目标对象方法的拦截与控制。动态代理是代理设计模式的一种实现方式，与静态代理不同的是，它<strong>不需要显示地编写代理类</strong>来代理被代理对象，而是通过<strong>Java反射机制</strong>在运行时动态生成代理类和代理对象。 </p><p><strong>实现方法：</strong></p><p>目标对象实现代理接口，<strong>代理工厂</strong>通过Proxy类的静态方法newProxyInstance()，利用反射机制返回代理对象实例。 </p><p>newProxyInstance()三个参数：目标对象的类加载器、目标对象的接口、实现InvocationHandler接口并重写invoke()方法，编写代理对象逻辑。</p><ul><li><strong>代理对象不需要实现接口</strong>，但是<strong>目标对象要实现接口</strong>，否则不能用动态代理</li><li>代理对象的生成，是利用 JDK 的 APl，动态的在<strong>内存中构建代理对象</strong></li><li>动态代理也叫做：JDK 代理、接口代理</li></ul><p>JDK提供了<code>java.lang.reflect.Proxy</code>类，可以通过它创建基于接口的动态代理对象。使用Proxy类的newProxyInstance静态方法，该方法需要接收三个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object <span class="title function_">newProxylnstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理接口和目标对象同上，目标对象需要实现代理接口</span></span><br><span class="line"><span class="comment">// ITeacherDao与TeacherDao同上</span></span><br><span class="line"><span class="comment">// 代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeacherFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">newProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">                                      target.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;JDK代理授课开始...&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;JDK代理授课结束...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> returnVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建目标对象</span></span><br><span class="line"><span class="type">ITeacherDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();</span><br><span class="line"><span class="comment">//给目标对象，创建代理对象，可以转成 ITeacherDao</span></span><br><span class="line"><span class="type">ITeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (ITeacherDao)<span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line"><span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());</span><br><span class="line"><span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">proxyInstance.teach();</span><br></pre></td></tr></table></figure><blockquote><p>其中几个参数</p><p>1）ClassLoader loader：指定当前目标对象使用的类加载器，获取加载器的方法固定<br>2）Class&lt;?&gt;[] interfaces：目标对象实现的接口类型，使用泛型方法确认类型<br>3）InvocationHandler h：事情处理，执行目标对象的方法时触发事情处理器方法，把当前执行的目标对象方法作为参数传入</p></blockquote><h2 id="Cglib-代理"><a href="#Cglib-代理" class="headerlink" title="Cglib 代理"></a>Cglib 代理</h2><p><strong>Cglib 代理</strong></p><p>静态 代理和 JDK 代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可<strong>使用目标对象子类来实现代理</strong>——这就是 Cglib 代理</p><p>Cglib 代理也叫作<strong>子类代理</strong>，它是<strong>在内存中构建一个子类对象从而实现对目标对象功能扩展</strong>，有些书也将 Cglib 代理归属到动态代理。</p><p><strong>使用方法：</strong></p><p>代理工厂类实现MethodInterceptor接口并重写intercept()方法编写代理逻辑，通过cglib包的Enhancer类设置父类字节码文件和创建子类对象来返回代理对象实例。</p><p><strong>Cglib包</strong></p><p>是一个强大的高性能的<strong>代码生成包</strong>，它可以在<strong>运行期扩展 java 类与实现 java 接口</strong>。它广泛的被许多 AOP 的框架使用，例如 Spring AOP，实现方法拦截。</p><p>Cglib 包的<strong>底层</strong>是通过使用<strong>ASM框架</strong>来<strong>转换字节码并生成新的类</strong></p><p><strong>ASM框架</strong></p><p>一个强大的Java字节码操作框架，可以让程序员通过代码生成和转换现有字节码来操作Java类。ASM可以直接生成字节码，也可以通过访问现有字节码来修改它。我们可以使用ASM来生成新的类、新的方法、字段、注解等。同时，ASM还允许我们在运行时改变现有的Java类的字节码，从而实现动态的Java类修改，例如添加方法、添加字段等。</p><blockquote><p>在 AOP 编程中如何选择代理模式：</p><ul><li>目标对象需要实现接口，用 JDK 代理</li><li>目标对象不需要实现接口，用 Cglib 代理</li></ul></blockquote><p><strong>案例：</strong></p><ol><li>引入<code>cglib</code>的 jar 文件（asm.jar，asm-commons.jar，asm-tree.jar，cglib-2.2jar）</li><li>在内存中动态构建子类，注意**代理的类不能为<code>final</code>**，否则报错<code>java.lang.IllegalArgumentException</code></li><li>标对象的方法如果为<code>final</code>/<code>static</code>，那么就不会被拦截，即不会执行目标对象额外的业务方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师授课中...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Good&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理工厂类，实现MethodInterceptor 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回代理对象实例。不是静态方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();         <span class="comment">// 1、创建工具类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());     <span class="comment">// 2、设置父类</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);                    <span class="comment">// 3、设置回调函数</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();                    <span class="comment">// 4、创建子类对象，即代理对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> </span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cglib代理开始...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;cglib代理结束...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代理模式的变体（应用场景）"><a href="#代理模式的变体（应用场景）" class="headerlink" title="代理模式的变体（应用场景）"></a>代理模式的变体（应用场景）</h2><p>几种常见的代理模式一<strong>几种变体</strong></p><ul><li><strong>防火墙代理</strong>：内网通过代理穿透防火墙，实现对公网的访问</li><li><strong>缓存代理：</strong>比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok；如果取不到资源，再到公网或者数据库取，然后缓存</li><li><strong>远程代理：</strong>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息（RPC）</li><li><strong>同步代理：</strong>主要使用在多线程编程中，完成多线程间同步工作</li></ul><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="经典的组建家庭影院流程"><a href="#经典的组建家庭影院流程" class="headerlink" title="经典的组建家庭影院流程"></a>经典的组建家庭影院流程</h2><p><strong>问题描述：</strong></p><ul><li>组建家庭影院过程：<ol><li>直接用遥控器：统筹各设备开关</li><li>开爆米花机</li><li>放下屏幕</li><li>开投影仪</li><li>开音响</li><li>开DVD，选dvd</li><li>去拿爆米花</li><li>调暗灯光</li><li>播放</li><li>观影结束后，关闭各种设备</li></ol></li><li><strong>需求</strong>：组建一个电影院，要求完成上述流程</li></ul><h2 id="传统方式解决影院管理"><a href="#传统方式解决影院管理" class="headerlink" title="传统方式解决影院管理"></a>传统方式解决影院管理</h2><h3 id="实现方案：客户端直接调用各流程"><a href="#实现方案：客户端直接调用各流程" class="headerlink" title="实现方案：客户端直接调用各流程"></a>实现方案：客户端直接调用各流程</h3><p>客户端直接使用各个子系统</p><p><strong>各个电器类（子系统）</strong>：包括打开、关闭等功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DVD类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DVDPlayer</span>&#123;</span><br><span class="line">    <span class="comment">// 播放</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;播放DVD&quot;</span>); &#125;</span><br><span class="line">    <span class="comment">// 打开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;打开DVD&quot;</span>); &#125;</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;关闭DVD&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 投影仪</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Projector</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开投影仪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><strong>客户端</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、创建对象：创建各电器类对象</span></span><br><span class="line">        <span class="comment">// 2、打开电器：调用各对象的on()方法</span></span><br><span class="line">        <span class="comment">// 3、放映：调用DVDPlayer对象的play方法</span></span><br><span class="line">        <span class="comment">// 4.关闭：关闭所有电器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点和改进思路"><a href="#优缺点和改进思路" class="headerlink" title="优缺点和改进思路"></a>优缺点和改进思路</h3><p><strong>优点：</strong>比较好理解，简单易操作</p><p><strong>缺点：</strong></p><ul><li><strong>调用过程混乱</strong>：客户端创建各个子系统的对象，并直接去调用子系统（对象）相关方法，会造成调用过程混乱，没有清晰的过程</li><li><strong>无法直接维护子系统</strong>：不利于在 ClientTest 中去维护对子系统的操作</li></ul><p><strong>改进思路分析：</strong> 抽取界面类，定义一个高层接口（界面类），给子系统接口提供一致的界面（例如ready，play，pause，end等方法），屏蔽内部子系统的细节。</p><h2 id="外观模式-1"><a href="#外观模式-1" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="外观模式-门面模式"><a href="#外观模式-门面模式" class="headerlink" title="外观模式/门面模式"></a>外观模式/门面模式</h3><p><strong>外观模式（Facade）</strong>：也叫过程模式/门面模式，是一种结构型设计模式。外观模式通常创建一个外观类，将子系统类的多个流程方法组装起来。</p><p>外观模式通过封装复杂的子系统接口，提供一个简化的统一接口，减少了客户端与子系统的直接依赖，降低了耦合性。</p><blockquote><p> <strong>结构型模式</strong>（Structural Patterns）：<br>主要用于描述对象之间的<strong>组合</strong>关系<strong>。</strong>包括“代理模式”、“适配器模式”、“桥接模式”、“装饰者模式”、“外观模式”、“享元模式”和“组合模式”等。这些模式可以帮助我们更好地<strong>设计程序结构</strong>，提高代码的灵活性和可维护性。<br>外观模式将多个子系统通过界面接口统一访问，改变了各个子系统与客户端之间的组合关系，所以是结构型设计模式。</p></blockquote><h3 id="外观类、子系统和客户端"><a href="#外观类、子系统和客户端" class="headerlink" title="外观类、子系统和客户端"></a>外观类、子系统和客户端</h3><p><strong>外观模式的三个角色</strong>：</p><ul><li><strong>外观类</strong>（Facade）：提供统一的界面类，组装子系统的各个流程。例如软件安装外观类有个“一键安装”方法，组装了选择安装目录、选择组件、开启开机自启动等子流程。</li><li><strong>子系统</strong>：各功能的实际执行者。例如系统服务类设置开机自启动。</li><li><strong>客户端</strong>（Client）：调用者。客户端通过调用外观类提供的简化接口，与各子系统交互，从而实现功能。例如点击外观对象的“一键安装”方法，一键安装软件。</li></ul><p><strong>举例</strong>：</p><ul><li><strong>一键安装</strong>：在 PC 上安装软件的时候经常有一键安装选项，省去选择安装目录、安装的组件、选择开机自启动、选择是否生成快捷方式等步骤</li><li><strong>重启手机</strong>：手机的关机选项，就是把关机和启动组合为一个操作</li></ul><h3 id="优缺点和适用场景"><a href="#优缺点和适用场景" class="headerlink" title="优缺点和适用场景"></a>优缺点和适用场景</h3><p><strong>优点：</strong></p><ul><li><p><strong>简化用户操作</strong>：将具体的各个流程组装到外观类中，这样客户端调用时，直接调用外观类的方法即可。</p></li><li><p><strong>高内聚低耦合</strong>：将子系统的实现细节隐藏在外观类之后，客户端只与外观类交互，降低了系统各部分之间的耦合性。</p></li><li><p><strong>分层结构</strong>：外观模式可以作为上层系统与下层子系统交互的中间层，简化每一层之间的依赖。</p></li><li><p><strong>性能高</strong>：将各个子系统流程的分别调用，改为外观类一次性调用，减少网络通信成本，提高 了客户端的响应速度。</p></li><li><p><strong>易于维护</strong>：当需要修改流程时，只需要维护外观类的方法，调换各个流程，不需要关注各个子系统的具体实现。</p></li></ul><p><strong>缺点：</strong></p><ul><li><strong>掩盖子系统复杂性</strong>：将子系统的实现细节隐藏在外观类之后，开发者可能对各个子系统的具体实现细节了解不够深刻。 </li><li><strong>过度设计</strong>：一些场景子系统并不多，而且流程简单，未来也不需要扩展新的流程，用外观模式就会有些过度设计。这也是众多设计模式的缺点，需要充分考虑适用场景</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>子系统各流程复杂</strong>：当子系统很多时，为了防止遗留流程，并且方便管理各个流程的前后顺序，可以使用外观模式</li><li><strong>兼容旧系统功能</strong>：在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个 Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性</li><li><strong>三层架构</strong>：Java项目中，我们常常将Dao注入到Service，Service将多个Dao组合在一起，这其实也用到了外观模式。</li></ul><h2 id="外观模式解决影院管理"><a href="#外观模式解决影院管理" class="headerlink" title="外观模式解决影院管理"></a>外观模式解决影院管理</h2><h3 id="实现方案：将各流程组装到外观类"><a href="#实现方案：将各流程组装到外观类" class="headerlink" title="实现方案：将各流程组装到外观类"></a>实现方案：将各流程组装到外观类</h3><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a><strong>核心代码</strong></h3><h4 id="子系统：投影仪、DVD等类"><a href="#子系统：投影仪、DVD等类" class="headerlink" title="子系统：投影仪、DVD等类"></a>子系统：投影仪、DVD等类</h4><p>子系统类主要包括投影仪、DVD等类，拥有打开、关闭等功能（普通方法） ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 投影仪</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Projector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Projector</span> <span class="variable">projector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Projector</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Projector <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> projector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;打开投影仪...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;关闭投影仪...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">focus</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;投影仪聚焦...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">zoom</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;投影仪放大...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DVD类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DVDPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DVDPlayer</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DVDPlayer</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DVDPlayer <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> player;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;打开DVD播放器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;关闭DVD播放器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;播放DVD播放器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;暂停DVD播放器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDvd</span><span class="params">(String dvd)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;选dvd：&quot;</span> + dvd + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 荧幕类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Screen</span> <span class="variable">screen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Screen</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Screen <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> screen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;升起荧幕...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;拉下荧幕...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 音响类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stereo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Stereo</span> <span class="variable">stereo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stereo</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stereo <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stereo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;打开立体声...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;关闭立体声...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVolume</span><span class="params">(Integer volume)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;立体声音量+&quot;</span> + volume + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 灯光类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheaterLights</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">TheaterLights</span> <span class="variable">lights</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TheaterLights</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TheaterLights <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lights;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;打开灯光...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;关闭灯光...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dim</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;调暗灯光...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bright</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;调亮灯光...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 爆米花机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Popcorn</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Popcorn</span> <span class="variable">popcorn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Popcorn</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Popcorn <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> popcorn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;打开爆米花机器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;关闭爆米花机器...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;取出爆米花...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外观类：家庭影院外观类"><a href="#外观类：家庭影院外观类" class="headerlink" title="外观类：家庭影院外观类"></a>外观类：家庭影院外观类</h4><p>外观类包括一个或多个组装方法，将各个流程（子系统类的方法）组装起来。 </p><p>家庭影院 Facade</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外观类：家庭影院外观类，包括准备、观看、暂停、结束等大流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeTheaterFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">    <span class="keyword">private</span> Screen screen;</span><br><span class="line">    <span class="keyword">private</span> Stereo stereo;</span><br><span class="line">    <span class="keyword">private</span> TheaterLights lights;</span><br><span class="line">    <span class="keyword">private</span> Projector projector;</span><br><span class="line">    <span class="keyword">private</span> DVDPlayer player;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomeTheaterFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.popcorn = Popcorn.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.screen = Screen.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.stereo = Stereo.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.lights = TheaterLights.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.projector = Projector.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.player = DVDPlayer.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备看电影：调用开灯、放屏幕、开投影仪、调暗灯等流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ready</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打开灯光</span></span><br><span class="line">        lights.on();</span><br><span class="line">        <span class="comment">// 开爆米花机</span></span><br><span class="line">        popcorn.on();</span><br><span class="line">        <span class="comment">// 放下屏幕</span></span><br><span class="line">        screen.down();</span><br><span class="line">        <span class="comment">// 开投影仪，聚焦、放大</span></span><br><span class="line">        projector.on();</span><br><span class="line">        projector.focus();</span><br><span class="line">        projector.zoom();</span><br><span class="line">        <span class="comment">// 开音响，设置音量</span></span><br><span class="line">        stereo.on();</span><br><span class="line">        stereo.setVolume(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 开DVD，选dvd</span></span><br><span class="line">        player.on();</span><br><span class="line">        player.setDvd(<span class="string">&quot;坦塔尼克号&quot;</span>);</span><br><span class="line">        <span class="comment">// 取爆米花，关闭爆米花机器</span></span><br><span class="line">        popcorn.pop();</span><br><span class="line">        popcorn.off();</span><br><span class="line">        <span class="comment">// 调暗灯光</span></span><br><span class="line">        lights.dim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看电影</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        player.play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂停电影</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span> &#123;</span><br><span class="line">        player.pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭电影：调用关投影仪、关音响、开灯、收屏幕等流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        player.off();</span><br><span class="line">        projector.off();</span><br><span class="line">        stereo.off();</span><br><span class="line">        lights.bright();</span><br><span class="line">        screen.up();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端：家庭影院的准备、观看、结束"><a href="#客户端：家庭影院的准备、观看、结束" class="headerlink" title="客户端：家庭影院的准备、观看、结束"></a>客户端：家庭影院的准备、观看、结束</h4><p>客户端类创建外观类对象，调用各个组装方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端：调用影院外观类的准备、观看、结束等流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HomeTheaterFacade</span> <span class="variable">homeTheaterFacade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HomeTheaterFacade</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========家庭影院初始化============&quot;</span>);</span><br><span class="line">        homeTheaterFacade.ready();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========家庭影院沉浸式播放============&quot;</span>);</span><br><span class="line">        homeTheaterFacade.play();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========家庭影院暂停============&quot;</span>);</span><br><span class="line">        homeTheaterFacade.pause();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========家庭影院沉浸式播放============&quot;</span>);</span><br><span class="line">        homeTheaterFacade.play();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========家庭影院结束============&quot;</span>);</span><br><span class="line">        homeTheaterFacade.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式在三层架构中的应用"><a href="#外观模式在三层架构中的应用" class="headerlink" title="外观模式在三层架构中的应用"></a>外观模式在三层架构中的应用</h2><h3 id="三层架构和MVC设计模式"><a href="#三层架构和MVC设计模式" class="headerlink" title="三层架构和MVC设计模式"></a>三层架构和MVC设计模式</h3><h4 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h4><p>开发过程中，我们把后端服务器Servlet拆分成三层，分别是web、service和dao，这也是程序员常提到的<strong>“Java味”</strong>：</p><ul><li><strong>web层（表现层）</strong>：直接与用户交互，负责接收用户输入和呈现数据</li><li><strong>service层（业务层）</strong>：处理具体的业务逻辑。也称为服务层或应用层。</li><li><strong>dao层（数据访问层）</strong>：负责与数据库交互，执行数据的增删改查</li></ul><p><strong>优点</strong>：</p><ul><li><strong>低耦合</strong>：各层的职责明确，页面交互、业务逻辑、数据库操作三层分离，降低了系统模块间的耦合。并且各个类功能一目了然，例如OrderController可以直接看出它是控制器。</li><li><strong>易维护</strong>：每层的功能独立，业务逻辑更改后只需修改Service，数据库更改后只需修改dao。</li><li><strong>可扩展</strong>：当增加新功能后，可以在各层扩展相关功能的类。</li></ul><h4 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a><strong>MVC设计模式</strong></h4><p><strong>MVC设计模式</strong>：将后端Servlet设计为控制器controller、视图view、业务模型Model。</p><ul><li><strong>视图（View）</strong>：显示UI页面数据，并与用户交互。前后端分离项目中视图就是前端代码，一体化项目中视图是JSP、Thymeleaf 等框架渲染成的HTML。</li><li><strong>控制器（Controller）</strong>：负责接收浏览器发送过来的请求，然后响应给浏览器</li><li><strong>模型（Model）</strong>：封装后端业务逻辑和应用的核心数据，与数据层交互。</li></ul><p><strong>流程</strong>：</p><ol><li>控制器（例如serlvlet）用来接收浏览器发送过来的请求</li><li>控制器调用模型（例如JavaBean）来获取数据，比如从数据库查询数据；</li><li>控制器获取到数据后再交由视图（例如JSP）进行数据展示。 </li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/system/image-20250728170118400.png" alt="image-20250728170118400"></p><p><strong>优点</strong>：</p><ul><li><strong>低耦合</strong>：将数据、UI 和控制逻辑分离，便于开发、维护和扩展。</li><li><strong>可扩展性</strong>：将逻辑处理和视图渲染分开，各个小组件能直接复用。</li></ul><h3 id="外观模式在三层架构中的应用-1"><a href="#外观模式在三层架构中的应用-1" class="headerlink" title="外观模式在三层架构中的应用"></a>外观模式在三层架构中的应用</h3><p>外观模式像模板模式一样，都是很通用的设计模式，不只是JDK和常用框架的源码，我们开发过程中也会经常用到他们。</p><p>例如写Service时候，将Dao注入到Service，然后调用Dao的各个方法，这其实也用到外观模式的思想。</p><p>下面订单Service，注入了订单dao、商品dao和客户dao，然后对流程进行组装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单业务实现</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;             <span class="comment">// 订单dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductDao productDao;         <span class="comment">// 商品dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomerDao customerDao;     <span class="comment">// 客户dao</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">placeOrder</span><span class="params">(Customer customer, Product product)</span> &#123;</span><br><span class="line">        <span class="comment">// 外观模式思想：调用多个DAO方法，完成下单业务逻辑</span></span><br><span class="line">        <span class="comment">// 1.保存客户信息</span></span><br><span class="line">        customerDao.save(customer);</span><br><span class="line">        <span class="comment">// 2.更新商品库存</span></span><br><span class="line">        productDao.updateStock(product);</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(customer, product);</span><br><span class="line">        <span class="comment">// 3.保存订单</span></span><br><span class="line">        orderDao.save(order);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式在Tomcat源码中的应用"><a href="#外观模式在Tomcat源码中的应用" class="headerlink" title="外观模式在Tomcat源码中的应用"></a>外观模式在Tomcat源码中的应用</h2><p>Tomcat源码使用了外观模式，以<code>ApplicationContextFacade</code>为例</p><h3 id="外观类：ApplicationContextFacade"><a href="#外观类：ApplicationContextFacade" class="headerlink" title="外观类：ApplicationContextFacade"></a>外观类：ApplicationContextFacade</h3><p>ApplicationContextFacade 是 Apache Tomcat 框架中的外观类，位于 org.apache.catalina.core 包下。是 ApplicationContext 的代理接口，主要用于屏蔽 ApplicationContext 的复杂内部实现。</p><p>其中，initClassCache()方法用于初始化classCache变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.catalina.core;</span><br><span class="line"><span class="comment">// 外观类：用于屏蔽 ApplicationContext 的复杂内部实现。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextFacade</span> <span class="keyword">implements</span> <span class="title class_">ServletContext</span> &#123;</span><br><span class="line">    <span class="comment">// ---------------------------------------------------------- Attributes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;[]&gt; classCache; <span class="comment">// 缓存类对象：用于后续通过反射获取类的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Method&gt; objectCache; <span class="comment">// 缓存方法对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----------------------------------------------------------- Constructors</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法：构造一个新对象实例，并初始化类对象缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The associated Context instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApplicationContextFacade</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">        classCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        objectCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        initClassCache();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化类缓存：将ApplicationContext各方法加入类缓存中，value统一初始化成String类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initClassCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建String的类对象</span></span><br><span class="line">        Class&lt;?&gt;[] clazz = <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;;</span><br><span class="line">        <span class="comment">// 2.将该类对象作为value，key是ApplicationContext各方法，统一存到类缓存中</span></span><br><span class="line">        <span class="comment">// 获取上下文</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getContext&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取 MIME 类型</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getMimeType&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取资源路径</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getResourcePaths&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取资源</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getResource&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取资源的输入流</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getResourceAsStream&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取请求分发器</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getRequestDispatcher&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取指定名称的分发器</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getNamedDispatcher&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取 Servlet</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getServlet&quot;</span>, clazz);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 设置初始化参数</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setInitParameter&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, String.class &#125;);</span><br><span class="line">        <span class="comment">// 创建 Servlet 实例</span></span><br><span class="line">        classCache.put(<span class="string">&quot;createServlet&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.class &#125;);</span><br><span class="line">        <span class="comment">// 添加 Servlet</span></span><br><span class="line">        classCache.put(<span class="string">&quot;addServlet&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, String.class &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建过滤器实例</span></span><br><span class="line">        classCache.put(<span class="string">&quot;createFilter&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.class &#125;);</span><br><span class="line">        <span class="comment">// 添加过滤器</span></span><br><span class="line">        classCache.put(<span class="string">&quot;addFilter&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, String.class &#125;);</span><br><span class="line">        <span class="comment">// 创建监听器</span></span><br><span class="line">        classCache.put(<span class="string">&quot;createListener&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.class &#125;);</span><br><span class="line">        <span class="comment">// 添加监听器</span></span><br><span class="line">        classCache.put(<span class="string">&quot;addListener&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取过滤器注册信息</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getFilterRegistration&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取 Servlet 注册信息</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getServletRegistration&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取初始化参数</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getInitParameter&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 设置属性</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setAttribute&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, Object.class &#125;);</span><br><span class="line">        <span class="comment">// 移除属性</span></span><br><span class="line">        classCache.put(<span class="string">&quot;removeAttribute&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取资源的真实路径</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getRealPath&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 获取属性</span></span><br><span class="line">        classCache.put(<span class="string">&quot;getAttribute&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        classCache.put(<span class="string">&quot;log&quot;</span>, clazz);</span><br><span class="line">        <span class="comment">// 设置会话跟踪模式</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setSessionTrackingModes&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Set.class &#125;);</span><br><span class="line">        <span class="comment">// 添加 JSP 文件</span></span><br><span class="line">        classCache.put(<span class="string">&quot;addJspFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, String.class &#125;);</span><br><span class="line">        <span class="comment">// 声明角色</span></span><br><span class="line">        classCache.put(<span class="string">&quot;declareRoles&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String[].class &#125;);</span><br><span class="line">        <span class="comment">// 设置会话超时时间</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setSessionTimeout&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; <span class="type">int</span>.class &#125;);</span><br><span class="line">        <span class="comment">// 设置请求字符编码</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setRequestCharacterEncoding&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;);</span><br><span class="line">        <span class="comment">// 设置响应字符编码</span></span><br><span class="line">        classCache.put(<span class="string">&quot;setResponseCharacterEncoding&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tomcat和Spring的ApplicationContext区别"><a href="#Tomcat和Spring的ApplicationContext区别" class="headerlink" title="Tomcat和Spring的ApplicationContext区别"></a>Tomcat和Spring的ApplicationContext区别</h3><p><strong>相同点：</strong> 两者都是应用程序上下文，用于管理和获取容器的环境信息。</p><p><strong>不同点：</strong></p><ul><li><strong>Tomcat的ApplicationContext</strong>：Web容器相关的应用上下文，用于获取和管理Web容器的环境信息；</li><li><strong>Spring的ApplicationContext</strong>：Spring的IOC容器相关的应用上下文，用于获取和管理IOC容器的环境信息；</li></ul><blockquote><p><strong>IOC容器</strong>：</p><ul><li><strong>IOC控制反转思想：</strong>创建对象的控制权由内部（即new实例化）反转到外部（即IOC容器）。</li><li><strong>Bean：</strong>IOC容器中存放的一个个对象</li><li><strong>DI依赖注入：</strong>绑定IOC容器中bean与bean之间的依赖关系。例如将dao层对象注入到service层对象。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">// web容器：ApplicationContext是ServletContext接口的实现类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line">    <span class="comment">// 获取所有Bean</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">            System.out.println(beanDefinitionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取所有web容器的属性</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">servletTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取所有web容器的属性</span></span><br><span class="line">        Enumeration&lt;String&gt; attributeNames = servletContext.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attributeNames.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> attributeNames.nextElement();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 &lt;em&gt;Gang of Four&lt;/em&gt; (&lt;em&gt;GoF&lt;/em&gt;) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型模式</title>
    <link href="https://southernfish.github.io/2025/07/28/java/java-design-pattern-creational/"/>
    <id>https://southernfish.github.io/2025/07/28/java/java-design-pattern-creational/</id>
    <published>2025-07-28T06:10:36.000Z</published>
    <updated>2025-07-28T10:27:55.454Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><p><strong>创建型模式</strong>（Creational Patterns）：主要<strong>用于对象的创建</strong>，包括多个不同的模式，如工厂方法模式、抽象工厂模式、建造者模式、单例模式和原型模式等。这些模式都有助于降低系统耦合度，并提高代码的可重用性和可扩展性。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130423855?spm=1001.2014.3001.5502">设计模式——设计模式介绍和单例设计模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130433828?spm=1001.2014.3001.5502">设计模式——工厂模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/133910728">设计模式——原型模式</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/134162179">【设计模式】结合StringBuilder源码，探析建造者模式的特性和应用场景</a></p></blockquote><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对<strong>某个类只能存在一个对象实例</strong>，并且<strong>该类只提供一个取得其对象实例的方法</strong>（静态方法）</p><blockquote><p>比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，<strong>一个项目通常只需要一个 SessionFactory</strong> 就够，这是就会使用到单例模式</p></blockquote><p><strong>优点：</strong></p><ul><li><p>节省资源：单例模式实例只有一个，可以<strong>避免重复创建对象</strong>，从而节省了资源，提高了系统性能。</p></li><li><p>管理全局变量：单例模式可以用于管理全局状态和变量，方便在整个系统中<strong>共享数据</strong>。</p></li><li><p>简化系统架构：使用单例模式可以简化系统架构，减少类的数量和接口的复杂度。</p></li></ul><p><strong>缺点：</strong></p><ol><li><strong>可能引发并发问题</strong>：单例模式在多线程中使用时，需要保证线程安全，否则可能会引发并发问题。</li><li><strong>可能增加系统复杂性</strong>：过度使用单例模式可能会增加系统复杂性，导致代码难以维护。</li><li><strong>难以调试</strong>：由于单例模式全局共享状态，可能会导致调试过程中的问题难以定位和测试。</li></ol><p><strong>注意事项和使用场景</strong></p><ul><li>单例模式保证了系统内存中该类只存在一个对象，<strong>节省系统资源</strong>，对一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住<strong>使用相应的获取对象的方法</strong>，而不是使用 new</li><li><strong>单例模式使用的场景</strong>：需要<strong>频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多但又经常用到的对象</strong>（即：重量级对象）、工具类对象、频繁访问数据库或文件的对象（比如数据源、session 工厂等）</li></ul><h2 id="八种单例模式的创建方式"><a href="#八种单例模式的创建方式" class="headerlink" title="八种单例模式的创建方式"></a>八种单例模式的创建方式</h2><ol><li><strong>饿汉式（静态常量）：线程安全，没用到会浪费内存。</strong></li><li><strong>饿汉式（静态代码块）：线程安全，没用到会浪费内存。</strong></li><li>懒汉式（线程不安全）：懒加载，线程不安全。即用到时候再实例化，多线程时可能创建多个实例。不要用这种方式。</li><li>懒汉式（线程安全，同步方法）：线程安全，但效率低（每次获取实例都要加锁），不推荐。</li><li>懒汉式（线程不安全，同步代码块）：线程不安全，不要用这种方式。</li><li><strong>双重检查</strong></li><li><strong>静态内部类</strong></li><li><strong>枚举</strong></li></ol><h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><p>线程安全，可用，但如果没用到会浪费内存。</p><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、类的内部创建 私有静态常对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法 getInstance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li><strong>优点：</strong>写法简单，就是在<strong>类装载的时候就完成实例化</strong>（类变量在JVM类加载的准备、初始化阶段会赋值）。<strong>避免了线程同步问题</strong></li><li><strong>缺点：</strong>在类装载的时候就完成实例化，<strong>没有达到 Lazy Loading 的效果</strong>。若从始至终从未使用过这个实例，则会造成<strong>内存的浪费。</strong></li></ul><p>这种方式基于 classloder 机制避免了多线程的同步问题。不过，instance 在类装载时就实例化，在单例模式中大多数都是调用getlnstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 Lazy loading 的效果。</p><h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><p>线程安全，可用，但是可能造成内存浪费</p><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、类的内部声明对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 3、在静态代码块中创建对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、向外暴露一个静态的公共方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong>：这种方式和上面静态常量的方式其实类似，只不过<strong>将类实例化的过程放在了静态代码块中</strong>，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。<strong>优缺点和上面是一样的。</strong></p><h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><p>懒加载，线程不安全。即用到时候再实例化，多线程时可能创建多个实例。<strong>不要用这种方式</strong>。</p><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、构造器私有化</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 2、类的内部声明对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="comment">// 3、向外暴露一个静态的公共方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>起到了 <strong>Lazy Loading</strong> 的效果，但是只能在单线程下使用</li><li>如果在<strong>多线程</strong>下，一个线程进入了判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，便<strong>会产生多个实例</strong></li></ul><h3 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h3><p>线程安全，但效率低（每次获取实例都要加锁），不推荐。</p><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、类的内部声明对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">    <span class="comment">// 向外暴露一个公共静态synchronized方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>解决了线程不安全问题</li><li><strong>效率太低了</strong>，每个线程在想获得类的实例时候，执行<code>getlnstance()</code>方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接<code>return</code>就行了。方法进行同步效率太低</li></ul><h3 id="懒汉式（线程不安全，同步代码块）"><a href="#懒汉式（线程不安全，同步代码块）" class="headerlink" title="懒汉式（线程不安全，同步代码块）"></a>懒汉式（线程不安全，同步代码块）</h3><p>线程不安全，在实际开发中，<strong>不能使用这种方式</strong></p><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、类的内部声明对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;    <span class="comment">// 可能有多个线程同时通过检查，多次执行下面代码，产生多个实例</span></span><br><span class="line">            <span class="comment">// 类级别的锁对象，锁对象是全局的，对该类的所有实例均有效。回顾锁对象是this时仅限于锁当前实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块</li><li>但这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了判断语句块，还未来得及往下执行，<strong>另一个线程也通过了这个判断语句</strong>，这时便会产生多个实例</li></ul><h3 id="双重检查（推荐，线程安全、懒加载）"><a href="#双重检查（推荐，线程安全、懒加载）" class="headerlink" title="双重检查（推荐，线程安全、懒加载）"></a>双重检查（推荐，线程安全、懒加载）</h3><p>在实际开发中，<strong>推荐使用</strong>这种单例设计模式</p><ol><li>构造器私有化</li><li>类的内部创建对象引用，同时用<strong>volatile关键字</strong>修饰</li><li>向外暴露一个静态的公共方法，<strong>加入同步处理的代码块，并进行双重判断</strong>，解决线程安全问题</li></ol><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2、类的内部声明对象，同时用`volatile`关键字修饰，为了保证可见性。</span></span><br><span class="line">    <span class="comment">// 原子性、可见性（修改立即更新到内存）、有序性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法，加入同步处理的代码块，并进行双重判断，解决线程安全问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;                <span class="comment">// 第一次检查，可能有多个线程同时通过检查</span></span><br><span class="line">            <span class="comment">// 类级别的锁对象，锁对象是全局的，对该类的所有实例均有效。回顾锁对象是this时仅限于锁当前实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;    </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;       <span class="comment">// 第二次检查，只会有1个线程通过检查并创建实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>Double-Check 概念是多线程开发中常使用到的，我们进行了<strong>两次检查</strong>，这样就可以保证线程安全了</li><li>这样实例化代码只用执行一次，后面再次访问时直接 return 实例化对象，也避免的反复进行方法同步</li><li><strong>线程安全；延迟加载；效率较高</strong></li></ul><h3 id="静态内部类（推荐）"><a href="#静态内部类（推荐）" class="headerlink" title="静态内部类（推荐）"></a>静态内部类（推荐）</h3><p>线程安全、延迟加载、效率高，推荐使用。 </p><p><strong>步骤：</strong> </p><ul><li><p>1）构造器私有化</p></li><li><p>2）定义一个<strong>静态内部类</strong>，内部定义当前类的静态属性</p></li><li><p>3）向外暴露一个静态的公共方法</p></li></ul><blockquote><p>知识加油站：</p><ul><li><p>类的加载机制是延迟加载的，也就是说，只有在需要使用到某个类时才会进行加载。</p></li><li><p>类加载过程中会加载其所有静态成员到内存中，包括静态变量、静态成员方法和静态内部类。</p></li><li><p>类加载包括加载、链接（验证、准备（为类变量分配内存并赋零值）、解析）、初始化（类变量赋初值、执行静态语句块）。</p></li></ul></blockquote><p><strong>步骤示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2、定义一个静态内部类，内部定义当前类的静态属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、向外暴露一个静态的公共方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>这种方式采用了类装载的机制，来保证初始化实例时只有一个线程</li><li>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用getlnstance方法，才会装载Singletonlnstance 类，从而完成 Singleton 的实例化。</li><li>类的静态属性只会在第一次加载类的时候初始化，<strong>JVM</strong>帮助我们保证了<strong>线程的安全性</strong>，在类进行初始化时，别的线程是无法进入的</li><li><strong>优点</strong>：避免了线程不安全，利用静态内部类特点实现<strong>延迟加载，效率高</strong></li></ul><h3 id="枚举（推荐）"><a href="#枚举（推荐）" class="headerlink" title="枚举（推荐）"></a>枚举（推荐）</h3><p>推荐，线程安全，延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance == instance2);    <span class="comment">// true</span></span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能<strong>避免多线程同步问题</strong>，而且还能防止反序列化重新创建新的对象</li><li>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式</li></ul><h3 id="JDK-源码里单例模式分析"><a href="#JDK-源码里单例模式分析" class="headerlink" title="JDK 源码里单例模式分析"></a>JDK 源码里单例模式分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span>&#123; <span class="keyword">return</span> currentRuntime; &#125;</span><br><span class="line">    <span class="comment">// Don&#x27;t let anyone else instantiate this class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="工厂模式介绍"><a href="#工厂模式介绍" class="headerlink" title="工厂模式介绍"></a>工厂模式介绍</h2><p>以提高复杂性为代价，提高可维护性和复用性。 </p><p>工厂模式是一种<strong>创建型设计模式（跟创建对象有关）</strong>，它主要解决了对象的创建过程中的灵活性和可维护性问题。工厂模式允许在<strong>不暴露对象创建逻辑</strong>的情况下，统一由<strong>工厂类负责创建对象并返回</strong>，从而降低了代码的耦合性。</p><ol><li><p><strong>简单工厂模式</strong> </p><p>简单工厂模式是<strong>通过工厂类</strong>（抽象或非抽象）<strong>的静态方法来创建对象实例</strong>，并将实例作为方法的返回值。在使用时，只需要调用该静态方法来创建对象，而无需创建工厂类的实例。<strong>静态工厂方法也是简单工厂模式的一种</strong>。</p></li><li><p><strong>工厂方法模式</strong></p><p>工厂方法模式是在抽象工厂类里<strong>定义创建抽象产品对象的抽象方法，由具体工厂类决定要实例化的产品类</strong>。抽象工厂类的构造器里调用“创建抽象产品对象”的抽象方法，具体工厂类重写抽象方法，按情景实例化具体产品类。使用时直接创建具体工厂对象，将执行抽象工程类构造器调用重写后的创建方法，创建具体产品对象。</p><p>一个抽象工厂类能派生多个具体工厂类。每个具体工厂类只能建立一个具体产品类的实例。一个抽象产品类能派生多个具体产品类。 </p></li><li><p><strong>抽象工厂模式</strong></p><p>抽象工厂模式是抽象工厂接口里定义创建抽象产品对象的抽象方法，各具体工厂实现类根据情景创建具体产品对象。</p><p>一个抽象工厂类能够派生出多个具体工厂类。每一个具体工厂类能够建立多个具体产品类的实例。多个抽象产品类，每个抽象产品类能够派生出多个具体产品类。</p></li></ol><p><strong>优点：</strong></p><ol><li>可以避免直接使用new关键字创建对象带来的耦合性，提高了代码的<strong>可维护性</strong>；</li><li>可以将对象的创建逻辑封装到一个工厂类中，提高了代码的<strong>复用性</strong>；</li><li>可以对<strong>对象的创建逻辑进行统一管理</strong>，方便代码的维护和升级。</li></ol><p><strong>缺点：</strong></p><ol><li>增加了代码的复杂度，需要创建工厂类，会<strong>增加代码规模</strong>；</li><li>如果产品类发生变化，需要<strong>修改工厂类，可能会影响到其他代码的功能</strong>。</li></ol><p>综上所述，工厂模式是一种常用的创建型设计模式，可以提高代码的可维护性、复用性和灵活性。但是，在使用时需要权衡利弊，避免过度使用，增加代码的复杂度。</p><p><strong>工厂模式的意义：</strong></p><p>将<strong>实例化对象的代码提取出来</strong>，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</p><p><strong>设计模式的依赖抽象原则：</strong></p><ul><li>创建对象实例时，不要直接 new 类，而是把这个 new 类的动作放在一个工厂的方法中并返回。有的书上说，变量不要直接持有具体类的引用</li><li>不要让类继承具体类，而是继承抽象类或者是实现 interface（接口）</li><li>不要覆盖基类中已经实现的方法</li></ul><h2 id="披萨项目需求"><a href="#披萨项目需求" class="headerlink" title="披萨项目需求"></a>披萨项目需求</h2><p>披萨项目：要便于披萨种类的扩展，要便于维护</p><ul><li>披萨的种类很多（比如 GreekPizz、CheesePizz 等）</li><li>披萨的制作有 prepare、bake、cut、box</li><li>完成披萨店订购功能</li></ul><h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPizza</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备原材料，不同具体披萨不一样，所以是抽象方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; baking...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; cutting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; boxing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 希腊风味披萨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreekPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        setName(<span class="string">&quot;GreekPizza&quot;</span>);</span><br><span class="line">        System.out.println(name + <span class="string">&quot; preparing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 奶酪披萨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheesePizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        setName(<span class="string">&quot;CheesePizza&quot;</span>);</span><br><span class="line">        System.out.println(name + <span class="string">&quot; preparing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 订购披萨，不断输入披萨类型，输出披萨的生产包装过程。</span></span><br><span class="line"><span class="comment">// 耦合度高，违反了设计模式的 OCP 原则，即对扩展开放，对修改关闭。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String orderType;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 每次新增披萨类型，都要改这个订购类，而订购类可能会有很多，都要改就太麻烦了</span></span><br><span class="line">            orderType = getType();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;cheese&quot;</span>.equals(orderType)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;greek&quot;</span>.equals(orderType)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入类型错误，程序退出&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入披萨类型：&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> reader.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 披萨商店</span></span><br><span class="line"><span class="comment">// 相当于一个客户端，发出订购</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">stubOrderPizza</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传统方式优缺点：</strong></p><ul><li><p>优点是比较好理解，简单易操作</p></li><li><p>缺点是<strong>违反了设计模式的 OCP 原则，即对扩展开放，对修改关闭。</strong>即当给类增加新功能时，尽量不修改代码，或尽可能少修改。</p></li><li><p>比如我们这时要新增加一个Pizza的种类（Cheese技萨），需要做如下修改订购类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 胡椒披萨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PepperPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        setName(<span class="string">&quot;PepperPizza&quot;</span>);</span><br><span class="line">        System.out.println(name + <span class="string">&quot; preparing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;pepper&quot;</span>.equals(orderType)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>改进的思路分析：</strong></p><p>分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着也需要修改。而创建Pizza的代码，往往有多处<br>思路：<strong>把创建 Pizza 对象封装到一个类中</strong>，这样我们有新的 Pizza 种类时，只需要修改该类就可，其它有创建到 Pizza 对象的代码就不需要修改了 ==&gt; <strong>简单工厂模式</strong></p><h2 id="非静态简单工厂模式"><a href="#非静态简单工厂模式" class="headerlink" title="非静态简单工厂模式"></a>非静态简单工厂模式</h2><ul><li>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是<strong>由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式</li><li>简单工厂模式：<strong>定义了一个创建对象的类，由这个类来封装实例化对象的行为</strong>（代码）</li><li>在软件开发中，如果要用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式</li></ul><p><strong>简单工厂模式优化披萨项目</strong></p><p>创建一个披萨工厂类，用于根据披萨类别创建披萨对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个披萨工厂类，用于根据披萨类别创建披萨对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;greek&quot;</span>:  pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pepper&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改订购披萨类，披萨对象从披萨工厂类获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaFactory pizzaFactory;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(PizzaFactory pizzaFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pizzaFactory = pizzaFactory;</span><br><span class="line">        orderPizza();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            pizza = pizzaFactory.createPizza(getType());</span><br><span class="line">            <span class="keyword">if</span> (pizza == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Failed to Order Pizza&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);        <span class="comment">// 无限循环，不断输入披萨类型，进行加工、包装等操作；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态简单工厂模式"><a href="#静态简单工厂模式" class="headerlink" title="静态简单工厂模式"></a>静态简单工厂模式</h2><p>静态工厂模式也是简单工厂模式的一种，只是<strong>将工厂方法改为静态方法</strong></p><p>静态工厂模式<strong>通过工厂类的静态方法来创建对象实例，并将实例作为方法的返回值</strong>。在使用时，只需要调用该静态方法来创建对象，而无需创建工厂类的实例。</p><p>静态工厂模式的优点在于可以<strong>简化代码实现</strong>，无需创建工厂对象的实例，提高代码的简洁性；<strong>对比普通工厂模式</strong>的优点在于<strong>更方便扩展和修改</strong>，如果需要新增一个产品线，只需要添加具体的产品类和对应的工厂类即可，无需修改已有的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单静态工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title function_">createPizza2</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订购披萨类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 直接通过静态方法创建工厂对象，不用再像之前通过“构造器参数赋值成员变量”方式创建对象。</span></span><br><span class="line">            pizza = PizzaFactory.createPizza(getType());    </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式：<strong>定义创建对象的抽象方法</strong>，由<strong>子类决定要实例化的类</strong>。工厂方法模式将对象的实例化推迟到子类。</p><p><strong>实现方式：</strong>抽象工厂类的构造器里调用“创建抽象产品对象”的抽象方法，具体工厂类重写抽象方法，按情景实例化具体产品类。</p><p>一个抽象产品能够派生出多个具体产品类。 一个抽象工厂类能够派生出多个具体工厂类。每一个具体工厂类只能建立一个具体产品类的实例。 </p><p>工厂方法模式包含以下几个角色：</p><ol><li><p>抽象产品类（Product）：定义了产品的抽象接口，具体产品将按照抽象产品类所定义的接口来实现。</p></li><li><p>具体产品类（Concrete Product）：是抽象产品类的一个具体实现，定义了具体产品的实现方法。</p></li><li><p>抽象工厂类（Factory）：是工厂方法模式的核心，定义了工厂类需要实现的接口，用于创建产品对象。</p></li><li><p>具体工厂类（Concrete Factory）：是抽象工厂类的一个具体实现，实现了工厂方法创建具体对象实例的逻辑。</p></li></ol><p><strong>披萨项目新的需求</strong>：客户可以点不同口味的披萨，如<strong>北京奶酪 Pizza</strong>、北京胡椒 Pizza 或者是伦敦奶酪 Pizza、伦敦胡椒 Pizza</p><p><strong>思路1</strong>：使用简单工厂模式，创建不同的简单工厂类，比如 BJPizzaFactory、LDPizzaFactory 等等。从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好</p><p><strong>思路2</strong>：工厂方法模式设计方案：将披萨项目的<strong>实例化功能抽象成抽象方法</strong>，在不同的口味点餐子类中具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 披萨商店</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">loc</span> <span class="operator">=</span> <span class="string">&quot;bj&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (loc.equals(<span class="string">&quot;bj&quot;</span>)) &#123;                <span class="comment">// 创建北京口味的各种Rizza</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BJOrderPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LDOrderPizza</span>();             <span class="comment">// 创建伦敦口味的各种Pizza</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂类，订购披萨类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOrderPizzaFactory</span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法不断根据用户输入披萨类型，调用创建披萨对象的抽象方法，实现加工披萨。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            pizza = createPizza(getType());</span><br><span class="line">            <span class="keyword">if</span> (pizza == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Failed to Order Pizza&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂类，订购伦敦披萨类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">AbstractOrderPizzaFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">LDCheesePizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pepper&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">LDPepperPizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂类，订购北京披萨类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">AbstractOrderPizzaFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">BJCheesePizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pepper&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂接口里有创建抽象产品的方法，各具体工厂实现类根据情景创建具体产品对象。</p><ul><li>抽象工厂模式：定义了一个接口用于创建相关或有依赖关系的对象簇，而无需指明具体的类</li><li>抽象工厂模式可以<strong>将简单工厂模式和工厂方法模式进行整合</strong></li><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）</li><li>将工厂抽象成两层，抽象工厂接口和具体工厂类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展</li></ul><p> 抽象工厂接口里有创建抽象产品的方法，各具体工厂实现类根据情景创建具体产品对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsPizzaFactory</span> &#123;</span><br><span class="line">    Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJPizzaFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsPizzaFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDPizzaFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsPizzaFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订购披萨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(AbsFactory factory)</span> &#123;</span><br><span class="line">        setFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderPizza</span><span class="params">(AbsFactory factory)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="comment">// 用户输入</span></span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span></span><br><span class="line">            pizza = factory.createPizza(orderType);</span><br><span class="line">            <span class="keyword">if</span> (pizza != <span class="literal">null</span>) &#123;     <span class="comment">// 订购ok</span></span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Failed to Order Pizza&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);                <span class="comment">// 无限循环，不断输入披萨类型，进行加工、包装等操作；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建订购单，由具体工厂类创建具体产品对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">OrderPizza</span>(<span class="keyword">new</span> <span class="title class_">BJFactory</span>());</span><br></pre></td></tr></table></figure><h2 id="JDK-源码分析"><a href="#JDK-源码分析" class="headerlink" title="JDK 源码分析"></a>JDK 源码分析</h2><p>JDK 中的 Calendar 类中，就使用了静态简单工厂模式。</p><p><strong>静态简单工厂模式：由一个工厂对象</strong>（可以是抽象类，可以是非抽象类）<strong>决定创建出哪种产品类的实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Calendar类是工厂类，getInstance()是静态方法，用于创建对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 注意月份下标从O开始，所以取月份要+1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年:&quot;</span> + cal.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(<span class="string">&quot;月:&quot;</span> + (cal.get(Calendar.MONTH) + <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;日:&quot;</span> + cal.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(<span class="string">&quot;时:&quot;</span> + cal.get(Calendar. HOUR_OF_DAY)) ;</span><br><span class="line">        System.out.println(<span class="string">&quot;分:&quot;</span> + cal.get(Calendar. MINUTE)) ;</span><br><span class="line">        System.out.println(<span class="string">&quot;秒:&quot;</span> + cal. get(Calendar.SECOND));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Calendar工厂类，决定创建出哪一种产品类的实例</span></span><br><span class="line"><span class="comment">// Calendar类是工厂类，getInstance()是静态方法，用于创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Calendar</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable, Comparable&lt;Calendar&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据时区地区返回Calendar 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Locale</span> <span class="variable">aLocale</span> <span class="operator">=</span> Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line">        <span class="keyword">return</span> createCalendar(defaultTimeZone(aLocale), aLocale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据时区地区创建Calendar 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title function_">createCalendar</span><span class="params">(TimeZone zone, Locale aLocale)</span>&#123;</span><br><span class="line">        <span class="type">CalendarProvider</span> <span class="variable">provider</span> <span class="operator">=</span> LocaleProviderAdapter</span><br><span class="line">                                .getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                                 .getCalendarProvider();</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> provider.getInstance(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                <span class="comment">// fall back to the default instantiation</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">caltype</span> <span class="operator">=</span> aLocale.getUnicodeLocaleType(<span class="string">&quot;ca&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (caltype != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;buddhist&quot;</span>: cal = <span class="keyword">new</span> <span class="title class_">BuddhistCalendar</span>(zone, aLocale); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;japanese&quot;</span>: cal = <span class="keyword">new</span> <span class="title class_">JapaneseImperialCalendar</span>(zone, aLocale); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;gregory&quot;</span>: cal = <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(zone, aLocale); <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cal == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据不同地区，返回不同的具体的产品类</span></span><br><span class="line">            <span class="comment">// If no known calendar type is explicitly specified,</span></span><br><span class="line">            <span class="comment">// perform the traditional way to create a Calendar:</span></span><br><span class="line">            <span class="comment">// create a BuddhistCalendar for th_TH locale,</span></span><br><span class="line">            <span class="comment">// a JapaneseImperialCalendar for ja_JP_JP locale, or</span></span><br><span class="line">            <span class="comment">// a GregorianCalendar for any other locales.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> The language, country and variant strings are interned.</span></span><br><span class="line">            <span class="keyword">if</span> (aLocale.getLanguage() == <span class="string">&quot;th&quot;</span> &amp;&amp; aLocale.getCountry() == <span class="string">&quot;TH&quot;</span>) &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> <span class="title class_">BuddhistCalendar</span>(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aLocale.getVariant() == <span class="string">&quot;JP&quot;</span> &amp;&amp; aLocale.getLanguage() == <span class="string">&quot;ja&quot;</span></span><br><span class="line">                       &amp;&amp; aLocale.getCountry() == <span class="string">&quot;JP&quot;</span>) &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> <span class="title class_">JapaneseImperialCalendar</span>(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(zone, aLocale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="经典的克隆羊问题（复制10只属性相同的羊）"><a href="#经典的克隆羊问题（复制10只属性相同的羊）" class="headerlink" title="经典的克隆羊问题（复制10只属性相同的羊）"></a>经典的克隆羊问题（复制10只属性相同的羊）</h2><p><strong>问题描述：</strong>现在有一只羊，姓名为 Tom，年龄为 1，颜色为白色，请编写程序创建和 Tom 羊属性完全相同的 10 只羊。</p><h2 id="传统方案：循环new对象"><a href="#传统方案：循环new对象" class="headerlink" title="传统方案：循环new对象"></a>传统方案：循环new对象</h2><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 羊</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 克隆羊</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">            System.out.println(sheep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点和改进思路"><a href="#优缺点和改进思路" class="headerlink" title="优缺点和改进思路"></a>优缺点和改进思路</h3><p><strong>优点</strong>：好理解，简单易操作</p><p><strong>缺点：</strong></p><ul><li><strong>每次获取再复制效率低：</strong>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li><li><strong>不灵活：</strong>总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活</li></ul><p><strong>改进的思路分析：Object 类的 clone() 方法</strong></p><p>Object 类是所有类的根类，Object 类提供了一个 clone 方法，该方法可以将一个 Java 对象复制一份，但是对应的类必须<strong>实现Cloneable接口</strong>，该接口表示该类能够复制且具有复制的能力 ==&gt; <strong>原型模式</strong></p><h2 id="原型模式（Prototype模式）"><a href="#原型模式（Prototype模式）" class="headerlink" title="原型模式（Prototype模式）"></a>原型模式（Prototype模式）</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>原型模式（Prototype 模式）：</strong>用<strong>原型实例</strong>指定创建对象种类，并通过<strong>拷贝</strong>原型创建新的对象</p><p>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。</p><p><strong>原理：</strong>将一个原型对象传给要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()</p><blockquote><p><strong>创建型设计模式：</strong>关注如何有效地创建对象，以满足不同的需求和情境。</p><p><strong>包括：</strong>单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</p></blockquote><h3 id="原理及代码演示"><a href="#原理及代码演示" class="headerlink" title="原理及代码演示"></a>原理及代码演示</h3><ul><li><strong>Prototype：</strong>原型类。包含一个用于复制对象的克隆方法。可以使用Cloneable接口作为原型接口。</li><li><strong>ConcretePrototype：</strong>具体原型类。实现原型接口、重写克隆方法clone()的具体类。</li><li><strong>Client：</strong>让一个原型对象克隆自己，创建一个属性相同的对象</li></ul><p><strong>原型接口：</strong> 可以是Cloneable接口也可以是自定义带clone()方法的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：定义原型接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Prototype</span> <span class="keyword">extends</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步骤2：实现具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Prototype) <span class="built_in">super</span>.clone();     <span class="comment">// 使用浅拷贝</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步骤3：客户端代码，通过clone()方法创建原型对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();                     <span class="comment">// 创建具体类对象</span></span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">clonedObject</span> <span class="operator">=</span> (ConcretePrototype) prototype.clone(); <span class="comment">// 通过clone方法创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型模式解决克隆羊问题"><a href="#原型模式解决克隆羊问题" class="headerlink" title="原型模式解决克隆羊问题"></a>原型模式解决克隆羊问题</h3><blockquote><p><strong>问题回顾：</strong></p><p> 现在有一只羊，姓名为 Tom，年龄为 1，颜色为白色，请编写程序创建和 Tom 羊属性完全相同的 10 只羊。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型接口：Cloneable接口。</span></span><br><span class="line"><span class="comment">// 具体原型类：实现Cloneable接口</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, Integer age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheep = (Sheep) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端： 调用具体原型类的clone()方法创建10个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Sheep</span> <span class="variable">sheep1</span> <span class="operator">=</span> (Sheep) sheep.clone();</span><br><span class="line">            System.out.println(sheep1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="优缺点和使用场景"><a href="#优缺点和使用场景" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><p><strong>构造方法复杂时开销小：</strong>如果构造函数的逻辑很复杂，此时通过new创建该对象会比较耗时，那么就可以尝试使用克隆来生成对象。</p></li><li><p><strong>运行时动态创建对象：</strong>不用重新初始化对象，而是动态地获得对象运行时的状态</p></li><li><p><strong>开闭原则（OCP原则）</strong>：如果原始对象发生变化（增加或者减少属性），其它克隆对象的也会发生相应的变化，无需更改客户端代</p><p>码。相反，如果使用new方式，就需要在客户端修改构造参数。这使得系统更加灵活和可维护。</p></li><li><p><strong>对象封装性</strong>：原型模式可以帮助保护对象的封装性，因为客户端代码无需了解对象的内部结构，只需知道如何克隆对象。</p></li><li><p><strong>多态性</strong>：原型模式支持多态性，因为克隆操作可以返回具体子类的对象，而客户端代码不需要关心对象的具体类。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><p><strong>构造方法简单时开销大：</strong>如果构造函数的逻辑很简单，原型模式的效率不如new，因为JVM对new做了相应的性能优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//    验证构造方法简单时，原型模式开销大</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">    <span class="comment">// 克隆循环十万次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        sheep.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">midTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 20ms</span></span><br><span class="line">    System.out.println(<span class="string">&quot;克隆生成对象耗费的时间:&quot;</span> + (midTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    <span class="comment">// new10万次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Sheep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5ms</span></span><br><span class="line">    System.out.println(<span class="string">&quot;new生成对象耗费的时间:&quot;</span> + (System.currentTimeMillis() - midTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>要注意深拷贝和浅拷贝问题：</strong>实现Cloneable接口时，如果具体原型类直接返回super.clone()，则是浅拷贝。克隆的对象里，引用类型变量只拷贝引用，依然指向旧的地址。</p></li><li><p><strong>代码复杂性：</strong>在实现深拷贝的时候可能需要比较复杂的代码。设计模式一般都是以代码复杂性为代价，提高可扩展性、可读性。</p></li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ol><li><strong>构造方法复杂：</strong>要创建的对象构造方法逻辑很复杂，即创建新的对象比较复杂时，使用原型模式会比直接new效率更高；</li><li><strong>经常需要克隆：</strong>经常要创建一个和原对象属性相同的对象时，可以考虑原型模式。</li></ol><h3 id="Spring源码中的原型模式"><a href="#Spring源码中的原型模式" class="headerlink" title="Spring源码中的原型模式"></a>Spring源码中的原型模式</h3><p>Spring 框架Bean的生命周期中，ApplicationContext类的getBean()方法中，有用到原型模式。</p><p>获取Bean时会判断配置的Bean是单例还是原型，如果是原型，则用原型模式创建Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.issingleton())&#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype())&#123;</span><br><span class="line">    <span class="comment">// It&#x27;s a prototupe -&gt; create a new instance.</span></span><br><span class="line">    0<span class="type">bject</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterPrototypeCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    beanInstance = getobjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>验证：</strong>bean指定原型模式后，getBean()获取到的多个Bean是不同对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;id01&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">// 注解方式是@Scope(&quot;prototype&quot;)。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> health;</span><br><span class="line">     <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Monster</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Monster</span><span class="params">(String name, <span class="type">int</span> health)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.health = health;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加其他属性和方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtoType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过ID获取Monster</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;id01&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bean: &quot;</span> + bean); <span class="comment">// 输出“牛魔王&quot;....</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean2</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;id01&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bean2: &quot;</span> + bean2); <span class="comment">// 输出“牛魔王&quot;....</span></span><br><span class="line">        System.out.println(bean == bean2); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以用xml形式注册Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里使用scope=&quot;prototype&quot;即 原型模式来创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;id01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atquigu.spring.bean.Monster&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><h4 id="浅拷贝：引用类型变量拷贝引用"><a href="#浅拷贝：引用类型变量拷贝引用" class="headerlink" title="浅拷贝：引用类型变量拷贝引用"></a>浅拷贝：引用类型变量拷贝引用</h4><ul><li><strong>浅拷贝：</strong>拷贝后对象是新地址，基本类型变量拷贝值，引用类型变量拷贝引用。只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存。</li></ul><p><strong>实现方案：</strong>具体原型类直接返回super.clone()</p><p>实现Cloneable 接口，重写 clone()方法， 直接返回super.clone()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;   <span class="comment">// 虽然clone()是Object类的方法，但Java规定必须得实现一下这个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;                            <span class="comment">// 基本类型变量拷贝值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1.clone();            <span class="comment">// p2将是p1浅拷贝的对象</span></span><br><span class="line">        p2.age = <span class="number">20</span>;</span><br><span class="line">        System.out.println(p1 == p2);     <span class="comment">// false。拷贝后对象是新地址</span></span><br><span class="line">        System.out.println(p1.age);     <span class="comment">// 18。基本类型变量拷贝值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝：引用类型变量拷贝值"><a href="#深拷贝：引用类型变量拷贝值" class="headerlink" title="深拷贝：引用类型变量拷贝值"></a><strong>深拷贝：</strong>引用类型变量拷贝值</h4><p><strong>深拷贝：</strong>拷贝后对象是新地址，基本类型变量拷贝值，引用类型变量拷贝克隆后的值。创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象。反序列化创建对象是深拷贝。 </p><p><strong>实现方案：</strong>具体原型类专门克隆引用类型变量</p><p>实现Cloneable 接口，重写 clone()方法， 给super.clone()的引用类型成员变量也clone()一下，然后再返回克隆的对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;                                <span class="comment">// 基本类型变量拷贝值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            person.arr = <span class="built_in">this</span>.arr.clone();         <span class="comment">// 用引用类型的 clone 方法，引用类型变量拷贝克隆后的值</span></span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="经典的盖房子问题"><a href="#经典的盖房子问题" class="headerlink" title="经典的盖房子问题"></a>经典的盖房子问题</h2><p><strong>问题描述：</strong></p><ul><li><strong>建房子过程：</strong>打桩、砌墙、封顶。虽然建造过程一样，但实际造的房子有差别，因为房子有各种各样的，比如普通房，高楼，别墅。</li><li><strong>需求：</strong>写代码能建造各类房子</li></ul><h2 id="传统方案盖房子"><a href="#传统方案盖房子" class="headerlink" title="传统方案盖房子"></a>传统方案盖房子</h2><h3 id="实现方案：产品和创建产品过程耦合"><a href="#实现方案：产品和创建产品过程耦合" class="headerlink" title="实现方案：产品和创建产品过程耦合"></a>实现方案：产品和创建产品过程耦合</h3><p>创建以下几个类：</p><ul><li>AbsHouse（抽象盖房类）：包含打桩、砌墙、封顶三个方法；</li><li>NormalRoom（普通房间类）、Villa（别墅类）：继承抽象盖房类，根据情况重写三个方法；</li></ul><p>抽象盖房类：包含打桩、砌墙、封顶三个方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象房间类:包含打桩、砌墙、封顶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsHouse</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span>; <span class="comment">// 打桩</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span>; <span class="comment">// 砌墙</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span>; <span class="comment">// 封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123; <span class="comment">// 盖房子</span></span><br><span class="line">        piling();</span><br><span class="line">        walling();</span><br><span class="line">        capping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NormalRoom（普通房间类）、Villa（别墅类）：继承抽象盖房类，根据情况重写三个方法；</span></span><br><span class="line"><span class="comment">// 普通房</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalRoom</span> <span class="keyword">extends</span> <span class="title class_">AbsHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房打桩...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房砌墙...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房封顶...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高楼</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighRise</span> <span class="keyword">extends</span> <span class="title class_">AbsHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 别墅</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Villa</span> <span class="keyword">extends</span> <span class="title class_">AbsHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点和改进思路-1"><a href="#优缺点和改进思路-1" class="headerlink" title="优缺点和改进思路"></a>优缺点和改进思路</h3><p><strong>优点：</strong>简单，好理解易操作</p><p><strong>缺点</strong>：<strong>产品和创建产品过程耦合：</strong>没有设计<strong>缓存层对象</strong>，程序的扩展和维护不好。也就是说，这种设计方案把产品（即：房子）和创建产品的过程（即：建房子流程）封装在一起，耦合性太高。</p><p><strong>改进思路分析：</strong>使用建造者模式，将产品和产品建造过程<strong>解耦</strong>。</p><h2 id="建造者模式-生成器模式"><a href="#建造者模式-生成器模式" class="headerlink" title="建造者模式/生成器模式"></a>建造者模式/生成器模式</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>建造者模式（Builder Pattern）</strong>：使用多个步骤来创建一个复杂对象，而不是在一个构造函数或工厂方法中直接返回该对象。它将产品和产品建造过程进行了解耦。</p><p>建造者模式又叫生成器模式，是一种创建型设计模式。</p><p><strong>特点：</strong></p><ul><li>分步骤创建对象：对象的构建是分多个步骤进行的，而不是直接使用构造方法new对象，适用于需要分阶段构造的复杂对象。</li><li>同一个建造过程：同样的构建过程可以创建不同的对象表示（不同的配置组合）。</li></ul><h3 id="四个角色"><a href="#四个角色" class="headerlink" title="四个角色"></a>四个角色</h3><ul><li><p><strong>Product（产品）</strong>：一个包含多个部件的类。</p><p>每个部件是一个成员变量。例如房间包括地基、墙和屋顶等组件，又例如电脑包括CPU、内存条、主板等组件。</p></li><li><p><strong>Builder（抽象建造者）</strong>：一个包含产品变量及其所有部件建造方法的抽象类或接口</p><p>包含每个部件的建造方法，和一个返回产品的build()方法。例如房间的打桩、砌墙、封顶过程。</p></li><li><p><strong>ConcreteBuilder（具体建造者）</strong>：实现抽象建造者所有抽象建造方法</p></li><li><p><strong>Director（指挥者）</strong>：一个以抽象建造者为变量的、包含建造方法的类</p><ul><li>包含一个抽象建造者变量，和一个建造并返回产品的build()方法。</li><li>实际建造产品时，先创建一个指挥者对象，然后设置它的建造者变量，最后调用它的build()方法返回产品。</li></ul></li></ul><h3 id="优缺点和使用场景-1"><a href="#优缺点和使用场景-1" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h3><p><strong>优点：</strong></p><ul><li><strong>耦合性降低</strong>：<ul><li><strong>产品与建造解耦</strong>：客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li><strong>具体建造者之间解耦</strong>：每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象</li></ul></li><li><strong>代码可读性高</strong>：可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</li><li><strong>开闭原则</strong>：增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”，即代码对修改不开放，而对扩展开放。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>代码复杂性</strong>：没了解过建造者模式的人阅读代码更困难，这也是设计模式的通用缺点。</li><li><strong>过度设计风险</strong>：建造者模式只适合复杂产品对象，太简单的产品对象则没必要使用，或者建造方式只有一种的产品，都没必要使用。这也是设计模式的通用缺点。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>复杂产品对象</strong>：部件比较多的产品，例如房屋有墙、屋顶、地基、横梁等等部件。</li><li><strong>建造方式多样</strong>：例如房屋对于同一些材料，可以建成普通房屋、高楼等等。</li><li><strong>建造产品共同点</strong>：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制</li></ul><p><strong>不适用场景</strong>：</p><ul><li>简单产品对象；</li><li>建造方式单一；</li></ul><h3 id="建造者模式和抽象工厂模式的区别"><a href="#建造者模式和抽象工厂模式的区别" class="headerlink" title="建造者模式和抽象工厂模式的区别"></a>建造者模式和抽象工厂模式的区别</h3><p><strong>区别：</strong> </p><ul><li><strong>抽象工厂模式</strong>：适用于<strong>不同产品</strong>的情况。用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类）。</li><li><strong>建造者模式</strong>：适用于<strong>一个产品有多个部件</strong>的情况。用来创建一种类型的复杂对象，通过设置不同可选参数，“定制化”创建不同对象。</li></ul><p><strong>示例</strong>：顾客走进一家餐馆点餐</p><ul><li><strong>工厂模式</strong>：根据用户不同的选择，来制作<strong>不同的食物</strong>，比如披萨、汉堡、沙拉。</li><li><strong>建造者模式</strong>：对于披萨来说，用户又有各种配料可以定制，我们通过建造者模式根据用户选择的<strong>不同配料</strong>来制作披萨。</li></ul><h2 id="建造者模式盖房子"><a href="#建造者模式盖房子" class="headerlink" title="建造者模式盖房子"></a>建造者模式盖房子</h2><h3 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h3><p>产品类包含多个部件的对象。<br>每个部件是一个成员变量。例如房间包括地基、墙和屋顶等组件，又例如电脑包括CPU、内存条、主板等组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品：房间类，包含多个部件</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String pile; <span class="comment">// 地基</span></span><br><span class="line">    <span class="keyword">private</span> String wall; <span class="comment">// 墙</span></span><br><span class="line">    <span class="keyword">private</span> String roof; <span class="comment">// 屋顶</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter和setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h3><p>抽象建造者是个抽象类，包含每个部件的建造方法，和一个返回产品的build()方法<br>例如房间的打桩、砌墙、封顶过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象建造者：房间建造抽象类,包含每个部件的抽象建造方法，和一个build()方法返回产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>(); <span class="comment">// 产品对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span>; <span class="comment">// 打地基</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span>; <span class="comment">// 砌墙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span>; <span class="comment">// 封顶</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  build()方法返回产品</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体建造者"><a href="#具体建造者" class="headerlink" title="具体建造者"></a>具体建造者</h4><p>具体建造者是抽象建造者的实现类，实现各个部件具体构建逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体建造者：普通房屋建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalRoomBuilder</span> <span class="keyword">extends</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;普通房打桩...&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;普通房砌墙...&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;普通房封顶...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighRiseBuilder</span> <span class="keyword">extends</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">piling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walling</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">capping</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指挥者"><a href="#指挥者" class="headerlink" title="指挥者"></a>指挥者</h4><p>指挥类包含一个抽象建造者变量，和一个建造并返回产品的build()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指挥者：负责建造并返回产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseDirector</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象建造者变量</span></span><br><span class="line">    <span class="keyword">private</span> HouseBuilder houseBuilder;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseDirector</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建房子方法</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">buildHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用建造者变量的各部门建造方法，然后建造返回</span></span><br><span class="line">        houseBuilder.piling();</span><br><span class="line">        houseBuilder.walling();</span><br><span class="line">        houseBuilder.capping();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><p><strong>步骤：</strong></p><ol><li><strong>创建指挥者</strong>：创建一个指挥者对象</li><li><strong>设置建造者</strong>：设置它的建造者变量为具体建造者对象</li><li><strong>返回产品</strong>：调用它的build()方法返回产品。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuilderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建指挥者对象</span></span><br><span class="line">        <span class="type">HouseDirector</span> <span class="variable">houseDirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseDirector</span>();</span><br><span class="line">        House house;</span><br><span class="line">        <span class="comment">// 2.用指挥者对象的setter方法设置建造者变量</span></span><br><span class="line">        houseDirector.setHouseBuilder(<span class="keyword">new</span> <span class="title class_">NormalRoomBuilder</span>());</span><br><span class="line">        <span class="comment">// 3.指挥者对象的build()方法获取产品</span></span><br><span class="line">        house = houseDirector.buildHouse();</span><br><span class="line">        <span class="comment">// 4.建造高楼</span></span><br><span class="line">        houseDirector.setHouseBuilder(<span class="keyword">new</span> <span class="title class_">HighRiseBuilder</span>());</span><br><span class="line">        house = houseDirector.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuilder-中的建造者模式"><a href="#StringBuilder-中的建造者模式" class="headerlink" title="StringBuilder 中的建造者模式"></a>StringBuilder 中的建造者模式</h2><h3 id="JDK源码中的建造者模式"><a href="#JDK源码中的建造者模式" class="headerlink" title="JDK源码中的建造者模式"></a>JDK源码中的建造者模式</h3><p>StringBuilder不是严格的建造者模式，但是使用了建造者模式思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK中，不止StringBuilder、StringBuffer使用了建造者模式，还有：stream流</span></span><br><span class="line"><span class="comment">// 1.过滤只保留长度为3的字符串，收集成List&lt;String&gt;类型</span></span><br><span class="line">List&lt;String&gt; ansList = list.stream().filter(item -&gt; item.length() == <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 时间API</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><h3 id="角色分析"><a href="#角色分析" class="headerlink" title="角色分析"></a>角色分析</h3><h4 id="产品：char数组"><a href="#产品：char数组" class="headerlink" title="产品：char数组"></a>产品：char数组</h4><p>char数组，数组可以包含多个元素，每个元素是一个部件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">// The value is used for character storage.</span></span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象建造者：AbstractStringBuilder"><a href="#抽象建造者：AbstractStringBuilder" class="headerlink" title="抽象建造者：AbstractStringBuilder"></a>抽象建造者：AbstractStringBuilder</h4><p>AbstractStringBuilder包含append()、delete()等方法，用来对产品（字符数组）里的部件（数组内每个元素）进行追加和删除。</p><p><strong>部件组装方法</strong>：append() 、delete()</p><p>以append()为例：</p><p><strong>核心流程</strong>：</p><ol><li><strong>判空</strong>：如果传入的字符串为null，则不追加</li><li><strong>校验扩容</strong>：若新容量大于当前数组长度，则进行扩容</li><li><strong>拷贝数组</strong>：校验数组越界后，调用System.arraycopy()拷贝数组</li></ol><p><strong>具体代码</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象建造者：简化版AbstractStringBuilder</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value; <span class="comment">// 产品：一个字符数组</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">// 实际字符串长度</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品部件建造方法：追加字符串</span></span><br><span class="line"><span class="comment">     * 这个方法不一定必须是抽象方法，子类可以重写        </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> AbstractStringBuilder &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判空：如果传入的字符串为null，则不追加</span></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="comment">// 2.校验扩容：若新容量大于当前数组长度，则进行扩容</span></span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        <span class="comment">// 3.拷贝数组</span></span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        <span class="comment">// 调整字符串长度：给count变量加上追加字符串长度</span></span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容底层数组，@param minimumCapacity 新容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否需要扩容，若新容量大于当前数组长度，则进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = Arrays.copyOf(value, newCapacity(minimumCapacity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span> dst[], <span class="type">int</span> dstBegin)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查源开始索引是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查源结束索引是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查开始索引是否大于结束索引</span></span><br><span class="line">        <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(srcEnd - srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用System.arraycopy复制字符</span></span><br><span class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体建造者：重写append-返回类型"><a href="#具体建造者：重写append-返回类型" class="headerlink" title="具体建造者：重写append()返回类型"></a>具体建造者：重写append()返回类型</h4><p><strong>StringBuilder</strong></p><p>具体建造者StringBuilder继承了AbstractStringBuilder，并重写了append()方法。</p><p>append()逻辑都是用父类的append()方法，主要重写的地方在于<strong>返回类型由父类AbstractStringBuilder改成了子类StringBuilder</strong></p><blockquote><p><strong>重写规则：</strong>重写时</p><ul><li><strong>返回类可以是原返回类的子类。</strong>例如工厂方法设计模式里，抽象工厂类的createObject()方法返回值是抽象产品类，具体工厂类的createObject()方法返回类是具体产品类</li><li>访问权限不能比其父类更为严格</li><li>抛出异常不能比父类更广泛</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体建造者：简化版StringBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span> <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 追加字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> java.lang.StringBuilder &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123; <span class="comment">// // 由AbstactStringBuilder重写成StringBuilder</span></span><br><span class="line">        <span class="built_in">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StringBuffer</strong></p><p>相比StringBuilder的append()方法，主要修改了返回值，方法内第一步清空toStringCache变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体建造者：简化版StringBuffer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuffer</span> <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存上一次调用toString()方法返回的值。</span></span><br><span class="line"><span class="comment">     * 每当StringBuffer被修改时，这个缓存会被清除。</span></span><br><span class="line"><span class="comment">     * transient关键字表明此字段不会被序列化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">char</span>[] toStringCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 追加字符串</span></span><br><span class="line"><span class="comment">     *  1.重写加了synchronized关键字，保证线程安全</span></span><br><span class="line"><span class="comment">     *  2.返回类由AbstractStringBuilder改为StringBuffer</span></span><br><span class="line"><span class="comment">     *  3.方法内第一步清空toStringCache</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> java.lang.StringBuffer &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> java.lang.StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存上一次调用toString()方法返回的值，所以每次更新底层字符数组时，都需要清空；</span></span><br><span class="line">        toStringCache = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取实际字符串长度</span></span><br><span class="line"><span class="comment">     * StringBuffer线程安全的原因：有线程同步风险的方法都加了synchronized锁，锁的粒度是当前实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展：String、StringBuffer、Stringbuilder有什么区别</strong></p><blockquote><p>得分点：是否可变、复用率、效率、线程安全问题</p></blockquote><p><strong>标准回答</strong></p><p>**String:**不可变字符序列，效率低，但是复用率高、线程安全。</p><ul><li><strong>不可变</strong>：指String对象创建之后,直到这个对象销毁为止,对象中的字符序列都不能被改变。</li><li><strong>复用率高</strong>：指String类型对象创建出来后归常量池管，可以随时从常量池调用同一个String对象。StringBuffer和StringBuider在创建对象后一般要转化成String对象才调用。</li></ul><p><strong>StringBuffer和StringBuilder</strong>都是字符序列可变的字符串，方法也一样，有共同的父类AbstractStringBuilder。 </p><ul><li><strong>StringBuilder:<strong>可变字符序列、</strong>效率最高、线程不安全</strong></li><li><strong>StringBuffer:<strong>可变字符序列、效率较高(增删)、</strong>线程安全</strong></li></ul><p><strong>扩展：为什么StringBuffer是线程安全的</strong></p><p>点进源码后发现，有线程同步风险的方法（例如length()、append()、delete()等）都加了synchronized锁，锁的粒度是当前实例。</p><blockquote><p><strong>synchronized关键字作用于三个位置：</strong></p><ol><li>作用在静态方法上,则锁是当前类的Class对象。</li><li>作用在普通方法上,则锁是当前的实例（this）。</li><li>作用在代码块上,则需要在关键字后面的小括号里,显式指定锁对象，例如this、Xxx.class。</li></ol></blockquote><p><strong>为什么StringBuffer效率低？</strong></p><ol><li><strong>锁本身效率低</strong>：存在线程竞争时，加锁的代码块本身就比不加锁要慢很多，因为锁内的共享资源同一时刻只能一个线程访问。</li><li><strong>锁粒度大</strong>：锁的粒度是当前实例，直接给整个方法加synchronized，而不是具体需要在有同步风险的代码块上加锁，性能低。这个方法内部分共享资源可能是线程安全的，并不需要加锁。</li></ol><h4 id="指挥者：StringBuilder"><a href="#指挥者：StringBuilder" class="headerlink" title="指挥者：StringBuilder"></a>指挥者：StringBuilder</h4><p>StringBuilder和StringBuffer自身既是具体建造者，也是指挥者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 &lt;em&gt;Gang of Four&lt;/em&gt; (&lt;em&gt;GoF&lt;/em&gt;) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>设计模式七大原则</title>
    <link href="https://southernfish.github.io/2025/07/28/java/java-design-pattern-principle/"/>
    <id>https://southernfish.github.io/2025/07/28/java/java-design-pattern-principle/</id>
    <published>2025-07-28T02:20:36.000Z</published>
    <updated>2025-07-28T10:27:55.454Z</updated>
    
    <content type="html"><![CDATA[<p>软件设计模式的七大核心原则包括‌<strong>单一职责原则、开闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则和合成复用原则</strong>‌，这些原则构成了面向对象设计的基石。</p><blockquote><p>参考原文：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130403757">设计模式——设计模式简介和七大原则</a></p></blockquote><h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><ol><li><p><strong>单一职责原则（Single Responsibility Principle）</strong></p><p>对类来说，即<strong>一个类应该只负责一项职责</strong>。对接口来说，接口设计要符合单一职责原则，粒度越小通用性就越好。</p></li><li><p><strong>开闭原则（Open Close Principle）</strong></p><p><em>对扩展开放，对修改关闭</em>。</p></li><li><p><strong>里氏代换原则（Liskov Substitution Principle）</strong></p><p>只有当衍生类可替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p></li><li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个是开闭原则的基础，<em>对接口编程，依赖于抽象而不依赖于具体</em>。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong></p><p>使用多个隔离的接口来降低耦合度。</p></li><li><p><strong>迪米特法则（最少知道原则）（Demeter Principle）</strong></p><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><strong>合成复用原则（Composite Reuse Principle）</strong></p><p>原则是<em>尽量使用合成/聚合的方式，而不是使用继承</em>。<em>继承实际上破坏了类的封装性</em>，超类的方法可能会被子类修改。</p></li></ol><h2 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h2><p>对类来说，即一个类应该只负责一项职责。对接口来说，接口设计要符合单一职责原则，粒度越小通用性就越好。</p><blockquote><p>例如user表只负责存储用户相关的信息。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2</p></blockquote><p><strong>注意事项和细节</strong></p><ul><li><p>1）降低类的复杂度，一个类只负责一项职责</p></li><li><p>2）提高类的可读性，可维护性</p></li><li><p>3）降低变更引起的风险</p></li><li><p>4）通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；<strong>只有类中方法数量足够少</strong>，<strong>可以在方法级别保持单一职责原则</strong></p></li></ul><p><strong>案例：</strong></p><p><strong>方案1（违反单一原则）</strong>，方法内条件判断，区分情景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);vehicle.run(<span class="string">&quot;轮船&quot;</span>);vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;汽车&quot;</span>.equals(type)) &#123;</span><br><span class="line">            System.out.println(type + <span class="string">&quot;在公路上运行...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;轮船&quot;</span>.equals(type)) &#123;</span><br><span class="line">            System.out.println(type + <span class="string">&quot;在水面上运行...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;飞机&quot;</span>.equals(type)) &#123;</span><br><span class="line">            System.out.println(type + <span class="string">&quot;在天空上运行...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案2（单一职责）：</strong>不同类，区分情景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RoadVehicle</span> <span class="variable">roadVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoadVehicle</span>();</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        <span class="type">WaterVehicle</span> <span class="variable">waterVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaterVehicle</span>();</span><br><span class="line">        waterVehicle.run(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        <span class="type">AirVehicle</span> <span class="variable">airVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AirVehicle</span>();</span><br><span class="line">        airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遵守单一职责原则，但改动很大，即将类分解，同时修改客户端。改进：直接修改Vehicle类，改动的代码会比较少=&gt;方案3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoadVehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在公路上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterVehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在水面上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AirVehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在天空上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案3（方法级别单一职责）：不同方法，区分情景：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle2</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle2</span>();</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        vehicle.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有对原来的类做大的修改，只是增加方法。没有在类级别上遵守单一职责原则，但在方法级别上遵守单一职责</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在公路上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runWater</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在水面上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAir</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;在天空上运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><p><strong>客户端不应该依赖它不需要的接口</strong>，即一个类对另一个类的依赖应该建立在最小的接口上。</p><p>接口隔离原则（Interface Segregation Principle，ISP）是SOLID中的一个设计原则，它定义为“客户端应该不被迫依赖于它不使用的方法”，即一个类不应该强制依赖它不需要的接口。</p><p>接口隔离原则的主要目标是<strong>将庞大而臃肿的接口拆分成更小、更具体的接口</strong>，以方便客户端根据需求选择其所需的特定接口。这样可以大幅度减少客户端对于不必要的接口的依赖，使系统更加灵活、可维护和易于扩展。</p><p><strong>典型案例</strong>：当我们需要使用一个接口时，通常是需要实现该<strong>接口</strong>的所有方法，但是实际上可能<strong>只需要用到部分方法</strong>。如果这个接口包含很多方法，就会造成实现类的代码冗余和依赖性过强。</p><p>通过<strong>合理的接口拆分和组合</strong>，可以使得接口更加精简，提高代码的<strong>复用性和可拓展性</strong>。同时，也有利于提高代码的<strong>可维护性</strong>，降低代码修改时的风险和维护成本。</p><p><strong>注意</strong>：接口是一种描述行为的抽象，而隔离的目的是为了让接口更好地描述抽象行为，而不是让接口的数量变得多而复杂。因此，我们需要在接口隔离时保持适度，并根据具体情况进行选择和拆分。</p><p><strong>违法隔离的代码：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理实现 operation2，operation3，operation4，operation5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理实现 operation2，operation3，operation4，operation5</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A类通过接口Interface1依赖（使用）B类，但是只会用到1，2，3方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend2</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend3</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C类通过接口Interface1依赖（使用）D类，但是只会用到1，4，5方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend4</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend5</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拆分接口后的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface3</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>, Interface2 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>, Interface3 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A类通过接口Interface1,Interface2依赖（使用）B类，但是只会用到1，2，3方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend2</span><span class="params">(Interface2 i)</span> &#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend3</span><span class="params">(Interface2 i)</span> &#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C类通过接口Interface1,Interface3依赖（使用）D类，但是只会用到1，4，5方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span> &#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend4</span><span class="params">(Interface3 i)</span> &#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend5</span><span class="params">(Interface3 i)</span> &#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p><strong>高层模块不应该依赖低层模块，二者都应该依赖其抽象</strong>（接口或抽象类）</p></li><li><p>抽象不应该依赖细节，细节应该依赖抽象</p></li><li><p>依赖倒转（倒置）的中心思想是<strong>面向接口编程</strong></p></li><li><p>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，<strong>抽象的东西要稳定的多</strong>。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</p></li><li><p>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p></li><li><p><strong>多态</strong>是实现依赖倒转原则的方法之一。</p></li></ul><p><strong>案例：</strong>用户类接收邮件、微信等信息。</p><p><strong>违反依赖倒转</strong>：引用具体而非抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取的对象是微信，短信等等，则新增类，同时 Peron也要增加相应的接收方法</span></span><br><span class="line"><span class="comment">// 解决思路：引入一个抽象的接口IReceiver，表示接收者，这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">// 因为Email，Weixin等等属于接收的范围，他们各自实现IReceiver接口就ok，这样我们就符号依赖倒转原则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息：Hello World！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(Email email)</span> &#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进：多态的方式引用抽象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息：Hello World！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weixin</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信消息：Hello World！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShortMessage</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;短信信息：Hello World！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(IReceiver receiver)</span> &#123;</span><br><span class="line">        System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h3><ul><li><p><strong>低层模块尽量都要有抽象类或接口，</strong>或者两者都有，程序稳定性更好</p></li><li><p><strong>变量的声明类型尽量是抽象类或接口</strong>，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</p></li><li><p>继承时遵循里氏替换原则</p></li></ul><p><strong>开关电视的案例：</strong> </p><ol><li><p><strong>接口传递</strong>：ITV接口是IOpenAndClose接口的普通方法参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(ITV tv)</span>;    <span class="comment">// 抽象方法，接收接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ITV接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(ITV tv)</span>&#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造方法传递</strong>： ITV接口是OpenAndClose类的成员变量和构造方法参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ITV接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ITV tv;                 <span class="comment">// 成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAndClose</span><span class="params">(ITV tv)</span>&#123;     <span class="comment">// 构造器</span></span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>setter 方式传递</strong>：ITV接口是OpenAndClose类的成员变量和setter方法参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setTv</span><span class="params">(ITV tv)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ITV接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ITV tv;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTv</span><span class="params">(ITV tv)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="里氏替换原则（Liskov-Substitution-Principle）"><a href="#里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h2><p><strong>面对对象OO 中继承性的思考和说明</strong></p><ul><li><p>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果<strong>子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏</strong></p></li><li><p>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来<strong>侵入性</strong>，程序的可移植性降低，增加对象间的<strong>耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</p></li><li><p>问题提出：在编程中，如何正确使用继承？=&gt;里氏替换原则</p></li></ul><p><strong>基本介绍</strong></p><ul><li><p>在1988年，由麻省理工学院的以为姓里的女士提出</p></li><li><p><strong>父类型对象替换成子类型对象后功能未变：</strong>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象</p></li><li><p>在使用继承时，遵循里氏替换原则，在<strong>子类中尽量不要重写父类的方法</strong></p></li><li><p>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过<strong>聚合、组合、依赖</strong>来解决问题</p></li></ul><p><strong>案例：</strong></p><p><strong>传统方案：</strong>子类把父类的减方法重写为加方法：整个继承体系的复用性会比较差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 增加了一个新功能：完成两个数相加，然后和9求和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> func1(num1, num2) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进方案：</strong>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等关系代替</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个更加基础的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 将更基础的成员和方法写到Base类中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 如果B需要使用A类的方法，使用组合关系</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加了一个新功能：完成两个数相加，然后和9求和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> func1(num1, num2) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a.func1(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开闭原则（Open-Closed-Principle）"><a href="#开闭原则（Open-Closed-Principle）" class="headerlink" title="开闭原则（Open Closed Principle）"></a>开闭原则（Open Closed Principle）</h2><p><strong>开：</strong>对扩展开放。</p><p><strong>闭：</strong> 对修改关闭。</p><ul><li><p>开闭原则是编程中<strong>最基础、最重要</strong>的设计原则</p></li><li><p>一个软件实体如类、模块和函数应该<strong>对扩展开放</strong>（对提供者而言），<strong>对修改关闭</strong>（对使用者而言）。<strong>用抽象构建框架，用实现扩展细节</strong>。增加了新功能后，原来使用的代码并没有做更改。</p></li><li><p>当软件需要变化时，尽量通过<strong>扩展</strong>软件实体的行为来实现变化，而<strong>不是通过修改</strong>已有的代码来实现变化。</p></li><li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则</p></li></ul><p><strong>方案一：传统方案</strong>，一个画图形的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.m_type == <span class="number">1</span>) &#123;</span><br><span class="line">            drawRectangle(s);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>) &#123;</span><br><span class="line">            drawCircle(s);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>) &#123;</span><br><span class="line">            drawTriangle(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawTriangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    RectangleShape() &#123;</span><br><span class="line">        m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    CircleShape() &#123;</span><br><span class="line">        m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TriangleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    TriangleShape() &#123;</span><br><span class="line">        m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>方式 1 的优缺点</strong></p><ul><li><p>优点是比较好理解，简单易操作</p></li><li><p>缺点是<strong>违反了</strong>设计模式的 OCP 原则，即<strong>对扩展开放</strong>（提供方），<strong>对修改关闭</strong>（使用方）。即当我们给类增加新功能的时喉，尽量不修改代码，或者尽可能少修改代码</p></li><li><p>比如要新增加一个图形种类，需要做如下修改，修改的地方较多4）代码演示</p></li></ul><p><strong>方式 1 的改进的思路分析</strong></p><p>把创建 Shape 类做成<strong>抽象类</strong>，并提供一个<strong>抽象的 draw 方法</strong>，让子类去实现即可</p><p>这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并<strong>实现 draw 方法</strong>即可</p><p>使用方的代码就不需要修改，满足了<strong>开闭原则</strong></p></blockquote><p><strong>方式 2 开闭原则：</strong>画图功能设为基类的抽象方法，新增实现类只需要继承基类并实现画图的抽象方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">        s.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_type;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    RectangleShape() &#123;</span><br><span class="line">        m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    CircleShape() &#123;</span><br><span class="line">        m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TriangleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    TriangleShape() &#123;</span><br><span class="line">        m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪米特法则（Demeter-Principle）"><a href="#迪米特法则（Demeter-Principle）" class="headerlink" title="迪米特法则（Demeter Principle）"></a>迪米特法则（Demeter Principle）</h2><p><strong>基本介绍</strong></p><ul><li><p>一个对象应该对其他对象保持最少的了解</p></li><li><p>类与类关系越密切，耦合度越大</p></li><li><p>迪米特法则又叫<strong>最少知道原则</strong>，即<strong>一个类对自己依赖的类知道的越少越好。</strong>也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</p></li><li><p>迪米特法则还有个更简单的定义：<strong>只与直接的朋友通信</strong></p></li><li><p><strong>直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多：依赖、关联、组合、聚合等。其中，我们称<strong>出现成员变量，方法参数，方法返回值中的类为直接的朋友</strong>，而<strong>出现在局部变量中的类不是直接的朋友。</strong>也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p></li></ul><p><strong>注意事项和细节</strong></p><ul><li>主要A类里存在方法里B类是直接朋友，那么A类所有方法局部变量出现的B类都是直接朋友。</li><li>迪米特法则的核心是降低类之间的耦合</li><li><strong>注意</strong>：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系</li></ul><p><strong>传统方案：</strong>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总部员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 学院员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeEmployee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 学院员工管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();            <span class="comment">//是直接朋友</span></span><br><span class="line">        CollegeEmployee collegeEmployee;                        <span class="comment">// 是直接朋友</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            collegeEmployee = <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            collegeEmployee.setId(<span class="string">&quot;学院员工id=&quot;</span> + i);</span><br><span class="line">            list.add(collegeEmployee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总部员工管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SchoolManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 仅出现成员变量，方法参数，方法返回值中的类为直接的朋友</span></span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();                <span class="comment">// Employee 是直接朋友，出现在返回值</span></span><br><span class="line">        Employee employee;                                        <span class="comment">// 是直接朋友</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            employee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            employee.setId(<span class="string">&quot;总部员工id=&quot;</span> + i);</span><br><span class="line">            list.add(employee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAllEmployee</span><span class="params">(CollegeManager sub)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------学院员工--------------&quot;</span>);</span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();        <span class="comment">// 不是直接朋友，出现在局部变量</span></span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee collegeEmployee : list1) &#123;</span><br><span class="line">            System.out.println(collegeEmployee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------总部员工-------------&quot;</span>);</span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="built_in">this</span>.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : list2) &#123;</span><br><span class="line">            System.out.println(employee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用实例改进</strong></p><ul><li><p>前面设计的问题在于 SchoolManager 中，CollegeEmployee 类并不是 SchoolManager 类的直接朋友（分析）</p></li><li><p>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</p></li><li><p>对代码按照迪米特法则进行改进，<strong>将局部对象变量封装进参数里。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学院员工管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();            <span class="comment">// 是直接朋友</span></span><br><span class="line">        CollegeEmployee collegeEmployee;                        <span class="comment">// 是直接朋友</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            collegeEmployee = <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            collegeEmployee.setId(<span class="string">&quot;学院员工id=&quot;</span> + i);</span><br><span class="line">            list.add(collegeEmployee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改进，新增方法，输出学院员工信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployee</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------学院员工--------------&quot;</span>);</span><br><span class="line">         <span class="comment">// CollegeEmployee是直接朋友，出现在上面getAllEmployee()方法的返回值</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();   </span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee collegeEmployee : list1) &#123;</span><br><span class="line">            System.out.println(collegeEmployee.getId());</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总部员工管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SchoolManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 仅出现成员变量，方法参数，方法返回值中的类为直接的朋友</span></span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();            <span class="comment">// Employee 是直接朋友，出现在返回值</span></span><br><span class="line">        Employee employee;                                    <span class="comment">// 是直接朋友</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            employee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            employee.setId(<span class="string">&quot;总部员工id=&quot;</span> + i);</span><br><span class="line">            list.add(employee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAllEmployee</span><span class="params">(CollegeManager sub)</span> &#123;</span><br><span class="line">        sub.printEmployee();                                <span class="comment">// 改进，降低耦合，不用非直接朋友。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------总部员工-------------&quot;</span>);</span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="built_in">this</span>.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : list2) &#123;</span><br><span class="line">            System.out.println(employee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（Composite Reuse Principle）</h2><p><strong>基本介绍</strong></p><p>原则是尽量使用<strong>合成/聚合</strong>的方式，而不是使用继承。也就是把需要用到的类作为本类的参数、成员变量、局部变量。</p><ul><li><strong>依赖</strong>（Dependency）<strong>：</strong>指的是<strong>一个对象使用另一个对象</strong>的情况。通常是在一个对象的方法中传入另一个对象作为参数，或者在方法中创建另一个对象的实例。依赖关系是一种“短暂”的引用关系，一旦不再需要依赖对象就可以释放掉。</li><li><strong>合成</strong>（Composition）：指的是两个或多个对象之间一种包含与被包含的关系。其中<strong>包含对象是整体，被包含对象是零部件</strong>，它们的生命周期是一致的，无法单独存在。例如，一辆汽车是由发动机、车轮、底盘等组成的，这些组成部分与它们组合成的整体汽车具有相同的生命周期。当整体消亡时，所有零部件也随之消亡。</li><li><strong>聚合</strong>（Aggregation）：指的是两个或多个对象之间一种包含与被包含的关系，<strong>被包含对象可以存在于多个包含对象之间</strong>。在聚合关系中，被包含对象可以独立于包含对象存在，生命周期也不一定相同。例如，大学是由系部、学院、图书馆等组成的，这些部分可以独立存在，而且它们也可以属于不同的大学。即使整个大学消亡，它们仍然可以存在。</li></ul><p>总之，依赖、合成和聚合是面向对象编程中描述对象关系的重要概念，它们有助于设计和实现具有良好扩展性和可维护性的应用程序。</p><p><strong>案例</strong></p><p>B类想用A类方法，如果直接继承，那么耦合性会提高，之后A类修改后B类也得跟着修改。</p><p><strong>解决办法：</strong></p><ul><li>把A类作为B类普通方法的形参；</li><li>把A类作为B类成员变量，用setter方法</li><li>B类的普通方法里创建A类的对象；</li></ul><h2 id="其他原则"><a href="#其他原则" class="headerlink" title="其他原则"></a>其他原则</h2><h3 id="DRY原则"><a href="#DRY原则" class="headerlink" title="DRY原则"></a>DRY原则</h3><p><strong>DRY原则</strong>（Don’t Repeat Yourself）：即不要写重复的代码。</p><p><strong>代码重复的三种情况：</strong></p><ul><li><p><strong>实现逻辑重复</strong>：多段代码实现了相同的逻辑。例如有两个方法，虽然变量名和方法名不一样，但实际逻辑一模一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUserToDatabase</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span> &amp;&amp; user.isValid()) &#123;</span><br><span class="line">        database.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAdminToDatabase</span><span class="params">(User admin)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (admin != <span class="literal">null</span> &amp;&amp; admin.isValid()) &#123;</span><br><span class="line">        database.save(admin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>功能语意重复</strong>：多段代码实现了相同的功能。例如有两个方法，一个是遍历集合，一个是stream流遍历集合，只是表现形式不一样，实际功能医院。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用两种方式计算同样的总和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateTotal</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> number : numbers) &#123;</span><br><span class="line">        sum += number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateSum</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(numbers).sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>代码执行重复</strong>：多处地方调用了相同的多段代码。例如完全不抽取方法，一个service方法几千行，很多重复的代码没抽取方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;Order started&quot;</span>);</span><br><span class="line">    <span class="comment">// other order processing code</span></span><br><span class="line">    log.info(<span class="string">&quot;Order started&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>解决方案：</strong></p><ul><li><strong>三层架构</strong>：开发过程中，我们把后端服务器Servlet拆分成三层，分别是web、service和dao，这也是程序员常提到的<strong>“Java味”</strong></li><li><strong>模块化</strong>：将项目按业务分成相互隔离的多模块，然后抽取出一个common模块让其他模块调用，降低耦合；</li><li><strong>满足单一职责</strong>：即一个类应该只负责一项职责、一个接口只实现一个功能。</li><li><strong>封装继承多态</strong>：抽取公用代码为新方法、使用继承的方式替代重复成员变量、方法的编写。</li><li><strong>模板等设计模式</strong>：将通用逻辑抽取成新方法。</li></ul><hr><h1 id="UML类图：统一建模语言"><a href="#UML类图：统一建模语言" class="headerlink" title="UML类图：统一建模语言"></a>UML类图：统一建模语言</h1><ul><li>UML—-Unified modeling language UML（<strong>统一建模语言</strong>），是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</li><li>UML 本身是<strong>一套符号的规定</strong>，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</li><li>使用 UML 来建模，常用的工具有 Rational Rose，也可以使用一些插件来建模</li></ul><p><strong>UML 类图</strong></p><ul><li><p>用于描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系</p></li><li><p>类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合</p></li></ul><h2 id="依赖（dependence）"><a href="#依赖（dependence）" class="headerlink" title="依赖（dependence）"></a>依赖（dependence）</h2><p>只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编译都通过不了。A用到B，那么A依赖B，即A——-&gt;B。</p><ul><li><p>类中用到了对方</p></li><li><p>类的成员属性</p></li><li><p>方法的返回类型</p></li><li><p>方法接收的参数类型</p></li><li><p>方法中使用到 </p></li></ul><h2 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h2><p>泛化关系实际上就是<strong>继承</strong>关系，它是依赖关系的特例。A继承B，那么A➞B。</p><h2 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h2><p>关联关系<strong>实际上就是类与类之间的联系</strong>，它是依赖关系的特例</p><p>关联具有导航性：即双向关系或单向关系<br>关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”（表示n到m个都可以），“m…*”（表示至少m个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向一对一关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向一对一关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h2><p>聚合关系表示的是<strong>整体和部分的关系</strong>，<strong>整体与部分可以分开</strong>。聚合关系是关联关系的特例，所以它具有关联的导航性与多重性</p><p>B是A的未实例化成员变量，则B—◇A</p><p>如：一台电脑由键盘（keyboard）、显示器（monitor），鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：Mouse—◇Computer，Monitor—◇Computer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monitor</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">    <span class="keyword">private</span> Monitor monitor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mouse = mouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMonitor</span><span class="params">(Monitor monitor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.monitor = monitor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>组合关系也是<strong>整体与部分的关系</strong>，但是<strong>整体与部分不可以分开</strong></p><p>B是A的实例化成员变量，则B&lt;—◇A</p><p>如果我们认为 Mouse、Monitor 和 Computer 是不可分离的，则升级为组合关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monitor</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Mouse</span> <span class="variable">mouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Monitor</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monitor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个案例，在程序中我们定义实体：Person 与 IDCard、Head，那么 Head 和 Person 就是组合，IDCard 和 Person 就是聚合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Head</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Head</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Head</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件设计模式的七大核心原则包括‌&lt;strong&gt;单一职责原则、开闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则和合成复用原则&lt;/strong&gt;‌，这些原则构成了面向对象设计的基石。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考原文：&lt;/p&gt;
&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>设计模式介绍及简单实现</title>
    <link href="https://southernfish.github.io/2025/07/28/java/java-design-pattern/"/>
    <id>https://southernfish.github.io/2025/07/28/java/java-design-pattern/</id>
    <published>2025-07-28T01:26:36.000Z</published>
    <updated>2025-07-28T10:27:55.455Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130403757">设计模式——设计模式简介和七大原则</a></p><p><a href="https://mp.weixin.qq.com/s/DxPjhfI3Wn70ORK-Q3FrMQ">如何优雅的将设计模式运用到实际项目中去?</a></p></blockquote><h1 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验。模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳实践。</p></li><li><p>设计模式的本质提高软件的维护性、通用性和扩展性，并降低软件的复杂度</p></li><li><p>《<strong>Design Patterns - Elements of Reusable Object-Oriented Software</strong>》（设计模式 - 可复用的面向对象软件元素）是经典的书，该书首次提到了软件开发中设计模式的概念。作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design，合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong></p></li><li><p>设计模式并不局限于某种语言，Java、PHP、C++ 都有设计模式</p></li></ol><h2 id="设计模式目的及核心思想"><a href="#设计模式目的及核心思想" class="headerlink" title="设计模式目的及核心思想"></a>设计模式目的及核心思想</h2><p><strong>重要性</strong>： </p><ol><li><p>设计模式是软件设计中普遍存在问题的解决方案。</p></li><li><p>便于项目开发完成后维护项目（可读性、规范性）、新增功能。</p></li><li><p>你在实际项目中使用过什么设计模式，怎么使用的？解决了什么问题？</p></li><li><p>项目的功能模块和框架里会使用设计模式。</p></li></ol><p><strong>设计模式目的</strong>：</p><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战。</p><p>设计模式是为了让程序（软件），具有更好的</p><ol><li><p>可复用性（即：相同功能的代码，不用多次编写，也叫做代码重用性）</p></li><li><p>可读性（即：编程规范性，便于其他程序员的阅读和理解）</p></li><li><p>可扩展性（即：当需要增加新的功能时，非常的方便，也叫做可维护性）</p></li><li><p>可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</p></li><li><p>使程序呈现高内聚，低耦合的特性</p></li></ol><p><strong>设计原则核心思想</strong></p><ul><li><p>1）找出应用中可能<strong>需要变化之处，把它们独立出来</strong>，不要和那些不需要变化的代码混在一起</p></li><li><p>2）针对<strong>接口编程</strong>，而不是针对实现编程</p></li><li><p>3）为了交互对象之间的<strong>松耦合</strong>设计而努力</p></li></ul><h2 id="设计模式分类（3类）"><a href="#设计模式分类（3类）" class="headerlink" title="设计模式分类（3类）"></a>设计模式分类（3类）</h2><h3 id="创建型模式（对象创建优化）"><a href="#创建型模式（对象创建优化）" class="headerlink" title="创建型模式（对象创建优化）"></a>创建型模式（对象创建优化）</h3><p><strong>创建型模式</strong>（Creational Patterns）：主要<strong>用于对象的创建</strong>，包括多个不同的模式，如工厂方法模式、抽象工厂模式、建造者模式、单例模式和原型模式等。这些模式都有助于降低系统耦合度，并提高代码的可重用性和可扩展性。</p><ol><li><strong>单例模式</strong><ul><li><strong>作用</strong>：确保类仅有一个实例（如数据库连接池），全局共享访问点。</li><li><strong>实现</strong>：双重检查锁（<code>volatile</code> + <code>synchronized</code>）或静态内部类。</li></ul></li><li><strong>工厂模式</strong><ul><li><strong>简单工厂</strong>：通过参数类型创建对象，<strong>将对象创建延迟到子类</strong>（如支付方式：支付宝/微信）。</li><li><strong>工厂方法</strong>：子类决定实例化逻辑（扩展性更强）。</li><li><strong>抽象工厂</strong>：创建相关对象族（如跨平台UI组件）。</li></ul></li></ol><blockquote><p>单例模式（Singleton Pattern）、工厂模式（Factory Pattern）、抽象工厂模式（Abstract Factory Pattern）</p><p>建造者模式（Builder Pattern）、原型模式（Prototype Pattern）</p></blockquote><h3 id="结构型模式（类-对象组合优化）"><a href="#结构型模式（类-对象组合优化）" class="headerlink" title="结构型模式（类/对象组合优化）"></a>结构型模式（类/对象组合优化）</h3><p><strong>结构型模式</strong>（Structural Patterns）：主要<strong>用于描述对象之间的组合关系</strong>，包括多个不同的模式，如“代理模式”、“适配器模式”、“桥接模式”、“装饰者模式”、“外观模式”、“享元模式”和“组合模式”等。这些模式可以帮助我们更好地设计程序结构，提高代码灵活性和可维护性。</p><ol><li><strong>适配器模式</strong><ul><li><strong>场景</strong>：兼容接口差异（如老式打印机接入新系统）；</li><li><strong>类型</strong>：类适配器（继承）或对象适配器（组合）。</li></ul></li><li><strong>装饰器模式</strong><ul><li><strong>动态扩展功能</strong>：替代继承避免类爆炸（如Java I/O流嵌套包装）。</li></ul></li><li><strong>代理模式</strong><ul><li><strong>控制访问</strong>：远程调用（RPC）、权限校验（Spring AOP切面)。</li></ul></li><li><strong>外观模式</strong><ul><li>提供一个<strong>统一的接口，用来访问子系统</strong>中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li></ul></li></ol><blockquote><p>适配器模式（Adapter Pattern）、装饰器模式（Decorator Pattern）、代理模式（Proxy Pattern）<br>外观模式（Facade Pattern）</p><p>桥接模式（Bridge Pattern）、过滤器模式（Filter、Criteria Pattern）、组合模式（Composite Pattern）<br>享元模式（Flyweight Pattern）</p></blockquote><h3 id="行为型模式（对象交互优化）"><a href="#行为型模式（对象交互优化）" class="headerlink" title="行为型模式（对象交互优化）"></a>行为型模式（对象交互优化）</h3><p><strong>行为型模式</strong>（Behavioral Patterns）：主要<strong>用于描述对象之间的通信和责任分配</strong>，包括多个不同的模式，如“策略模式”、“模板方法模式”、“观察者模式”、“迭代器模式”、“职责链模式”、“命令模式”、“访问者模式”、“备忘录模式”和“解释器模式”等。这些模式通常用于实现不同的算法、流程和通信方式，以实现系统的更高灵活性和可维护性。</p><ol><li><p><strong>策略模式</strong></p><ul><li><strong>算法封装</strong>：电商促销策略（满减/折扣）动态切换；</li><li><strong>实现</strong>：<code>Comparator</code>接口实现自定义排序。</li></ul></li><li><p><strong>观察者模式</strong></p><ul><li><strong>事件驱动</strong>：定义了<strong>对象之间的一对多的依赖</strong>，一对多状态通知（如配置中心变更推送）；</li><li><strong>工具</strong>：<code>java.util.Observable</code>。</li></ul></li><li><p><strong>责任链模式</strong></p><ul><li><strong>流程解耦</strong>：多级审批系统或过滤器链（如Servlet Filter）。</li></ul></li><li><p><strong>模版方法模式</strong>（Template Method）</p><ul><li>定义了一个算法的骨架，子类重写特定步骤中，模版方法使得<strong>子类可在不改变算法结构的情况下，重新定义算法的步骤</strong>，（如<code>JdbcTemplate</code>执行流程固定）。</li></ul></li><li><p><strong>状态模式</strong>（State）</p><ul><li>对象行为随内部状态改变（如订单状态机：待支付→已发货）‌，允许<strong>对象在内部状态改变时改变它的行为</strong>。</li></ul></li></ol><blockquote><p>策略模式（Strategy Pattern）、观察者模式（Observer Pattern）、责任链模式（Chain of Responsibility Pattern）<br>模板模式（Template Pattern）、状态模式（State Pattern）</p><p>命令模式（Command Pattern）、解释器模式（Interpreter Pattern）、迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）、备忘录模式（Memento Pattern）、空对象模式（Null Object Pattern）<br>访问者模式（Visitor Pattern）</p></blockquote><h3 id="J2EE-模式"><a href="#J2EE-模式" class="headerlink" title="J2EE 模式"></a>J2EE 模式</h3><p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</p><blockquote><ul><li>MVC 模式（MVC Pattern）</li><li>业务代表模式（Business Delegate Pattern）</li><li>组合实体模式（Composite Entity Pattern）</li><li>数据访问对象模式（Data Access Object Pattern）</li><li>前端控制器模式（Front Controller Pattern）</li><li>拦截过滤器模式（Intercepting Filter Pattern）</li><li>服务定位器模式（Service Locator Pattern）</li><li>传输对象模式（Transfer Object Pattern）</li></ul></blockquote><h2 id="关键应用对照表"><a href="#关键应用对照表" class="headerlink" title="关键应用对照表"></a>关键应用对照表</h2><table><thead><tr><th>模式</th><th>典型应用场景</th><th>代表框架实现</th></tr></thead><tbody><tr><td><strong>单例</strong></td><td>配置管理器、线程池</td><td>Spring Bean默认作用域</td></tr><tr><td><strong>工厂方法</strong></td><td>Spring的<code>FactoryBean</code>接口</td><td><code>BeanFactory</code>实例化对象</td></tr><tr><td><strong>代理</strong></td><td>MyBatis的Mapper接口动态代理</td><td>JDK动态代理生成DAO对象</td></tr><tr><td><strong>观察者</strong></td><td>Spring的事件监听机制（<code>ApplicationEvent</code>）</td><td>配置更新广播</td></tr></tbody></table><h2 id="模式选择原则"><a href="#模式选择原则" class="headerlink" title="模式选择原则"></a>模式选择原则</h2><ul><li>创建对象复杂 → 工厂模式</li><li>扩展对象功能 → 装饰器/代理</li><li>算法灵活切换 → 策略模式</li><li>状态联动更新 → 观察者模式‌</li></ul><h2 id="三种工厂模式的应用场景"><a href="#三种工厂模式的应用场景" class="headerlink" title="三种工厂模式的应用场景"></a>三种工厂模式的应用场景</h2><table><thead><tr><th><strong>模式</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>简单工厂</strong></td><td>产品种类少且不常变化，客户端只需传入参数，无需关心创建逻辑。</td></tr><tr><td><strong>工厂方法</strong></td><td>需要灵活扩展新产品，且不同子类可能需要不同的创建逻辑。</td></tr><tr><td><strong>抽象工厂</strong></td><td>需要创建一组相关或依赖的对象（产品族），且系统需要支持多套产品配置。</td></tr></tbody></table><h2 id="设计模式遵循的原则"><a href="#设计模式遵循的原则" class="headerlink" title="设计模式遵循的原则"></a>设计模式遵循的原则</h2><ol><li><p><strong>单一职责原则（Single Responsibility Principle）</strong></p><p>对类来说，即<strong>一个类应该只负责一项职责</strong>。对接口来说，接口设计要符合单一职责原则，粒度越小通用性就越好。</p></li><li><p><strong>开闭原则（Open Close Principle）</strong></p><p><em>对扩展开放，对修改关闭</em>。</p></li><li><p><strong>里氏代换原则（Liskov Substitution Principle）</strong></p><p>只有当衍生类可替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p></li><li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个是开闭原则的基础，<em>对接口编程，依赖于抽象而不依赖于具体</em>。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong></p><p>使用多个隔离的接口来降低耦合度。</p></li><li><p><strong>迪米特法则（最少知道原则）（Demeter Principle）</strong></p><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><strong>合成复用原则（Composite Reuse Principle）</strong></p><p>原则是<em>尽量使用合成/聚合的方式，而不是使用继承</em>。<em>继承实际上破坏了类的封装性</em>，超类的方法可能会被子类修改。</p></li></ol><hr><h1 id="设计模式简单实现模板"><a href="#设计模式简单实现模板" class="headerlink" title="设计模式简单实现模板"></a>设计模式简单实现模板</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>‌单例模式的核心应用场景包括<strong>资源管理、配置管理、日志记录、数据库连接池</strong>等需要全局唯一实例的场景‌。该模式通过确保类仅有一个实例并提供全局访问点，优化系统性能和资源利用率。‌‌‌‌</p><p><strong>核心应用场景</strong>‌</p><ol><li><p>‌<strong>资源管理优化</strong>‌<br>适用于需频繁创建和销毁的高成本资源（如数据库连接、线程池、硬件外设管理），通过共享唯一实例减少内存开销和性能损耗。‌‌‌‌ </p><ul><li><strong>数据库连接池</strong>：避免重复建立连接，提升数据库操作效率</li><li><strong>硬件外设管理</strong>：如SPI Flash、ADC模块的全局访问控制</li></ul></li><li><p><strong>全局状态一致性</strong><br>确保多线程或跨模块访问时数据同步，例如： </p><ul><li><strong>配置管理器</strong>：统一管理应用程序配置参数，防止状态不一致</li><li><strong>日志记录器</strong>：集中处理日志输出，便于跟踪和分析</li></ul></li><li><p><strong>性能敏感场景</strong>‌</p><ul><li><strong>缓存系统</strong>：全局唯一的缓存实例可避免重复加载数据</li><li><strong>游戏引擎核心组件</strong>：如资源管理器、纹理加载器等</li></ul></li></ol><ol start="4"><li><p><strong>其他典型场景</strong>‌</p><ul><li><p><strong>操作系统服务</strong>‌：如任务管理器、回收站等需唯一实例的系统组件</p></li><li><p><strong>ID生成器/计数器‌</strong>：生成唯一序列时防止多实例导致冲突</p></li><li><p><strong>跨进程共享对象</strong>‌：如.NET框架中的远程单例对象</p></li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式（静态内部类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个静态内部类，该类中有一个静态属性Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>通过一个工厂类，根据传入的参数动态决定创建哪种具体产品类的实例。<br><strong>核心</strong>：将对象的创建逻辑集中在一个类中</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>产品种类较少且固定；客户端不需要关心对象创建细节。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>场景</strong>：用户支付场景，目前支持支付宝支付和微信支付，未来会新增银行卡，云闪付等方式。使用策略模式，每一种支付方式都是一种策略，根据用户传入的支付类型，创建不同的策略类，使用工厂模式，通过封装一个<code>PaymentStrategyHandler</code>策略处理类，其他系统直接通过一个统一的入口，进行该功能的调用，使用门面模式。</p><ol><li><p><strong>定义一个策略类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPayment</span> &#123;</span><br><span class="line">    Boolean <span class="title function_">pay</span><span class="params">(PaymentBody paymentBody)</span>; <span class="comment">// 支付</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliPay</span> <span class="keyword">implements</span> <span class="title class_">IPayment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">pay</span><span class="params">(PaymentBody paymentBody)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝支付...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPay</span> <span class="keyword">implements</span> <span class="title class_">IPayment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">pay</span><span class="params">(PaymentBody paymentBody)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;微信支付...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionPay</span> <span class="keyword">implements</span> <span class="title class_">IPayment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">pay</span><span class="params">(PaymentBody paymentBody)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;银联支付...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建策略工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.EnumUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ReflectUtil;</span><br><span class="line"><span class="keyword">import</span> com.universal.core.designPatterns.enums.PayStrategyEnum;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory for payment methods</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IPayment <span class="title function_">getPayStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.通过枚举中的type获取对应的value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> EnumUtil.getFieldBy(PayStrategyEnum::getValue, PayStrategyEnum::getType, type);</span><br><span class="line">        <span class="comment">// 2.使用反射机制创建对应的策略类</span></span><br><span class="line">        <span class="type">IPayment</span> <span class="variable">payment</span> <span class="operator">=</span> ReflectUtil.newInstance(value);</span><br><span class="line">        <span class="keyword">return</span> payment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义策略枚举</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付策略枚举</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PayStrategyEnum</span> &#123;</span><br><span class="line">    ZFB(<span class="string">&quot;ZFB&quot;</span>, <span class="string">&quot;com.universal.core.designPatterns.factory.impl.AliPay&quot;</span>),</span><br><span class="line">    WX(<span class="string">&quot;WX&quot;</span>, <span class="string">&quot;com.universal.core.designPatterns.factory.impl.WechatPay&quot;</span>),</span><br><span class="line">    UNION(<span class="string">&quot;UNION&quot;</span>, <span class="string">&quot;com.universal.core.designPatterns.factory.impl.UnionPay&quot;</span>);</span><br><span class="line">    String type;</span><br><span class="line">    String value;</span><br><span class="line">    </span><br><span class="line">    PayStrategyEnum(String type, String value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建策略的上下文角色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentContext</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IPayment paymentStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PaymentContext</span><span class="params">(IPayment paymentStrategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentStrategy = paymentStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">pay</span><span class="params">(PaymentBody paymentBody)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.paymentStrategy.pay(paymentBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>提供统一访问处理入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.EnumUtil;</span><br><span class="line"><span class="keyword">import</span> com.universal.core.designPatterns.enums.PayStrategyEnum;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentStrategyHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">pay</span><span class="params">(PaymentBody payBody)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!EnumUtil.contains(PayStrategyEnum.class, payBody.getType())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;不支持的支付方式!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.获取支付策略对象</span></span><br><span class="line">        <span class="type">IPayment</span> <span class="variable">payStrategy</span> <span class="operator">=</span> PaymentFactory.getPayStrategy(payBody.getType());</span><br><span class="line">        <span class="comment">// 2.获取支付策略上下文</span></span><br><span class="line">        <span class="type">PaymentContext</span> <span class="variable">paymentContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentContext</span>(payStrategy);</span><br><span class="line">        <span class="comment">// 3.进行支付</span></span><br><span class="line">        <span class="keyword">return</span> paymentContext.pay(payBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/designPatterns&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesignPatternController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/pay&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">pay</span><span class="params">(<span class="meta">@RequestBody</span> PaymentBody paymentBody)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PaymentStrategyHandler.pay(paymentBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="与简单工厂的区别"><a href="#与简单工厂的区别" class="headerlink" title="与简单工厂的区别"></a>与简单工厂的区别</h3><p>简单工厂模式的最大优点在于包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，相对于客户端来说，去除了与具体产品的依赖。</p><ul><li> <strong>简单工厂：</strong>用来<strong>生产同一等级结构中的任意产品</strong>，对于增加新的产品，无能为力。    </li><li> <strong>工厂方法：</strong>用来<strong>生产同一等级结构中的固定产品</strong>，支持增加任意产品。</li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>产品种类可能动态扩展；需要将对象创建逻辑分散到不同子类中</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p><code>工厂方法模式（Factory Method）</code>，定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法是一个类的实例化延迟到其子类，通俗来说：它提供了一种实例化逻辑委托子类的方法。<strong>代码示例：</strong></p><ol><li><p><strong>定义<code>NetworkConfigFactoryService</code>工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.universal.core.designPatterns.factoryMethod.NetworkConfigCrudService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NetworkConfigFactoryService</span> &#123;</span><br><span class="line">    <span class="comment">// 获取指定的处理逻辑类</span></span><br><span class="line">    <span class="comment">// @param productType</span></span><br><span class="line">    NetworkConfigCrudService <span class="title function_">getSpecificService</span><span class="params">(String productType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>NetworkConfigFactoryService</code>工厂实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetworkConfigFactoryServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">NetworkConfigFactoryService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AServiceImpl aService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BServiceImpl bService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CServiceImpl cService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DServiceImpl dService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkConfigCrudService <span class="title function_">getSpecificService</span><span class="params">(String productType)</span> &#123;</span><br><span class="line">        <span class="type">NetworkConfigCrudService</span> <span class="variable">networkConfigCrudService</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (productType)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>: networkConfigCrudService = aService; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>: networkConfigCrudService = bService; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>: networkConfigCrudService = cService; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;D&quot;</span>: networkConfigCrudService = dService; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> networkConfigCrudService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义网点操作接口<code>NetworkConfigCrudService</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NetworkConfigCrudService</span> &#123;</span><br><span class="line">    NetworkConfigVO <span class="title function_">getNetwork</span><span class="params">(NetworkConfigDTO networkConfigDTO)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现类分别是 <code>AServiceImpl</code>、<code>BServiceImpl</code>、<code>CServiceImpl</code>、<code>DServiceImpl</code>，分别对应不同的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">NetworkConfigCrudService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkConfigVO <span class="title function_">getNetwork</span><span class="params">(NetworkConfigDTO networkConfigDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NetworkConfigVO</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">NetworkConfigCrudService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkConfigVO <span class="title function_">getNetwork</span><span class="params">(NetworkConfigDTO networkConfigDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NetworkConfigVO</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">NetworkConfigCrudService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkConfigVO <span class="title function_">getNetwork</span><span class="params">(NetworkConfigDTO networkConfigDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NetworkConfigVO</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">NetworkConfigCrudService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkConfigVO <span class="title function_">getNetwork</span><span class="params">(NetworkConfigDTO networkConfigDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NetworkConfigVO</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>控制层NetworkConfigController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/networkConfig&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetworkConfigController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NetworkConfigFactoryService factoryService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/getNetworkDetails&quot;, produces = MediaType.APPLICATION_JSON_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;NetworkConfigVO&gt; <span class="title function_">getNetworkDetails</span><span class="params">(<span class="meta">@RequestBody</span> NetworkConfigDTO networkConfigDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取AService处理类逻辑</span></span><br><span class="line">        <span class="type">NetworkConfigCrudService</span> <span class="variable">aService</span> <span class="operator">=</span> factoryService.getSpecificService(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">NetworkConfigVO</span> <span class="variable">network</span> <span class="operator">=</span> aService.getNetwork(networkConfigDTO);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.success(network);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>定义 提供一个接口，用于创建相关或依赖对象家族，而无需指定具体类。<br><strong>核心</strong>：生产多个产品族（如不同操作系统下的UI组件）</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p> 需要创建多个相互关联的产品（如不同主题的UI组件、跨平台适配）；系统需要独立于产品的创建和组合过程</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义产品族接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体产品族实现（Windows风格）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Windows风格按钮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Windows风格文本框&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 具体产品族实现（MacOS风格）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacOSButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MacOS风格按钮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacOSTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MacOS风格文本框&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 抽象工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 具体工厂实现-windows</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 具体工厂实现（MacOS风格）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacOSFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacOSButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacOSTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 客户端调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GUIFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacOSFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> factory.createButton();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField</span> <span class="operator">=</span> factory.createTextField();</span><br><span class="line">        button.render();           <span class="comment">// 输出：MacOS风格按钮</span></span><br><span class="line">        textField.display();    <span class="comment">// 输出：MacOS风格文本框</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><strong><code>适配器模式Adapter</code></strong> 是将一个接口转换成另一个客户所期望的接口。**<code>Adapter</code>** 适配器让那些本来因为接口不兼容的类可以合作无间。</p><p><a href="https://blog.csdn.net/weixin_43718423/article/details/148005751">Spring 框架中适配器模式的五大典型应用场景</a></p><h3 id="适配器模式的角色分析"><a href="#适配器模式的角色分析" class="headerlink" title="适配器模式的角色分析"></a>适配器模式的角色分析</h3><ul><li><strong>目标接口（Traget）</strong>：客户期待的接口，目标可以是具体的或者抽象的类，也可以是接口。</li><li><strong>需要适配的对象（Source Adaptee）</strong>：需要适配的对象。</li><li><strong>适配器（Adapter）</strong>：通过包装一个需要适配的对象，把原接口转成目标接口。</li></ul><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>Java适配器模式在实际开发中主要应用于<strong>系统整合、接口兼容和功能扩展</strong>三大场景，通过对象适配器和类适配器两种方式实现接口转换。</p><p><strong>典型应用场景</strong></p><ol><li><p><strong>系统整合场景</strong>。 将旧系统的接口适配到新系统（如日志框架转换）。 <strong>示例</strong>：</p><ul><li>通过<code>FileLoggerAdapter</code>将基于文件的日志写入适配到数据库日志接口。</li><li><strong>企业级应用</strong>：整合遗留系统接口与企业中台规范。</li></ul></li><li><p><strong>接口兼容场景</strong>。 多线程开发中将<code>Callable</code>适配为Runnable接口。 <strong>示例</strong>：</p><ul><li><code>RunnableAdapter</code>转发Callable任务给Thread执行。</li><li><strong>JDK应用</strong>：<code>InputStreamReader</code>将字节流适配为字符流。</li></ul></li><li><p><strong>功能扩展场景</strong>。 多媒体播放器扩展播放格式。 <strong>示例</strong>：</p><ul><li><code>MediaPlayer</code>适配<code>AdvancedMediaPlayer</code>实现<code>mp4/vlc</code>播放支持</li><li><strong>Android开发</strong>：<code>BaseAdapter</code>统一<code>ListView</code>与不同类型数据源的交互。</li></ul></li></ol><p><strong>实现方式对比</strong></p><ol><li><strong>对象适配器</strong>（推荐）。 通过组合持有被适配对象实例。 <strong>优势</strong>：支持多态、适配器可复用、避免单继承限制。  </li><li><strong>类适配器</strong>。 通过继承实现接口转换。 <strong>局限</strong>：单继承限制、无法适配多个类。 <strong>示例</strong>：<ul><li><code>ExpensiveAdapter</code>继承<code>HuaweiPhone</code>实现Player接口。</li></ul></li></ol><p><strong>最佳实践原则</strong></p><ol><li><strong>接口设计规范</strong>。 目标接口保持最小化定义。 适配器类命名遵循<code>XxxAdapter</code>格式。</li><li><strong>组合优于继承</strong>。 对象适配器比例达<code>85%</code>以上（Java设计规范推荐）。组合方式降低耦合度，支持动态替换适配对象。</li><li><strong>异常处理机制</strong>。 在适配器中处理被适配对象的异常。 示例：<ul><li><code>RunnableAdapter</code>捕获Callable异常并转换为运行时异常。</li></ul></li></ol><h3 id="类适配器代码实现"><a href="#类适配器代码实现" class="headerlink" title="类适配器代码实现"></a>类适配器代码实现</h3><p><strong>场景</strong>：以网线上网为例，现在有一根水晶头网线，但它的接口与电脑的不匹配（因为电脑的是<code>usb</code>或者<code>typec</code>），那就需要一个转接头，也就是适配器，才能上网，下面的转接头可理解为适配器：</p><ol><li><p>我们拥有一根网线, 其有上网的功能，但是它的接口与电脑不匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要适配的类：网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;                    <span class="comment">// 功能：上网</span></span><br><span class="line">        System.out.println(<span class="string">&quot;链接网线上网&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个<code>usb</code>接口，也就是目标接口（Target）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口转换器的抽象实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NetToUsb</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span>;            <span class="comment">// 作用：处理请求，网线 =&gt; usb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个适配器继承着网线，连接着<code>usb</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的适配器，余姚链接usb,连接网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">NetToUsb</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.request();                    <span class="comment">// 可以上网了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上网的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端类：想上网，插不上网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="comment">// 电脑需要连接上转接器才可以上网</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">net</span><span class="params">(NetToUsb adapter)</span>&#123;</span><br><span class="line">        adapter.handleRequest();             <span class="comment">// 上网的具体实现：找一个转接头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 电脑，适配器，网线</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(); <span class="comment">// 电脑</span></span><br><span class="line">        <span class="type">Adapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>();    <span class="comment">// 转接器</span></span><br><span class="line">        computer.net(adapter);              <span class="comment">// 电脑直接连接转接器就可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="对象适配器应用"><a href="#对象适配器应用" class="headerlink" title="对象适配器应用"></a>对象适配器应用</h3><ul><li>java.util.Arrays#asList()open in new window</li><li>java.util.Collections#list()open in new window</li><li>java.util.Collections#enumeration()open in new window</li><li>javax.xml.bind.annotation.adapters.XMLAdapter</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>**<code>代理模式Proxy</code>**，为其他对象提供一种代理以控制对这个对象的访问。</p><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><p>‌代理模式的核心使用场景包括<strong>访问控制、功能扩展和对象隔离</strong>三大类‌，具体可分为<strong>远程访问优化、资源延迟加载、权限管理、性能增强</strong>等典型应用场景。‌</p><p><strong>远程服务访问</strong>‌</p><ol><li><p>‌<strong>远程代理</strong>‌：解决跨网络对象调用问题，客户端通过本地代理对象访问远程服务端资源。典型应用包括： </p><ul><li>分布式系统中的<code>RPC</code>调用（如<code>Dubbo</code>框架）</li><li>数据库连接池管理</li><li><code>CORBA</code>远程对象调用</li></ul></li></ol><p><strong>资源访问控制</strong>‌</p><ol><li><p>‌<strong>保护代理</strong>‌：通过权限过滤实现访问控制，包含两种实现维度： </p><ul><li><p><strong>身份认证代理</strong>：控制特定用户/角色的操作权限（如<code>OA</code>系统审批接口代理）</p></li><li><p><strong>防火墙代理</strong>：过滤非法请求（如<code>Web</code>应用防火墙）</p></li></ul></li><li><p><strong>虚拟代理</strong>‌：优化高开销对象的使用效率： </p><ul><li>大型文件加载时显示缩略图（如图库管理系统）</li><li>延迟加载数据库连接（如<code>MyBatis</code>延迟加载）</li><li>视频流分片加载（如在线视频网站）</li></ul></li></ol><p><strong>系统功能增强</strong>‌</p><ol><li><p>‌<strong>智能代理</strong>‌：在方法调用前后插入扩展逻辑： </p><ul><li>日志记录代理（记录<code>API</code>调用信息）</li></ul></li></ol><ul><li>事务管理代理（<code>Spring</code>声明式事务）<ul><li>缓存代理（<code>MyBatis</code>二级缓存机制）</li></ul></li></ul><ol start="2"><li><p><strong>适配代理</strong>‌：解决接口兼容性问题： </p><ul><li>API版本适配（如新旧支付接口兼容）</li><li>协议转换（如<code>HTTP</code>转<code>WebSocket</code>）</li><li>数据格式转换（<code>XML</code>与<code>JSON</code>互转）</li></ul></li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>代理模式</strong> 实际上在平时中也运用的非常广泛，最经典的例子就是<code>房东委托中介代理出租房子</code>的案例。</p><ol><li><p>创建一个Subject类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 活动类，目的是出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span>; <span class="comment">// 租房接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个房东角色，现在活动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 房东</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseOwner</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">// 实现租房方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东成功出租了房子...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个中介代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中介代理类</span></span><br><span class="line"><span class="comment">// 一般情况下我们不能直接联系到房东，所以需要提供一个代理类，即中介类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseProxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HouseOwner</span> <span class="variable">houseOwner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseOwner</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介收取代理费，帮助房东出租房子...&quot;</span>);</span><br><span class="line">        houseOwner.rentHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟用户找中介租房子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span>&#123;</span><br><span class="line">    <span class="type">HouseProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseProxy</span>();</span><br><span class="line">    proxy.rentHouse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><p>策略模式的核心应用场景聚焦于需要<strong>动态选择算法或业务规则</strong>的场景‌，主要适用于<strong>算法切换、支付方式选择、会员折扣系统、订单处理逻辑和游戏AI行为</strong>等需要灵活扩展的业务场景。‌‌</p><p><strong>策略模式的典型应用场景</strong>‌：策略模式通过<strong>封装算法族并实现运行时动态切换</strong>，有效解决了复杂条件判断和频繁扩展需求的问题‌。以下是其核心应用领域： </p><ol><li><p>‌<strong>算法动态切换场景</strong>‌</p><p>排序算法选择（快速排序、归并排序）。‌‌</p><p>文件压缩格式切换（<code>ZIP</code>、<code>RAR</code>、<code>7z</code>）。‌‌</p><p>加密算法适配（<code>AES</code>、<code>RSA</code>、<code>MD5</code>）。‌‌</p><p>日志输出方式配置（文件存储、网络传输、控制台输出）。‌‌</p></li><li><p><strong>电商领域高频应用</strong>‌</p><p>支付方式选择（信用卡、支付宝、微信支付），通过策略接口统一调用不同支付通道。‌‌‌‌</p><p>折扣策略配置（满减、折扣券、会员价），支持促销活动的快速迭代。‌‌</p><p>订单类型处理（普通订单、团购订单、促销订单），替代多层级if-else判断逻辑。‌‌</p></li><li><p><strong>系统行为动态调整</strong>‌</p><p>游戏AI策略切换（进攻型、防御型、逃跑型行为模式）。‌‌</p><p>交通出行方式计算（飞机、火车、自驾的成本与时间策略）。‌‌</p><p>影院售票系统（学生折扣、儿童减免、VIP积分等差异化策略）。‌‌</p></li><li><p><strong>策略模式的使用优势</strong></p><p><strong>扩展性</strong>‌：新增策略只需实现接口，无需修改上下文逻辑。‌‌</p><p><strong>解耦性</strong>‌：算法实现与使用逻辑分离，符合开闭原则。‌‌</p><p><strong>可维护性</strong>‌：消除大规模条件判断，代码结构更清晰。‌‌</p></li></ol><h3 id="基本实现步骤"><a href="#基本实现步骤" class="headerlink" title="基本实现步骤"></a>基本实现步骤</h3><p><strong>场景</strong>: 商场搞活动，根据客户购买商品的金额，收费时给与不同的打折，比如，购买 <strong>金额&gt;=2000</strong> 的打八折(0.8)，金额 <strong>500 ~ 1000</strong> 的，打九折(0.9)，购买金额 <strong>0 ~ 500</strong> 的九五折(0.95)，根据不同的金额走不同计算策略逻辑。</p><ol><li><p>定义一个<code>Strategy接口</code>来表示一个策略</p><p>其中<code>strategy</code>方法返回当前策略的唯一标识，<code>algorithm</code>则是该策略的具体执行的计算逻辑。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    String <span class="title function_">strategy</span><span class="params">()</span>; <span class="comment">// 采用策略</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span>; <span class="comment">// 计算方法逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义几个是<code>Strategy接口</code>的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">strategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StrategySelector.strategyA.getStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;process with strategyA...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">strategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StrategySelector.strategyB.getStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;process with strategyB...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">strategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StrategySelector.strategyC.getStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;process with strategyC...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义策略选择枚举 <strong>StrategySelector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">StrategySelector</span> &#123;</span><br><span class="line">    strategyA(<span class="number">1</span>,<span class="string">&quot;strategyA&quot;</span>),</span><br><span class="line">    strategyB(<span class="number">2</span>,<span class="string">&quot;strategyB&quot;</span>),</span><br><span class="line">    strategyC(<span class="number">3</span>,<span class="string">&quot;strategyC&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String strategy;</span><br><span class="line"></span><br><span class="line">    StrategySelector(Integer code, String strategy) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个<code>StrategyRunner接口</code>用来表示策略的调度器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StrategyRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String strategy)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>execute</code>方法内部通过判断<code>strategy</code>的值来决定具体执行哪一个策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyRunnerImpl</span> <span class="keyword">implements</span> <span class="title class_">StrategyRunner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Strategy&gt; STRATEGIES = </span><br><span class="line">        Arrays.asList(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>(), <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>(), <span class="keyword">new</span> <span class="title class_">ConcreteStrategyC</span>());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Strategy&gt; STRATEGY_MAP = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        STRATEGY_MAP = STRATEGIES.stream().collect(Collectors.toMap(Strategy::strategy, s -&gt; s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String strategy)</span> &#123;</span><br><span class="line">        STRATEGY_MAP.get(strategy).algorithm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>StrategyRunnerImpl</code>内部，定义了一个<code>STRATEGIES</code>列表来保存所有<code>Strategy</code>实现类的实例，以及一个叫做<code>STRATEGY_MAP</code>的Map来保存<code>strategy</code>和<code>Strategy实例</code>之间的对应关系，<code>static块</code>中的代码用于从<code>STRATEGIES</code>列表构造<code>STRATEGY_MAP</code>。这样，在execute方法中就可以很方便地获取到指定 strategy 的 Strategy 实例。</p></li></ol><h3 id="实现并运用策略模式"><a href="#实现并运用策略模式" class="headerlink" title="实现并运用策略模式"></a>实现并运用策略模式</h3><ol><li><p>定义一个<code>Strategy接口</code>来表示一个策略，再定义几个是<code>Strategy接口</code>的实现类，同上【1 - 2】步骤，注意需要在自定义<code>Strategy实现类</code>上标注<code>@Component</code>注解以将其注册进容器。</p></li><li><p>定义一个<code>StrategyConfig</code>配置类，用于向容器注入一个<code>StrategyRunner</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StrategyRunner <span class="title function_">runner</span><span class="params">(List&lt;Strategy&gt; strategies)</span> &#123;</span><br><span class="line">        Map&lt;String, Strategy&gt; strategyMap = </span><br><span class="line">            strategies.stream().collect(Collectors.toMap(Strategy::strategy, s -&gt; s));</span><br><span class="line">        <span class="keyword">return</span> flag -&gt; strategyMap.get(flag).algorithm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>strategyRunner</code>方法的实现，逻辑与<code>StrategyRunnerImpl</code>几乎完全相同，也是根据一个<code>List&lt;Strategy&gt;</code>来构造一个<code>Map&lt;String, Strategy&gt;</code>。不过，这里的<code>strategies列表</code>是通过方法参数传进来的。由于<code>strategyRunner</code>标注了<code>Bean注解</code>，因此参数上的<code>List&lt;Strategy&gt;</code>实际上是在Spring Boot初始化过程中<strong>从容器获取的</strong>，所以我们之前向容器中注册的那两个实现类会在这里被注入。 这样就不必关注系统中<code>Strategy实现类</code>的具体个数，因为Spring Boot的自动配置会帮我们自动发现所有实现类。</p></li><li><p>在任何需要的地方注入<code>StrategyRunner</code>，直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/designPatterns&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesignPatternController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StrategyRunner strategyRunner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/algorithm&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="meta">@RequestParam(&quot;strategy&quot;)</span> String strategy)</span> &#123;</span><br><span class="line">        strategyRunner.execute(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问接口，控制台输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process with strategyA...</span><br></pre></td></tr></table></figure></li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><strong><code>观察者模式Observer</code></strong> 定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><p><em>初识观察者模式：报社+订阅者 = 观察者模式。</em></p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>观察者模式定义了对象之间一对多的关系。</li><li>主题（可观察者）用一个共同的接口来更新观察者。</li><li>观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li><li>使用次模式时，你可以从被观察者处推或拉数据（推的方式被认为是更正确的）。</li><li>有多个观察者时，不可以依赖特定的通知次序。</li><li><code>java</code>中有多种观察者模式的实现，包括了通用的<code>java.util.Observable</code>，不过需要注意<code>Observable</code>实现上所带来的问题，有必要的话，可以实现自己的<code>Observable</code>。</li><li><code>Spring</code>也大量使用观察者模，比如<code>ListenrEvent</code>消息订阅与发布;</li></ul><h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><p><strong>GUI 事件处理</strong><br><code>场景</code>：用户界面组件（如按钮、输入框）的状态变化需要触发多个事件监听器<br><code>案例</code>：</p><ul><li><p>点击按钮后，触发日志记录、界面更新、数据提交等多个操作</p></li><li><p>输入框内容变化时，实时校验输入合法性并更新提示信息</p></li><li><p>框架应用：<code>Java Swing</code>、Android 的 <code>OnClickListener</code>、JavaScript 的<code>addEventListener</code></p></li></ul></li><li><p><strong>实时数据同步</strong><br><strong>场景</strong>：数据源的变更需要实时同步到多个客户端或组件。<strong>案例</strong>：</p><ul><li><strong>股票行情系统</strong>：股价变动时，所有关注的投资者界面自动刷新</li><li><strong>在线协作工具</strong>（如 <code>Google Docs</code>）：一个用户编辑内容，其他用户的视图实时更新</li><li><strong>前端框架</strong>（如 <code>Vue、React</code>）的数据绑定：数据变化驱动视图渲染</li><li>一个主界面由几个子界面垂直布局组成， 数据源变更，子界面数据将实时变化（页面还有几个一级标题页面，为了解耦和代码管理按照标题差分类结构）</li></ul></li><li><p><strong>状态监控与报警</strong><br><strong>场景</strong>：监控系统状态变化，并触发相关响应（如日志、报警、资源调整）。<strong>案例</strong>：</p><ul><li><p>服务器 CPU 使用率超过阈值时，触发邮件报警、记录日志、自动扩容</p></li><li><p>物联网设备（如传感器）数据异常时，通知用户和管理系统</p></li></ul></li><li><p><strong>游戏开发中的事件系统</strong><br><strong>场景</strong>：游戏内事件（如角色死亡、任务完成）需要触发多模块响应。<strong>案例</strong>：</p><ul><li><p>玩家生命值降为 0 时，触发 UI 更新死亡动画、保存进度、播放音效</p></li><li><p><strong>成就系统</strong>：当玩家达成特定条件（如击杀 100 个敌人），解锁成就并推送通知</p></li></ul></li><li><p><strong>配置或参数动态更新</strong><br><strong>场景</strong>：系统配置变更后，相关组件需动态调整行为，无需重启。<strong>案例</strong>：</p><ul><li><p>修改系统主题颜色，所有界面组件自动切换配色</p></li><li><p>动态调整日志级别，实时生效</p></li></ul></li><li><p><strong>分布式系统中的一致性保证</strong><br><strong>场景</strong>：多个服务需要根据核心服务状态变化保持一致性。<strong>案例</strong>：</p><ul><li><p>电商系统中，订单状态变为“已支付”时，通知库存服务扣减库存、物流服务生成运单</p></li><li><p><strong>分布式缓存失效</strong>：当缓存数据更新，通知所有节点清除旧缓存</p></li></ul></li></ol><p><strong>场景</strong>：以气象站为例，天气信息表示被观察者，天气布告板表示订阅者和观察者，当天气发生变化（被观察者）时，会通过<code>notifyObserver</code>通知所有观察者，并调用他们的控制方法处理数据。</p><p>一个<code>WeatherData</code>对象负责追踪目前的天气状况（温度，湿度，气压）。希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。当<code>WeatherObject</code>对象获得最新的测量数据时，三种布告板必须实时更新。</p><h3 id="气象监测应用的对象分析"><a href="#气象监测应用的对象分析" class="headerlink" title="气象监测应用的对象分析"></a>气象监测应用的对象分析</h3><p>此系统中的三个部分是：</p><ul><li>气象站（获取实际气象数据的物理装置）</li><li><code>WeatherData</code>对象（最总来自气象站的数据，并更新布告板）</li><li>布告板（显示目前天气状况给用户看）。</li></ul><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li><p><strong>实现气象站</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主题接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;     <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;     <span class="comment">// 删除观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;                  <span class="comment">// 当主题状态改变时，这个方法会被调用，以通知所有的观察者</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当气象观测值改变时，主题会把这些状态值当作方法的参数，传送给观察者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当布告板需要显示时，调用此方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在<code>WeatherData</code>中实现主题接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer observer:observers)&#123;</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当从气象站得到更新观测值时，通知观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measurementsChanged</span><span class="params">()</span>&#123;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// WeatherData的其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>建立布告板</strong>（其中的一个布告板）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>, DisplayElement &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;        <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;            <span class="comment">// 湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;            <span class="comment">// 气压</span></span><br><span class="line">    <span class="keyword">private</span> Subject weatherData;     <span class="comment">// 天气主题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionDisplay</span><span class="params">(Subject weatherData)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里气象台更新的天气数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temp;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure</span><br><span class="line">        <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>利用内置的支持重写<code>WeatherData</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherDataTWO</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherDataTWO</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measurementsChanged</span><span class="params">()</span>&#123;</span><br><span class="line">        setChanged();          <span class="comment">// 在调用 notifyObservers()之前，要先调用 setChanged() 来指示状态已经改变</span></span><br><span class="line">        notifyObservers();     <span class="comment">// 没调用 notifyObservers 传送数据对象，表示采用的做法是拉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature,<span class="type">float</span> humidity,<span class="type">float</span> pressure)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getHumidity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPressure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>利用内置观察者重写布告板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">java</span>.util.Observer, DisplayElement &#123;</span><br><span class="line"></span><br><span class="line">    Observable observable;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionsDisplay</span><span class="params">(Observable observable)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.observable = observable;</span><br><span class="line">        observable.addObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;这里气象台更新的天气数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> WeatherDataTWO) &#123;</span><br><span class="line">            <span class="type">WeatherDataTWO</span> <span class="variable">weatherDataTWO</span> <span class="operator">=</span> (WeatherDataTWO) o;</span><br><span class="line">            <span class="built_in">this</span>.temperature = weatherDataTWO.getTemperature();</span><br><span class="line">            <span class="built_in">this</span>.humidity = weatherDataTWO.getHumidity();</span><br><span class="line">            display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><strong><code>模板方法（Template Method）</code></strong> 是一种行为设计模式。模板方法设计模式用于创建方法存根并将某些实现步骤推迟到子类。</p><p>模板方法定义了执行算法的步骤，它可以提供可能对所有或者部分子类通用的默认实现，下面通过一个简单的例子来理解这个模式。</p><h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><p><strong>多个类有相似的算法结构</strong></p><p>多个类具有相似的行为或算法，只是某些步骤的实现细节不同，可以使用模板方法模式将这些相似的算法提取到一个抽象类中，<strong>将不同的步骤定义为抽象方法</strong>，由子类去实现。例如，在图形绘制程序中，绘制不同类型的图形（如圆形、矩形等）可能有相似的步骤，如<strong>初始化绘制环境、绘制图形轮廓、填充图形</strong>等，但具体的绘制轮廓和填充方式不同。</p></li><li><p><strong>控制子类的扩展</strong></p><p>模板方法模式允许在不改变算法结构的情况下，通过子类扩展来改变算法的某些步骤。例如，在一个订单处理系统中，订单的处理流程可能包括<strong>接收订单、验证订单、处理支付、发货</strong>等步骤，其中处理支付的步骤可能会因支付方式的不同而有所差异。便可将订单处理流程定义在抽象类中，将支付处理步骤定义为抽象方法，由不同的子类实现不同的支付方式，同时保证订单处理基本流程不变。</p></li><li><p><strong>框架设计</strong></p><p>框架提供了一个算法的骨架，开发者可通过继承框架中的抽象类并实现抽象方法来定制自己的功能。例如，在Java的<code>JDBC</code>框架中，<code>Statement</code>接口及其子类就体现了模板方法模式的思想。<code>Statement</code>接口定义了一系列执行SQL语句的方法，如<code>executeQuery()</code>、<code>executeUpdate()</code>等，这些方法定义了执行SQL语句的基本流程，而具体的数据库操作由不同的数据库驱动程序实现。</p></li><li><p><strong>一次性实现不变部分，避免代码重复</strong></p><p>当算法中的某些步骤是不变的，而其他步骤可能会变化时，可将不变的步骤在抽象类的模板方法中实现，<strong>变化的步骤定义为抽象方法由子类实现</strong>，这样避免了在多个子类中重复编写不变的代码。例如，在一个日志记录系统中，日志的格式和输出方式可能是不变的，但日志的内容可能会因不同的业务场景而不同，可使用模板方法模式将日志的格式和输出方式在抽象类中实现，<strong>将日志内容的生成定义为抽象方法</strong>，由具体的日志记录类实现。</p></li></ol><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>场景</strong>：假设想提供一种算法了解房子，建造房屋需要执行的步骤是：建造地基-&gt;建造支柱-&gt;建造墙壁和窗户。重点是不能改变执行的顺序，在这种情况下，可以创建一个模板方法，它将使用不同的方法来建造房子，现在盖房子的地基对于所有类型的房子都是一样的，无论是木房、玻璃房子还是混泥土房。所以可以为此提供基础实现，如果子类想要覆盖这个方法，他们可以自己选择，但大多数情况下，所有类型的房屋都很常见。为了确保子类不覆盖模板方法，应该将其设为最终方法。</p><p><strong>模板方法抽象类</strong>：若希望某些方法由子类实现，必须将基类设为抽象类。</p><ol><li><p><strong>定义抽象类<code>HouseTemplate</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HouseTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// buildHouse()是模板方法，定义个执行几个步骤的执行顺序</span></span><br><span class="line">    <span class="comment">// template method, final so subclasses can&#x27;t override final修饰，子类不能重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">buildHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        buildFoundation();     <span class="comment">// 建造地基</span></span><br><span class="line">        buildPillars();     <span class="comment">// 建造柱子</span></span><br><span class="line">        buildWalls();         <span class="comment">// 建造墙壁</span></span><br><span class="line">        buildWindows();     <span class="comment">// 建造窗户</span></span><br><span class="line">        System.out.println(<span class="string">&quot;House is built successfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Building foundation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildFoundation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Building foundation with cement, iron rods and sand&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods to be implemented by subclasses</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPillars</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default implementation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildWindows</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Building Glass Windows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>WoodenHouse</code>，<code>GlassHouse</code>，<code>ConcreteHouse</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 木房 WoodenHouse</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WoodenHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseTemplate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPillars</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Building Pillars With Wood coating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Building Wooden Walls...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玻璃房 GlassHouse</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlassHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseTemplate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPillars</span><span class="params">()</span> &#123;</span><br><span class="line">       log.info(<span class="string">&quot;Building Pillars With Glass coating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Building Glass Walls...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混泥土房屋 ConcreteHouse</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseTemplate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPillars</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Building Pillars With Concrete coating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Building Concrete Walls...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>HousingClient</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HousingClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HouseTemplate</span> <span class="variable">houseBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WoodenHouse</span>();</span><br><span class="line">        houseBuilder.buildHouse();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        houseBuilder = <span class="keyword">new</span> <span class="title class_">GlassHouse</span>();</span><br><span class="line">        houseBuilder.buildHouse();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        houseBuilder = <span class="keyword">new</span> <span class="title class_">ConcreteHouse</span>();</span><br><span class="line">        houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Building foundation with cement,iron rods and sand</span><br><span class="line">Building Pillars With Wood coating...</span><br><span class="line">Building Wooden Walls...</span><br><span class="line">Building Glass Windows</span><br><span class="line">House is built successfully</span><br><span class="line">--------------</span><br><span class="line">Building foundation with cement,iron rods and sand</span><br><span class="line">Building Pillars With Glass coating...</span><br><span class="line">Building Glass Walls...</span><br><span class="line">Building Glass Windows</span><br><span class="line">House is built successfully</span><br><span class="line">--------------</span><br><span class="line">Building foundation with cement,iron rods and sand</span><br><span class="line">Building Pillars With Concrete coating...</span><br><span class="line">Building Concrete Walls...</span><br><span class="line">Building Glass Windows</span><br><span class="line">House is built successfully</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 &lt;em&gt;Gang of Four&lt;/em&gt; (&lt;em&gt;GoF&lt;/em&gt;) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>阿里规约</title>
    <link href="https://southernfish.github.io/2025/07/27/java/java-coding-guidelines/"/>
    <id>https://southernfish.github.io/2025/07/27/java/java-coding-guidelines/</id>
    <published>2025-07-27T06:26:36.000Z</published>
    <updated>2025-07-28T10:27:55.453Z</updated>
    
    <content type="html"><![CDATA[<p>阿里巴巴 的代码规范（ 阿里规约 ）主要包含 Java 、 C++ 、 Python 等编程语言的编码规范。最新版本可通过其 GitHub 仓库获取。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/134039365">【阿里规约】阿里开发手册解读——命名规范篇</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/134273900">【阿里规约】阿里开发手册解读——代码格式篇</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/135678947">【阿里规约】阿里开发手册解读——数据库和ORM篇</a></p></blockquote><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><ul><li><p><strong>统一小写：</strong>例如商品库存包com.example.product.stock，而不是com.example.productStock</p></li><li><p><strong>分隔符间单词必须单语义：</strong>例如商品库存包com.example.product.stock，而不是com.example.product_stock、com.example.product-stock</p></li></ul><blockquote><p><strong>参考</strong>：</p><p>【强制】 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 <code>单数</code> 形式，但是类名如果有复数含义，类名可以使用复数形式。<br><strong>正例</strong>： 应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils（此规则参考 spring 的框架结构）</p></blockquote><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><h3 id="普通类和方法"><a href="#普通类和方法" class="headerlink" title="普通类和方法"></a>普通类和方法</h3><ul><li>驼峰命名：例如UserService，而不是User_service。</li><li>禁止拼音英文混用；</li><li>禁止下划线、美元符号起始。</li><li><strong>可读性比长度重要：</strong>命名尽可能短，但<em>望文生义</em>更重要<ul><li><strong>可读性高（推荐）：</strong>下面这些类既保证了望文生义，又保证了缩写<ul><li>商品描述类：DescriptionOfProduct 缩写为 ProductDesc</li><li>应用程序配置类：ApplicationConfiguration 缩写为 AppConfig</li><li>客户信息类：CustomerInformation 缩写为 CustInfo。</li></ul></li><li><strong>可读性低（不推荐）</strong>：<ul><li>AbstractClass缩写命名成 AbsClass；</li><li>PurchaseProduct类缩写成PurProduct;</li></ul></li></ul></li></ul><blockquote><p><strong>参考：</strong></p><ul><li><p>【强制】 代码中的命名均不能以 下划线或美元符号 开始，也不能以 下划线或美元符号 结束。</p><p>反例： <em>name / <em><em>name / $name / name</em> / name$ / name</em></em></p></li><li><p>【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</p><p>说明： 正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，纯拼音命名方式更要避免采用。</p><p>正例： renminbi / alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。</p><p>反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</p></li><li><p>【强制】 方法名、参数名、成员变量、局部变量都统一使用 <code>lowerCamelCase</code> 风格，必须遵从驼峰形式。</p><p>正例： localValue / getHttpMessage() / inputUserId</p></li><li><p>【强制】 杜绝完全不规范的缩写，避免望文不知义。</p><p>反例： AbstractClass缩写命名成 AbsClass；condition缩写命名成 condi，此类随意缩写严重降低了代码的可阅读性。</p></li><li><p>【推荐】 为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。</p><p>正例： 在 JDK 中，表达原子更新的类名为：AtomicReferenceFieldUpdater。</p><p>反例： int a 的随意命名方式。</p></li><li><p>【推荐】 在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。</p><p>正例： startTime / workQueue / nameList / TERMINATED_THREAD_COUNT</p><p>反例： startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD</p></li></ul></blockquote><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p><strong>命名：</strong>待测类名+Test 。</p><p><strong>举例：</strong>用户测试类UserServiceTest，而不是TestUserService。</p><blockquote><p><strong>参考：</strong></p><p>【强制】 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；</p><p>​        测试类命名以它要测试的类的名称开始，以 Test 结尾</p></blockquote><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><strong>命名：</strong> Abstract+自定义类名。</p><p><strong>举例：</strong>抽象支付方式类AbstractPaymentMethod/BasePaymentMethod，而不是AbstractPayment。</p><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p><strong>命名：</strong>自定义异常名+Exception。</p><p>例如商品找不到类ProductNotFoundException，而不是ProductNotFound。</p><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ul><li><strong>类名：</strong>自定义类名+Enum。 例如ProcessStatusEnum</li><li><strong>成员名：</strong>跟常量一样</li><li><strong>纯大写+下划线：</strong>例如最大库存量MAX_STOCK_COUNT。</li><li><strong>可读性比长度重要：</strong>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。例如最大库存量MAX_STOCK_COUNT而不是MAX_COUNT。</li></ul><blockquote><p><strong>枚举类和常量类区别：</strong></p><p><strong>相同点：</strong>在Java中，枚举和常量都用于表示一组固定的值，但它们适用的场景有所不同。</p><p><strong>不同点：</strong></p><ul><li><strong>枚举（Enum）</strong>适用于表示<strong>一组有限的可能取值</strong>，这些取值在程序中某个上下文中具有特殊意义。例如，表示一周的星期几或某个颜色的枚举类型。枚举类型可通过限定的值范围提供更好的类型安全性，并且可使用switch语句进行更清晰的代码编写。</li><li><strong>常量（Constant）</strong>适用于表示在程序中经常使用的不可变的值。常量一般定义为 final 类型，并且通常用于表示某个固定的数值或者字符串常量。常量的值在程序中是不可修改的，可以通过常量名直接使用，提高代码的可读性和可维护性，但是可能会降低类型安全性和表达能力。</li></ul><p>总结来说，枚举适用于表示一组有限的、具有特殊意义的取值，常量适用于表示程序中经常使用的不可变的值。</p><p>【参考】 枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br>说明： 枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。<br>正例： 枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON</p></blockquote><h3 id="接口和实现类"><a href="#接口和实现类" class="headerlink" title="接口和实现类"></a>接口和实现类</h3><ul><li>service和dao实现类以Impl结尾。注意不要用Imp结尾。例如UserServiceImpl而不是UserServiceImp</li><li>能力型接口以-able结尾。如异常根类Throwable是可抛出的，实现类Exception和Error都可抛出。如Drawable接口和Circle实现类。</li></ul><blockquote><p><strong>参考</strong>：接口和实现类的命名有两套规则</p><ol><li><p>【强制】 对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用Impl 的后缀与接口区别。</p><p>正例： CacheServiceImpl 实现 CacheService 接口。</p></li><li><p>【推荐】 如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）。</p><p>正例： AbstractTranslator 实现 Translatable 接口。</p></li></ol></blockquote><h3 id="PO、DTO、VO"><a href="#PO、DTO、VO" class="headerlink" title="PO、DTO、VO"></a>PO、DTO、VO</h3><ul><li><strong>DO / BO / DTO / VO / AO / PO / UID 要大写，而非驼峰：</strong>例如UserDO，而不是UserDo。例如serialVersionUID，而不是serialVersionUid。</li><li><strong>禁止POJO后缀：</strong>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li></ul><blockquote><p><strong>扩展</strong>：PO、DTO、VO</p><ol><li>数据对象：xxxDO，xxx 即为数据表名。</li><li>DTO数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li><li>VO展示对象：xxxVO，xxx 一般为网页名称。</li><li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li></ol><p><strong>参考</strong>：<br>【强制】 类名使用 UpperCamelCase 风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID 等。<br>正例： JavaServerlessPlatform / UserDO / XmlService / TcpUdpDeal / TaPromotion<br>反例： javaserverlessplatform / UserDo / XMLService / TCPUDPDeal / TAPromotion<br>【参考】 各层命名规约：<br>A) Service/DAO 层方法命名规约</p><ol><li>获取单个对象的方法用 get 做前缀。</li><li>获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。</li><li>获取统计值的方法用 count 做前缀。</li><li>插入的方法用 save/insert 做前缀。</li><li>删除的方法用 remove/delete 做前缀。</li><li>修改的方法用 update 做前缀。</li></ol></blockquote><h3 id="用到设计模式的类"><a href="#用到设计模式的类" class="headerlink" title="用到设计模式的类"></a>用到设计模式的类</h3><blockquote><p>案例参考文章：<a href="/2025/06/19/java/java-design-patterns/">设计模式</a></p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>抽象类名以Abstarct/Base为前缀</li><li>用到设计模式时要在命名中进行体现。</li></ul><blockquote><p>参考：<br>【推荐】 如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。<br>说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。<br>正例： public class OrderFactory;   public class LoginProxy;    public class ResourceObserver;</p></blockquote><h4 id="案例一：工厂设计模式采购披萨"><a href="#案例一：工厂设计模式采购披萨" class="headerlink" title="案例一：工厂设计模式采购披萨"></a>案例一：工厂设计模式采购披萨</h4><p>采购披萨工厂类：利用工厂方法模式创建披萨时，可以把抽象工厂类命名为AbstractOrderPizzaFactory类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂类，订购披萨类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOrderPizzaFactory</span>&#123;</span><br><span class="line"><span class="comment">// 构造方法不断根据用户输入披萨类型，调用创建披萨对象的抽象方法，实现加工披萨。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            pizza = createPizza(getType());</span><br><span class="line">            <span class="keyword">if</span> (pizza == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Failed to Order Pizza&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类，订购伦敦披萨类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">AbstractOrderPizzaFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (orderType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">LDCheesePizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pepper&quot;</span>: pizza = <span class="keyword">new</span> <span class="title class_">LDPepperPizza</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="案例二：-观察者设计模式订阅天气"><a href="#案例二：-观察者设计模式订阅天气" class="headerlink" title="案例二： 观察者设计模式订阅天气"></a>案例二： 观察者设计模式订阅天气</h4><p>天气局接口和观察者类：WeatherSubject和天气观察者接口WeatherObserver</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><ul><li>驼峰命名：例如商品价格命名pruductPrice，而不是pruduct_price。</li><li>禁止拼音英文混用；</li><li>禁止下划线、美元符号起始。</li><li><strong>可读性比长度重要：</strong>命名尽可能短，但“望文生义”更重要<ul><li><strong>可读性高（推荐）</strong>：下面这些类<ul><li>最大值：maximumValue 缩写为 maxValue</li><li>项目数量：numberOfItems 缩写为 numItems</li><li>初始化计数器：initializeCounter 缩写为 initCounter</li></ul></li><li><strong>可读性低（不推荐）</strong>：<ul><li>数量：count缩写为cnt</li><li>值：value缩写成val</li><li>序号：index缩写成i</li></ul></li></ul></li><li><strong>类型名词放词尾：</strong>词尾是类型，让人能一眼看出这个变量是干什么的。例如：<ul><li>开始时间：startTime而不是startedAt。</li><li>工作队列：workQueue而不是QueueOfWork。</li><li>名字列表：nameList而不是listName。因为它是个列表。</li><li>最大线程数：MAX_THREAD_COUNT而不是COUNT_MAX_THREAD 。它是数量而不是线程。</li></ul></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><p>中括号要直接跟在类型后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：中括号放在变量名后面，注释放在右边</span></span><br><span class="line">String args[]; </span><br><span class="line"><span class="comment">// 正确示例：中括号直接跟在类型后面，注释放在代码上面</span></span><br><span class="line">String[] args; </span><br></pre></td></tr></table></figure><blockquote><p><strong>参考：</strong></p><p>【强制】 类型与中括号紧挨相连来表示数组。</p><p>正例： 定义整形数组 int[] arrayDemo;</p><p>反例： 在 main 参数中，使用 String args[]来定义</p></blockquote><h3 id="布尔型变量"><a href="#布尔型变量" class="headerlink" title="布尔型变量"></a><strong>布尔型变量</strong></h3><p>实体类（PO类）里布尔型变量不能加is前缀，否则部分框架解析会引起序列化错误。同时MySQL表达“是否”的字段可以用is_xxx，只需<code>&lt;resultMap&gt;</code>设置从 is_xxx 到 xxx 的映射关系即可。<strong>示例：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">// 逻辑删除字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> deleted;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 其他属性、构造函数和方法</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeleted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deleted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDeleted</span><span class="params">(<span class="type">boolean</span> deleted)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.deleted = deleted;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么强制 boolean 类型变量不能使用 is 开头？</strong></p><p>为了防止序列号失败。</p><ul><li><strong>lombok序列号失败</strong>：javaBeans规范boolean变量的getter方法是isXXX()，其他变量的getter方法是getXXX()。lombok遵循javaBeans规范，如果一个变量是boolean isSuccess;在注解@Data或@Getter生成getter方法的时候，它会生成isSuccess()方法，而不是isIsSucess()方法。这也是lombok的一个大坑。</li><li><strong>rpc框架序列号失败</strong>：在一些rpc框架里面，当反向解析读取到isSuccess()方法的时候，rpc框架会“以为”其对应的属性值是success，而实际上其对应的属性值是isSuccess，导致属性值获取不到，从而抛出异常。</li></ul><p>参考：<br>【强制】 POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。<br>说明： 在 MySQL 规约中的建表约定第一条，表达是与否的值采用 is_xxx 的命名方式，所以，需要在<code>&lt;resultMap&gt;</code> 设置从 is_xxx 到 xxx 的映射关系。<br>反例： 定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，RPC 框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</p></blockquote><h3 id="父子类变量"><a href="#父子类变量" class="headerlink" title="父子类变量"></a>父子类变量</h3><p><strong>父子类变量命名：</strong>避免同名变量。例如父类有个name变量，子类想声明一个昵称变量，应另外声明nickname，而非再次声明name。</p><blockquote><p>参考：<br>【强制】 避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。<br>说明： 子类、父类成员变量名相同，即使是 public 类型的变量也是能够通过编译，而局部变量在同一方法内的不同代码块中同名也是合法的，但是要避免使用。对于非 setter/getter 的参数名称也要避免与成员变量名称相同。<br>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfusingName</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 非 setter/getter 的参数名称，不允许与本类成员变量同名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(String alibaba)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">531</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 在同一方法体中，不允许与其它代码块中的 money 命名相同</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">615</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">ConfusingName</span> &#123;</span><br><span class="line">    <span class="comment">// 不允许与父类的成员变量名称相同</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sonAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>避免同一个方法的多个代码块中声明同名局部变量。例如下面方法的money变量不符合规范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(String alibaba)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">531</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 在同一方法体中，不允许与其它代码块中的 money 命名相同</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">615</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="普通常量"><a href="#普通常量" class="headerlink" title="普通常量"></a>普通常量</h3><ul><li><p><strong>纯大写+下划线：</strong>例如最大库存量MAX_STOCK_COUNT。</p></li><li><p><strong>可读性比长度重要：</strong>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。例如最大库存量MAX_STOCK_COUNT而不是MAX_COUNT。</p></li><li><p><strong>常量类细化</strong>：不要一个总的常量类维护所有常量，要按功能创建粒度小的常量类。例如电商平台商品模块不应该一个ProductStatusConstants维护所有商品常量，而应该细化成商品类型常量类ProductTypeConstants、商品价格范围常量类PriceRangeConstants、商品属性相关常量类ProductAttributeConstants等。</p></li><li><p><strong>枚举类</strong>：变量值只在固定几个值内变化时用枚举类。例如季节Season变量只会有春夏秋冬四种类型，可以定义成季节枚举类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    SPRING(<span class="number">1</span>), SUMMER(<span class="number">2</span>), AUTUMN(<span class="number">3</span>), WINTER(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seq;</span><br><span class="line">    </span><br><span class="line">    SeasonEnum(<span class="type">int</span> seq) &#123;</span><br><span class="line">        <span class="built_in">this</span>.seq = seq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSeq</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>参考</strong>：<br>【强制】 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>正例： MAX_STOCK_COUNT / CACHE_EXPIRED_TIME<br>反例： MAX_COUNT / EXPIRED_TIME<br>【推荐】 不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。<br>说明： 大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护。<br>正例： 缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。<br>【推荐】 如果变量值仅在一个固定范围内变化用 enum 类型来定义。<br>说明： 如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。</p></blockquote><h3 id="Long常量"><a href="#Long常量" class="headerlink" title="Long常量"></a>Long常量</h3><p><strong>大写L：</strong>以便于区分“L”和数字“1”。例如Long a=1L，而不是Long a=1l。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：</span></span><br><span class="line"><span class="comment">// a实际上表示 Long 型的 2，但容易混淆为数字 21。</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2l</span>; </span><br><span class="line"><span class="comment">//正确示例：</span></span><br><span class="line"><span class="comment">// 使用大写 &quot;L&quot; 来明确表示 Long 型的 2。</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2L</span>; </span><br><span class="line"><span class="comment">// 使用大写 &quot;L&quot; 来明确表示 long 型的 12345。</span></span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12345L</span>; </span><br></pre></td></tr></table></figure><blockquote><p><strong>参考：</strong><br>【强制】 在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。<br>说明： Long a = 2l; 写的是数字的 21，还是 Long 型的 2。</p></blockquote><hr><h1 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h1><h2 id="编码和换行符"><a href="#编码和换行符" class="headerlink" title="编码和换行符"></a>编码和换行符</h2><p><strong>规范：</strong>代码的编码统一使用UTF-8，换行符使用 Unix 格式，不要使用 Windows 格式。</p><blockquote><p>换行符：</p><p><strong>Unix格式</strong>：在Unix、Linux以及类Unix操作系统中，使用换行符\n来表示新行，这是常用的行结束符。</p><p><strong>Windows格式</strong>：在Windows操作系统中，通常使用回车符和换行符\r\n（CR-LF，Carriage Return-Line Feed）来表示新行。</p><p><strong>IDEA编码设置UTF-8</strong>：File → Setting → Editor → File Coding → Global Encoding；Project Encoding；Default encoding for properties files → 都选择 UTF-8</p></blockquote><h2 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h2><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p><strong>规范：</strong>if/for/while/switch/do 等保留字与括号之间都必须加空格。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 情况1的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 默认情况的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Java常见保留字</strong>：</p><ol><li><strong>条件语句关键字</strong>：如if、else、switch、case、default。</li><li><strong>循环控制关键字</strong>：如for、while、do、break、continue。</li><li><strong>访问修饰符关键字</strong>：如public、private、protected。</li><li><strong>数据类型关键字</strong>：如int、double、char、boolean。</li><li><strong>类和对象关键字</strong>：如class、new、extends、implements。</li><li><strong>异常处理关键字</strong>：如try、catch、throw、throws、finally。</li></ol></blockquote><h3 id="二目、三目运算符"><a href="#二目、三目运算符" class="headerlink" title="二目、三目运算符"></a>二目、三目运算符</h3><p><strong>规范：</strong>任何二目、三目运算符的左右两边需要加一个空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a + b;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">condition</span> <span class="operator">=</span> (x &gt; y) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>java中常见的二目、三目运算符：</strong></p><ul><li><strong>二目运算符：</strong>+、-、*、/、%、=、==、&gt;=、&amp;&amp;</li><li><strong>三目运算符：</strong>?:</li></ul></blockquote><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p><strong>规范：</strong>采用 4 个空格缩进。可以使用tab快捷键直接四个空格，禁止直接使用“tab”字符 。</p><p>IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。</p><blockquote><p><strong>IDEA设置 tab</strong>：File → Setting → Editor → Code Style → Tabs and Indents → 取消勾选Use tab character → Indent 设置4</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><strong>规范：</strong>注释双斜线后紧跟一个空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例： 这是示例注释，请注意在双斜线之后有一个空格</span></span><br><span class="line"><span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="comment">//反例： 这是示例注释，请注意在双斜线之后没空格</span></span><br><span class="line"><span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p><strong>规范：</strong>强制转换时，右括号后无空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：</span></span><br><span class="line"><span class="type">long</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">1000000000000L</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> (<span class="type">int</span>)first + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 反例：</span></span><br><span class="line"><span class="type">long</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">1000000000000L</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> (<span class="type">int</span>) first + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p><strong>规范：</strong>方法参数逗号后加一个空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：下例中实参的 args1，后边必须要有一个空格。</span></span><br><span class="line">method(args1, args2, args3);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反例：下例中实参的 args1，后边没空格。</span></span><br><span class="line">method(args1,args2,args3);</span><br><span class="line">method(args1 ,args2 ,args3);</span><br></pre></td></tr></table></figure><h2 id="行数、字符数"><a href="#行数、字符数" class="headerlink" title="行数、字符数"></a>行数、字符数</h2><h3 id="单行字符数"><a href="#单行字符数" class="headerlink" title="单行字符数"></a>单行字符数</h3><p><strong>规范：</strong>单行字符数不超过120个，超过时需要换行。</p><p><strong>换行规则：</strong></p><ol><li><p>第2/3/4/..行相对第一行缩进 4 个空格。</p></li><li><p>运算符随下文一起换行。例如a + b，应该换行成a\n + b，而不是a + \nb</p></li><li><p>点符号与下文一起换行。例如dog.eat()，应该换行成dog\n.eat()，而不是dog.\neat()</p></li><li><p>方法的多个参数换行时，逗号不与下文一起换行。例如sum (1,2,3)，应该换行成sum (1,2,\n3)，而不是sum (1,2\n,3)</p></li><li><p>在括号前不换行。例如fun (a)，应该换行成\nfun (a)，而不是fun \n(a)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); </span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行</span></span><br><span class="line">sb.append(<span class="string">&quot;Jack&quot;</span>).append(<span class="string">&quot;Ma&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反例：</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); </span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，不要在括号前换行</span></span><br><span class="line">sb.append(<span class="string">&quot;Jack&quot;</span>).append(<span class="string">&quot;Ma&quot;</span>)...append </span><br><span class="line">(<span class="string">&quot;alibaba&quot;</span>); </span><br><span class="line"><span class="comment">// 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行</span></span><br><span class="line">method(args1, args2, args3, ... </span><br><span class="line">, argsX);</span><br></pre></td></tr></table></figure><h3 id="方法行数"><a href="#方法行数" class="headerlink" title="方法行数"></a>方法行数</h3><p><strong>规范：</strong>单个方法的总行数不超过 80 行。 </p><p>除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过80 行。</p><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><h3 id="大括号换行规则"><a href="#大括号换行规则" class="headerlink" title="大括号换行规则"></a>大括号换行规则</h3><p><strong>规范：</strong>大括号内为空时无需换行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 大括号内为空，则不换行</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>规范：</strong>大括号内非空时： </p><ul><li><strong>左大括号：</strong>前不换行，后换行</li><li><strong>右大括号：</strong>前换行，右换行（有else时不换行）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这个数字是正数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(number &lt; -<span class="number">3</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这个数字不是正数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="小括号规则"><a href="#小括号规则" class="headerlink" title="小括号规则"></a>小括号规则</h3><p><strong>规范：</strong>小括号内侧不隔空格，外侧隔单空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例：小括号内侧不隔空格，外侧隔单空格。</span></span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 反例：</span></span><br><span class="line"><span class="comment">// 小括号外侧没隔单空格。</span></span><br><span class="line"><span class="keyword">if</span>(a == b)</span><br><span class="line"><span class="comment">// 小括号内侧隔了空格</span></span><br><span class="line"><span class="keyword">if</span> ( a == b )</span><br></pre></td></tr></table></figure><hr><h1 id="MySQL-规约"><a href="#MySQL-规约" class="headerlink" title="MySQL 规约"></a>MySQL 规约</h1><h2 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h2><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p><strong>命名：</strong>库名与应用名称尽量一致；</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul><li><strong>大小写：</strong>MySQL表名不能有大写字母。因为MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。</li><li><strong>复数：</strong>不可使用复数。</li><li><strong>不可使用保留字：</strong>例如不能命名为add,from,set等。</li><li><strong>业务名称_表的作用：</strong>建议命名“业务名称_表的作用”，例如：<ul><li><strong>用户信息表</strong>：user_info</li><li><strong>产品信息表</strong>：product_info</li><li><strong>客户订单关联表</strong>：customer_order_relation</li></ul></li></ul><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><h4 id="基础命名规范"><a href="#基础命名规范" class="headerlink" title="基础命名规范"></a>基础命名规范</h4><ul><li><strong>命名要慎重：</strong>字段名的修改代价很大，所以必须要慎重；</li><li><strong>大小写：</strong>MySQL字段名不能有大写字母。因为MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写，大小写混用会出问题。</li><li><strong>保留字：</strong>不可使用保留字。例如不能命名为add,from,set等。</li></ul><h4 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h4><ul><li><strong>注释：</strong>字段含义改变时，及时更新注释； </li><li><strong>合理冗余：</strong>多读少写、长度短、非唯一索引的字段可以冗余，以降低连表查询的次数。</li><li><strong>关联字段类型：</strong>要关联查询的两个字段，数据类型必须一致。如果不一致会导致索引失效，索引和索引失效场景具体可以参考顶部导航文章中的“MySQL高级篇”；</li><li><strong>分库分表依据：</strong>单表数据量<strong>五百万条</strong>数据，或者容量<strong>2GB</strong>。</li><li><strong>三大必备字段：</strong>主键、创建时间、修改时间。即id, create_time（或者命名为gmt_create）, update_time（或者命名为gmt_modified）</li></ul><h3 id="布尔型字段"><a href="#布尔型字段" class="headerlink" title="布尔型字段"></a>布尔型字段</h3><ul><li><p><strong>结构：</strong>is_xxx</p></li><li><p><strong>数据类型：</strong>unsigned tinyint</p></li><li><p><strong>值：</strong>1 表示是，0 表示否</p></li><li><p><strong>对应实体类变量：</strong>虽然数据库必须命名成is_xxx，但是该表对应的实体类成员变量<strong>不能命名为isXxx</strong>，否则会导致序列号失败。故需要在 <code>resultMap</code> 中进行字段与属性之间的映射。</p></li></ul><blockquote><p><strong>《阿里规约》原文</strong>：<br>【强制】 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。<br>说明： 任何字段如果为非负数，必须是 unsigned 。<br><strong>注意</strong>： POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在&lt; resultMap &gt;设置从 is_xxx到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。<br>正例： 表达逻辑删除的字段名 is_deleted ，1 表示删除，0 表示未删除。</p></blockquote><h3 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h3><ul><li><strong>类型：</strong>decimal。主要是为了防止丢失精度。</li></ul><blockquote><p>【强制】 小数类型为 decimal ，禁止使用 float 和 double 。<br>说明： 在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</p></blockquote><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="基本规范-1"><a href="#基本规范-1" class="headerlink" title="基本规范"></a>基本规范</h4><ul><li><strong>长度几乎固定字段：</strong>使用char类型。例如电话号、身份证字段类型char(11)即可，效率要比varchar(11)更高。因为实际存储时，varchar会根据实际输入的内容占用的长度进行存储，因此占用的存储空间是实际内容长度+可变长字段长度（当varchar使用长度≤255时使用一个字节记录，长度超出255时使用二个字节记录）。</li><li><strong>超长字段：</strong>长度超过 5000的超长字段，一律使用text类型，并将该字段独立出一个表。因为text、blog类型会导致索引失效；不使用varchar是因为varchar(5000)太长，建索引后非聚簇索引树过于占用磁盘空间。</li></ul><blockquote><p>【强制】 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。<br>【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text ，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></blockquote><h4 id="varchar和char类型的区别、适用场景"><a href="#varchar和char类型的区别、适用场景" class="headerlink" title="varchar和char类型的区别、适用场景"></a>varchar和char类型的区别、适用场景</h4><p><strong>长度：</strong></p><ul><li><strong>char：</strong>固定长度的字符串</li><li><strong>varchar：</strong>可变长度的字符串。</li></ul><p><strong>存储方式：</strong></p><ul><li><strong>char：</strong>长度固定不可变，未存满的值会用空格填充到固定的长度。因此char类型字符串<strong>末尾无法存储空格</strong>，当然也不需要额外字节记录字符串长度。</li><li><strong>varchar：</strong>varchar会使用1或2个额外字节记录字符串的长度。当列最大长度是255及以下时，varchar会使用一个字节<strong>记录可变长长度</strong>，最大长度255以上会使用两个字节记录可变长长度。因为varchar有记录长度，所以字符串末尾可以存储空格。</li></ul><p><strong>存储容量：</strong></p><ul><li><strong>char：</strong>最多255个字符</li><li><strong>varchar：</strong>理论上最多65535字节，最多65532个字符（当用utf-8编码存纯英文、且该表只有这一个字段时，字符串中的字符只占1个字节，能达到65532个字符）。但实际从性能考虑，超过5000长度时就不允许再用varchar，而是使用text类型。</li></ul><blockquote><p><strong>各编码的占用长度</strong></p><ul><li>GBK编码：一个英文字符占一个字节，中文2字节，单字符最大可占用2个字节。</li><li>UTF-8编码：一个英文字符占一个字节，中文3字节，单字符最大可占用3个字节。</li><li>utf8mb4编码：一个英文字符占一个字节，中文3字节，单字符最大占4个字节（如emoji表情4字节）。</li></ul><p><strong>varchar(20) 是指字符串最大字节数是20，还是最大字符数是20</strong>？</p><p><strong>答案</strong>：取决于MySQL版本；4.0版本及以下，MySQL中varchar长度是按字节展示，如varchar(20)，指的是20字节；5.0版本及以上，MySQL中varchar长度是按字符展示。如varchar(20)，指的是20字符。</p><p><strong>为什么varchar理论上最多字符数是65532</strong>？</p><p><strong>答案：</strong>因为MySQL行默认最大65535字节，varchar还需要1或2个字节维护可变长度，1个字节标识该列是否为NULL。</p></blockquote><p><strong>性能和空间</strong>：</p><ul><li><strong>char</strong>：性能更好，每次更新时不用维护长度；但存在空间浪费的可能；</li><li><strong>varchar</strong>：性能相对差一点，因为每次更新时要维护长度。如果更新后字符串变长后，原来的数据页正好存满，则需要耗费时间处理新字符串的存储；处理方式取决于存储引擎，例如MylSAM将行拆成多个片段存储，innoDB会分裂页。</li></ul><p><strong>适用场景：</strong></p><ul><li><strong>char：</strong>存储长度几乎固定的字符串适用char类型。例如电话号、身份证字段类型char(11)即可，效率要比varchar(11)更高。因为实际存储时，varchar会根据实际输入的内容占用的长度进行存储，因此占用的存储空间是实际内容长度+可变长字段长度（当varchar使用长度≤255时使用一个字节记录，长度超出255时使用二个字节记录）。 </li><li><strong>varchar：</strong>长度几乎不固定、不超过2000字符的字符串。</li></ul><h4 id="varchar和text类型的区别、适用场景"><a href="#varchar和text类型的区别、适用场景" class="headerlink" title="varchar和text类型的区别、适用场景"></a>varchar和text类型的区别、适用场景</h4><p><strong>存储方式</strong>：</p><ul><li><strong>VARCHAR</strong>：可变长度的字符数据类型，它需要指定最大长度。实际存储时，会根据实际输入的内容占用的长度进行存储，因此占用的存储空间是实际内容长度加上一些额外的长度信息。</li><li><strong>TEXT</strong>：TEXT也用于存储可变长度的字符数据，但它可以存储非常大的文本内容，通常可以存储几GB的数据。</li></ul><p><strong>索引和查询</strong>：</p><ul><li><strong>VARCHAR</strong>：由于VARCHAR有固定的最大长度，可以建立更有效率的索引，同时在查询时会更快一些。</li><li><strong>TEXT</strong>：对于较大的文本数据，使用TEXT类型可能会导致一些查询性能上的损失，因为文本数据的处理通常会比较耗费资源。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>VARCHAR</strong>：适用于长度可预期且不会太长的文本内容，比如姓名、地址等信息。</li><li><strong>TEXT</strong>：适用于长度不确定或者非常长的文本内容，比如文章内容、评论等。</li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>VARCHAR</strong>：占用存储空间相对较小，适合存储较短字符串，支持索引，查询速度较快。但最大长度的限制可能会带来一些不便。</li><li><strong>TEXT</strong>：可以存储非常大的文本内容，并且没有固定长度的限制，适合存储较长的文本数据。但是在查询和索引上可能会稍慢，而且在某些情况下，可能会消耗更多的存储空间。</li></ul><h3 id="外键-级联"><a href="#外键-级联" class="headerlink" title="外键/级联"></a>外键/级联</h3><p><strong>禁用外键和级联。</strong>因为外键影响数据库的插入速度，每次插入时都要检查、更新外键；级联更新是强阻塞，也会影响性能。<strong>外键与级联更新适用于单机低并发</strong>的场景，不适合分布式、高并发集群的场景</p><ul><li><p><strong>级联删除：</strong>创建外键时声明级联，则引用表删除数据时，被引用表也会级联删除这条数据。示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREIGN</span> KEY (customer_id) <span class="keyword">REFERENCES</span> customers(customer_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCAD</span><br></pre></td></tr></table></figure></li><li><p><strong>级联更新：</strong>创建外键时声明级联，则引用表更新数据时，被引用表也会级联更新这条数据。示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREIGN</span> KEY (customer_id) <span class="keyword">REFERENCES</span> customers(customer_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCAD</span><br></pre></td></tr></table></figure></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="命名规范-1"><a href="#命名规范-1" class="headerlink" title="命名规范"></a>命名规范</h3><blockquote><p>【强制】 主键索引名为 pk_ 字段名；唯一索引名为 uk _字段名 ； 普通索引名则为 idx _字段名。</p><p>说明： pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p></blockquote><h3 id="创建规范"><a href="#创建规范" class="headerlink" title="创建规范"></a>创建规范</h3><ul><li><p><strong>唯一索引：</strong>唯一特性字段必须创建唯一索引。一般不需要另外创建，因为创建唯一约束的时候会自动创建唯一索引。</p></li><li><p><strong>关联查询：</strong>被驱动表优先建索引，超过三个表禁止 join。</p></li><li><p><strong>字符串：</strong></p><ul><li><strong>模糊查询：</strong>禁止左模糊、全模糊索引。因为模糊查询会使索引失效，解决方案是使用ES等搜索引擎实现页面的搜索。</li><li><strong>索引长度：</strong>必须使用前缀索引。即字符串创建索引时必须指定索引长度，具体索引长度应该在区分度较高的前提下，索引长度越短越好。区分度=count(distinct left(列名, 索引长度))/count(*)，即统计重复次数。</li></ul></li><li><p><strong>排序：</strong>保持联合索引的有序性。例如搜索条件where a=? and b=? order by c;，则创建联合索引：a_b_c</p></li><li><p><strong>联合索引：</strong>区分度高的字段放左边。</p></li><li><p><strong>覆盖索引：</strong>使用覆盖索引防止回表；例如查询where a=? and b=? and c=?，则创建联合索引a_b_c，而不是a_b，因为走a_b_c的时候，直接在非聚簇索引树就能获取到所有要查询的字段，不需要回表查聚簇索引树。</p></li><li><p><strong>子查询优化深分页：</strong>正常情况下，深分页查询性能是很差的，例如我需要1w页第一条数据，那么就需要查出前1w条数据，性能很慢。用子查询可以优化深分页。</p></li><li><p><strong>深分页查询优化：</strong>需求是返回第1000000~1000010 的记录。如果直接limit 100000,10，将会先排序前十万条数据并回表，查询速度会非常慢，甚至会超时。</p><ul><li><p><strong>主键有序的表根据主键排序，先过滤再排序：</strong>直接查上页最后记录之后的几个数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 自增。适用于app端和web端。由于不建议用自增策略（不安全、<span class="number">8.0</span>才修复的ID回溯问题），所以此方法适用性不广。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">99999</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 雪花。x是上页最后一条记录的id。只适用于app端上下滑动分页时候必能拿到上页记录id。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> #&#123;x.id&#125; LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>主键不有序的表根据主键排序，先给主键分页，然后内连接原表：</strong>当前表内连接排序截取后的主键表，连接字段是主键。因为查主键是在聚簇索引树查，不用回表，排序和分页很快</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t,(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>,<span class="number">10</span>) a <span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure></li><li><p><strong>主键有序的表根据非主键排序：</strong>得到上一页最后一条记录x（app端通过下拉翻页是肯定能获得上页最后记录的），那么目标页码的所有记录id都比x.id小（因为逆序，且排序依据其实是age,id，主键自增），目标页码的所有记录age都比x.age小或等于。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 自增</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id<span class="operator">&lt;</span>#&#123;x.id&#125; <span class="keyword">AND</span> age<span class="operator">&gt;=</span>#&#123;x.age&#125; <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 雪花一个思路，只是x.id通过子查询获取</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>命中索引的要求：</strong>SQL 性能优化目标至少达 range 级别（范围索引），要求是 ref 级别（非唯一索引），最好const（唯一索引）。</p></li></ul><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><h3 id="基本规范-2"><a href="#基本规范-2" class="headerlink" title="基本规范"></a>基本规范</h3><ul><li><strong>更新前要先查询：</strong>删除、更新前要先查询，避免误操作。</li><li>禁用存储过程；</li><li>禁用外键、级联。</li></ul><h3 id="查询字段"><a href="#查询字段" class="headerlink" title="查询字段"></a>查询字段</h3><ul><li><p><strong>禁用select *。</strong>原因：</p><ul><li><p><strong>性能：</strong>多查询一些不需要的字段，性能差；</p></li><li><p><strong>失去覆盖索引的可能性：</strong>在命中联合索引时，查询的字段正好在非聚簇索引树中，就不需要回表了，而如果select *，则一定需要回表，影响性能。</p></li><li><p><strong>对比select 全部字段：</strong>即使需求是查询全部字段，也尽量用select 全部字段，而不用select *。原因：</p><ul><li><p><strong>性能：</strong>select * 在系统解析的时候会多一步从系统表获取具体字段的步骤，因此会比select 全部字段多花时间，效率稍低。</p></li><li><p><strong>结果顺序：</strong>select 全部字段，查询的结果字段顺序可控；</p></li></ul></li><li><p><strong>应用场景：</strong>某些特例也是可以用select *的，例如一些特定场景，在开发过程中（非生产环境），表结构、字段名频繁变化，可以暂时用select *</p></li></ul></li><li><p><strong>查询数量：</strong>正确区分count(*)、count(1)、count(字段)</p><ul><li><strong>count(*)：</strong>统计包括null的所有行数</li></ul></li><li><p><strong>count(1)：</strong>统计包括null的第一列的行数。因为第一列在每一列都存在，所以等同于统计了所有行，并且不需要检查各行数据， 所以性能可能略高于count(*)</p><ul><li><strong>count(字段)：</strong>统计不包括null的字段列的行数。例如学生表有100行，name列全是null，select count(name) from student查出的结果是0.</li></ul></li><li><p><strong>求和：</strong>当某一列值全是null时，count(col)的值是0，sum(col)的值是null，所以求和时要防止空指针异常。</p></li></ul><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><strong>先查数量再查询：</strong>分页查询前先查询count，如果count为0，则直接返回数据为null，不再分页查询，提高效率。</p><hr><h2 id="对象关系映射（ORM）"><a href="#对象关系映射（ORM）" class="headerlink" title="对象关系映射（ORM）"></a>对象关系映射（ORM）</h2><ul><li><p><strong>禁用select *。</strong></p></li><li><p><strong>布尔型字段：</strong>数据库表用is_xxx，实体类禁用isXxx</p><ul><li><p><strong>结构：</strong>is_xxx</p></li><li><p><strong>数据类型：</strong>unsigned tinyint</p></li><li><p><strong>值：</strong>1 表示是，0 表示否</p></li><li><p><strong>对应实体类变量：</strong>虽然数据库必须命名成is_xxx，但是该表对应的实体类成员变量<strong>不能命名为isXxx</strong>，否则会导致序列号失败。所系需要在 resultMap 中进行字段与属性之间的映射。</p></li></ul></li><li><p><strong>参数：</strong>使用#{}，#param#，而不是${}。防止SQL注入。</p></li><li><p><strong>返回值：</strong>强制禁用Map，虽然少去了序列号的过程，性能会快一点，但是字段类型不可控。</p></li><li><p><strong>更新接口：</strong>更新时不要更新全部字段，尽量不要写一个参数为实体类的更新接口。一方面可以防止出错、另一方面可以提高性能、减少binlog存储（binlog是二进制日志文件，记录改不记录读，用于数据复制和数据恢复；在主从同步时用到）。</p></li><li><p><strong>不要滥用事务：</strong>事务要尽可能的控制粒度，使粒度尽可能的小，例如一些不必要的查询可以放在事务外部，以减少锁冲突、缩短连接时长，从而提高QPS（每秒发送的请求数）</p></li></ul>]]></content>
    
    
    <summary type="html">‌</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    
    <category term="system" scheme="https://southernfish.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库-表设计优化、读写分离与分库分表</title>
    <link href="https://southernfish.github.io/2025/07/26/database/db-mysql-5-sharding/"/>
    <id>https://southernfish.github.io/2025/07/26/database/db-mysql-5-sharding/</id>
    <published>2025-07-26T11:30:36.000Z</published>
    <updated>2025-07-28T10:27:55.449Z</updated>
    
    <content type="html"><![CDATA[<p>数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，核心目标是将低效SQL语句转换为高效等效语句。人工智能自动优化技术通过重写SQL语句实现性能提升。优化技术演变历经三代工具：第一代解析执行计划，第二代推荐索引优化，第三代提出语法改进建议。优化策略贯穿数据库生命周期，其中设计阶段优化成本最低且收益最大。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/139088747">【MySQL调优】如何进行MySQL调优？从参数,数据,建模,索引,SQL语句等方向，三万字详细解读MySQL的性能优化方案（2024版）</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/133797658">一篇文章搞懂MySQL的分库分表，从拆分场景、目标评估、拆分方案、不停机迁移、一致性补偿等方面详细阐述MySQL数据库的分库分表方案</a></p></blockquote><h1 id="表设计优化"><a href="#表设计优化" class="headerlink" title="表设计优化"></a>表设计优化</h1><h2 id="混合业务分表、冷热数据分表"><a href="#混合业务分表、冷热数据分表" class="headerlink" title="混合业务分表、冷热数据分表"></a>混合业务分表、冷热数据分表</h2><p>例如把一个大的任务表，分离成任务表和历史任务表，任务表里任务完成后移动到历史任务表。任务表是热数据，历史任务表是冷数据，提高查询性能。</p><p><strong>混合业务分表：</strong></p><p>根据业务逻辑，将不同的业务数据分开存储在不同的表中。每个业务模块的数据单独存储，减少了单表的大小和查询的复杂度。</p><ul><li><strong>示例：</strong>将一个大的日志表，拆分成交易日志表、操作日志表、登录日志表等。这些要在项目设计期间就根据预估的数据量进行拆分。</li></ul><p><strong>冷热数据分表：</strong></p><p>将频繁访问的“热数据”和不常访问的“冷数据”分开存储。这种策略有助于提高热数据的查询性能，并且在存储和备份方面更加灵活。</p><ul><li><strong>示例1：</strong>把一个大的任务表，分离成任务表和历史任务表，任务表里任务完成后移动到历史任务表。任务表是热数据，历史任务表是冷数据，提高查询性能。</li><li><strong>示例2：</strong>或者将日志表分成日志表和历史日志表，使用定时任务将三个月前的日志都迁移到历史日志表，用户查看操作记录时，默认只显示近三个月的数据，从而提高性能。</li></ul><h2 id="联合查询改为中间关系表"><a href="#联合查询改为中间关系表" class="headerlink" title="联合查询改为中间关系表"></a>联合查询改为中间关系表</h2><p>例如属性表和属性分组表，不使用连接查询，使用“属性-属性分组表”存储每条属性与“属性关系”的id。</p><p>对于复杂的数据库设计，使用关系表是一种常见的方法，特别是在多对多的关系中，例如学生表和课程表、商品表和商品属性表、用户和角色表、作者和书籍表、部门和人员表。</p><p><strong>示例：</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 部门表 (departments)</span><br><span class="line">departments(department_id, department_name)</span><br><span class="line"># 人员表 (employees)</span><br><span class="line">employees(employee_id, employee_name)</span><br><span class="line"># 部门员工关联表 (department_employees)</span><br><span class="line">department_employees(id, department_id, employee_id)</span><br><span class="line"># department_id：外键，指向 departments 表；employee_id：外键，指向 employees 表</span><br></pre></td></tr></table></figure><p><strong>关系表的优点：</strong></p><ul><li><strong>多对多关系：</strong>通过中间表可以管理多对多的映射关系。</li><li><strong>支持扩展：</strong>关系表可以添加额外的字段来描述关系的属性。</li><li><strong>提高查询性能：</strong>减少表连接的次数，提高查询性能。</li></ul><h2 id="遵循三个范式"><a href="#遵循三个范式" class="headerlink" title="遵循三个范式"></a>遵循三个范式</h2><p>每个属性不可再分、表必须有且只有一个主键、非主键列必须直接依赖于主键</p><h2 id="字段建议非空约束"><a href="#字段建议非空约束" class="headerlink" title="字段建议非空约束"></a>字段建议非空约束</h2><ol><li>可能查询出现空指针问题；</li><li>导致聚合函数不准确，因为它会忽略null</li><li>不能用“=”判断，只能用is null判断；</li><li>null和其他值运算只能是null，可能让你不小心把它当成0；</li><li>null值比空字符更占用空间，空值长度是0，null长度是1bit；</li><li>不覆盖索引情况下，is not null无法用索引</li></ol><h2 id="反范式：使用冗余字段"><a href="#反范式：使用冗余字段" class="headerlink" title="反范式：使用冗余字段"></a>反范式：使用冗余字段</h2><p>虽然列字段不能太多，但为查询效率可增加冗余字段。</p><p><strong>反范式：</strong>为提高查询效率，可添加不常更新的字段为冗余字段。</p><p>反范式化是数据库设计的一种策略，通过在设计中引入冗余数据来提高查询性能，简化查询操作，或满足其他业务需求。</p><p><strong>使用场景：</strong></p><p>将多读少写的字段，增加为冗余字段，从而不再需要每次都连表查询这个字段。</p><blockquote><p><strong>注意：</strong></p><p>增加冗余字段后，当这个冗余字段对应的数据改动后，必须同步更改这个冗余字段。</p><p>例如成绩表除了有student_id字段外，增加冗余字段student_name，因为学生名基本不会变化，但在修改姓名的接口里，修改学生名后要同步修改成绩表的student_name字段。</p></blockquote><h2 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h2><ol><li><p><strong>整数类型</strong></p><p>考虑好数值范围，前期可以使用<code>int</code>保证稳定性。非负数类型要用UNSIGNED；同样字节数，存储的数值范围更大。主键一般使用<code>bigint</code>，布尔类型<code>tinint</code></p></li><li><p><strong>能整数就不要用文本类型：</strong>跟文本类型数据相比，大整数往往占用更少的存储空间。</p></li><li><p><strong>避免使用TEXT、BLOB数据类</strong></p><p>这两个大数据类型，排序时不能使用临时内存表，只能使用磁盘临时表，效率很差，建议别用，或分表到单独扩展表里。LongBlob类型能存储4G文件；</p></li><li><p><strong>避免使用枚举类型：</strong>排序很慢。</p></li><li><p><strong>使用TIMESTAMP存储时间：</strong></p><p>TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。 缺点是只能存到2038年，MySQL5.6.4版本可以参数配置，自动修改它为BIGINT类型。</p></li><li><p><strong>DECIMAL存浮点数</strong></p><p>Decimal类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。 </p></li></ol><hr><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p><strong>读写分离</strong>：读写分离能有效提高查询性能。读写分离基于MySQL的主从同步，一台主库负责写，多台从库负责读，每次主库发生写操作后，通过binlog和relay log，将修改操作同步到从库，从而保持主库和从库的数据一致性。</p><p><strong>主从同步：</strong>一台或多台MySQL数据库(slave，即从库)从另一台NySQL数据库（master，即主库）进行日志的复制，然后再解析日志并应用到自身，最终实现从库的数据和主库的数据保持一致。MySQL主从复制是NySQL数据库自带功能，无需借助第三方工具。</p><p><strong>主从同步实现步骤：</strong> </p><ol><li><strong>主服务器</strong>把数据更改记录到<strong>二进制日志</strong>（binlog，记录改不记录读，用于数据复制和数据恢复）中；</li><li><strong>从服务器</strong>异步近似实时地把主服务器的二进制日志<strong>复制到</strong>自己的<strong>中继日志</strong>（relay log）中；</li><li><strong>从服务器重做</strong>中继日志中的操作，把更改应用到自己的数据库上，以达到数据的最终一致性。</li></ol><p><strong>主从同步的延时问题：</strong></p><ul><li><p><strong>延时问题：</strong>是主服务器压力大导致的复制延时问题。</p></li><li><p><strong>解决方案</strong>：</p><ul><li><strong>网络带宽优化：</strong>如果是网络延时问题，可以通过增大服务器的带宽解决。</li><li><strong>硬件调优：</strong>如果是因为硬件配置差导致同步延时，可以通过提升服务器配置解决。</li></ul></li><li><p><strong>参数调优：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 多线程复制（MySQL 5.7及以上版本）：设置并行线程数</span></span><br><span class="line">slave_parallel_workers = 4  </span><br><span class="line"><span class="comment"># 开启半同步复制（MySQL 5.5及以上版本）</span></span><br><span class="line">rpl_semi_sync_master_enabled = 1</span><br><span class="line">rpl_semi_sync_slave_enabled = 1</span><br><span class="line"><span class="comment"># 同步延时时间：1秒超时。如果频繁写，则适当缩小；如果频繁读少写，则适当增大，以降低服务器压力</span></span><br><span class="line">rpl_semi_sync_master_timeout = 1000  </span><br></pre></td></tr></table></figure></li><li><p><strong>缩小事务粒度：</strong>一些代码中直接在整个Controller或者整个Service方法上加个@Transcational，而整个业务中其实只有一小段需要保持事务，这样是很影响性能的，因为事务不是那个，MySQL的连接会一直被占用，对数据库的压力很大。</p><p><strong>解决方案：</strong>减小代码中事务的粒度，例如将大事务拆解成小事务，将其中的一些查询操作脱离出去，只在写操作的方法中加事务；</p></li></ul><p><strong>复制原理：</strong> </p><ul><li><strong>主库二进制日志转储线程：</strong>负责将二进制日志发给从库。强制从主库读取数据时（/<em>master</em>/ SELECT * FROM user），会给二进制日志<strong>加锁</strong> ，读完解锁。</li><li><strong>从库I/O 线程：</strong>负责连接主库，并向主库发送请求和复制二进制日志到中继日志。</li><li><strong>从库SQL 线程：</strong>负责读取并执行中继日志中的更新语句，实现主从同步。 </li></ul><p><strong>主从库数量：</strong> </p><ul><li>每个 Master 可以有多个 Slave</li><li>每个 Slave 只能有一个唯一的服务器ID，只有一个 Master。</li></ul><hr><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>只分表：</strong>单表数据量大，读写出现瓶颈，这个表所在的库还可以支撑未来几年的增长。</li><li><strong>只分库：</strong>整个数据库读写出现性能瓶颈，将整个库拆开。</li><li><strong>分库分表：</strong>单表数据量大，所在库也出现性能瓶颈，就要既分库又分表。</li><li><strong>垂直拆分：</strong>把字段分开。例如spu表的pic字段特别长，建议把这个pic字段拆到另一个表（同库或不同库）。</li><li><strong>水平拆分：</strong>把记录分开。例如表数据量到达百万，我们拆成四张20万的表。</li></ul><h2 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h2><p>一般情况下，单表数据量到达千万级别，就可以考虑分库分表了。</p><p>具体是否分库分表看具体业务场景，例如流水表、记录表，数据量非常容易到达千万级、亿万级，需要在设计数据库表的阶段就进行分表，还有一些表虽然数据量只有几百万，但字段非常多，而且有很多text、blog格式的字段，查询性能也会很慢，可以考虑分库分表。</p><table><thead><tr><th align="left">数据量增长情况</th><th align="left">数据表类型</th><th align="left">优化核心思想</th></tr></thead><tbody><tr><td align="left">数据量为千万级，是一个相对<strong>稳定</strong>的数据量</td><td align="left">状态表</td><td align="left">能不拆就不拆读需求水平扩展</td></tr><tr><td align="left">数据量为千万级，可能达到<strong>亿级</strong>或者更高</td><td align="left">流水表</td><td align="left">业务拆分，面向分布式存储设计</td></tr><tr><td align="left">数据量为千万级，可能达到<strong>亿级</strong>或者更高</td><td align="left">流水表</td><td align="left">设计数据统计需求存储的分布式扩展</td></tr><tr><td align="left">数据量为千万级，不应该有这么多的数据</td><td align="left">配置表</td><td align="left">小而简，避免大一统</td></tr></tbody></table><h2 id="分库分表步骤简述"><a href="#分库分表步骤简述" class="headerlink" title="分库分表步骤简述"></a>分库分表步骤简述</h2><ol><li><strong>MySQL调优：</strong>数据量能稳定在千万级，近几年不会到达亿级，其实是不用着急拆的，先尝试MySQL调优，优化读写性能。</li><li><strong>目标评估：</strong>评估拆几个库、表，举例: 当前20亿，5年后评估为100亿。分几个表? 分几个库?解答:一个合理的答案，1024个表，16个库按1024个表算，拆分完单表200万，5年后为1000万.1024个表*200w≈100亿。</li><li><strong>表拆分：</strong><ul><li><strong>业务层拆分：</strong>混合业务拆分为独立业务、冷热分离</li><li><strong>数据层拆分：</strong><ul><li><strong>按日期拆分：</strong>这种方式较普遍，尤其是按照日期维度的拆分，其实在程序层面的改动很小，但扩展性方面的收益很大。<ul><li>日维度拆分，如test_20191021</li><li>月维度拆分,如test_201910</li><li>年维度拆分,如test_2019</li></ul></li><li><strong>按主键范围拆分：</strong>例如【1,200w】主键在一个表，【200w，400w】主键在一个表。优点是单表数据量可控。缺点是流量无法分摊，写操作集中在最后面的表。</li><li><strong>中间表映射：</strong>表随意拆分，引入中间表记录查询的字段值，以及它对应的数据在哪个表里。优点是灵活。确定是引入中间表让流程变复杂。</li><li><strong>hash切分：</strong>sharding_key%N。优点是数据分片均匀，流量分摊。缺点是扩容需要迁移数据，跨节点查询问题。</li><li><strong>按分区拆分：</strong>hash,range等方式。不建议，因为数据其实难以实现水平扩展。</li></ul></li></ul></li><li><strong>sharding_key（分表字段）选择：</strong>尽量选择查询频率最高的字段，然后根据表拆分方式选择字段。</li><li><strong>代码改造：</strong>修改代码里的查询、更新语句，以便让其适应分库分表后的情况。</li><li><strong>数据迁移：</strong>最简单的就是停机迁移，复杂点的就是不停机迁移，要考虑增量同步和全量同步的问题。<ol><li><strong>全量同步：</strong>老库到新库的数据迁移，要控制好迁移效率，解决增量数据的一致性。<ol><li><strong>定时任务：</strong>定时任务查老库写新库</li><li><strong>中间件：</strong>使用中间件迁移数据</li></ol></li><li><strong>增量同步：</strong>老库迁移到新库期间，新增删改命令的落库不能出错<ol><li><strong>同步双写：</strong>同步写新库和老库；</li><li><strong>异步双写（推荐）：</strong> 写老库，监听binlog异步同步到新库</li><li><strong>中间件同步工具：</strong>通过一定的规则将数据同步到目标库表</li></ol></li></ol></li><li><strong>数据一致性校验和补偿：</strong>假设采用异步双写方案，在迁移完成后，逐条对比新老库数据，<strong>一致则跳过，不一致则补偿：</strong><ol><li>新库存在，老库不存在：新库删除数据</li><li>新库不存在，老库存在：新库插入数据</li><li>新库存在、老库存在：比较所有字段，不一致则将新库更新为老库数据</li></ol></li><li><strong>灰度切读：</strong>灰度发布指黑（旧版本）与白（新版本）之间，让一些用户继续用旧版本，一些用户开始用新版本，如果用户对新版本没什么意见，就逐步把所有用户迁移到新版本，实现平滑过渡发布。<strong>原则：</strong><ol><li>有问题及时切回老库</li><li>灰度放量先慢后快，每次放量观察一段时间</li><li>支持灵活的规则：门店维度灰度、百 (万)分比灰度</li></ol></li><li><strong>停老用新：</strong>下线老库，用新库读写。</li></ol><h2 id="分库分表步骤详细"><a href="#分库分表步骤详细" class="headerlink" title="分库分表步骤详细"></a>分库分表步骤详细</h2><h3 id="分库分表的原则：能不分就不分"><a href="#分库分表的原则：能不分就不分" class="headerlink" title="分库分表的原则：能不分就不分"></a>分库分表的原则：能不分就不分</h3><ol><li><p><strong>优先MySQL调优，能不分就不分</strong></p><p>数据量能稳定在千万级，近几年不会到达亿级，其实是不用着急拆的，先尝试MySQL调优，优化读写性能。只有在MySQL调优已经无法解决慢查询问题时，才可以考虑分库分表。</p></li><li><p><strong>分片数量尽量少</strong>。</p><p>分片尽量均匀分布在多个 DataHost 上，因为一个查询 SQL 跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量。</p></li><li><p><strong>不要一个事务里跨越多个分片查询</strong></p><p>尽量不要在一个事务中的 SQL 跨越多个分片，分布式事务一直是个不好处理的问题。</p></li></ol><h3 id="目标评估"><a href="#目标评估" class="headerlink" title="目标评估"></a>目标评估</h3><p>评估需要拆分成几个库、几个表。</p><p><strong>举例：</strong>当前20亿，5年后评估为100亿。分几个表? 分几个库?</p><p><strong>解答</strong>：一个合理的答案，1024个表，16个库按1024个表算，拆分完单表200万，5年后为1000万.1024个表*200w≈100亿</p><h3 id="表拆分"><a href="#表拆分" class="headerlink" title="表拆分"></a>表拆分</h3><h4 id="业务层面拆分"><a href="#业务层面拆分" class="headerlink" title="业务层面拆分"></a>业务层面拆分</h4><h5 id="混合业务拆分"><a href="#混合业务拆分" class="headerlink" title="混合业务拆分"></a>混合业务拆分</h5><p>将混合业务拆分为独立业务。<strong>业务场景举例：</strong></p><ul><li><strong>电商网站：</strong>一个典型的混合业务，包含用户信息、订单信息、商品信息等。可以将用户信息、订单信息和商品信息分别拆分到不同的库或表中，以减少数据冗余并提高访问效率。</li><li><strong>社交媒体平台：</strong>含用户信息、好友关系、动态信息等。可将用户信息和好友关系分离存储，以便更好支持好友关系的查询和更新。</li><li><strong>在线游戏：</strong>涉及角色信息、道具信息、战斗日志等。可以将角色信息和道具信息拆分到不同的表中，以提升查询效率，并将战斗日志存储到日志数据库中，以减轻主数据库的负载。</li><li><strong>物流系统：</strong>包含订单信息、配送信息、运输信息等。可以将订单信息、配送信息和运输信息分别拆分到不同的表中，以便更好地支持订单的查询和跟踪。</li></ul><h5 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h5><p>将常用的“热”数据和不常使用的“冷”数据分开存储。即在处理数据时将数据库分成冷库和热库，冷库存放那些走到终态、不常使用的数据，热库存放还需要修改、经常使用的数据。</p><p><strong>什么情况下可以使用冷热分离？</strong></p><ol><li><strong>数据走到终态后只有读没有写的需求。</strong>例如订单完结后基本只会读不会改。</li><li><strong>用户能接受新旧数据分开查询。</strong>比如某电商网站默认只让查询3个月内的订单，若要查询3个月前的订单，还需要访问其他的页面。</li></ol><p><strong>业务场景举例：</strong></p><ul><li><strong>邮件系统：</strong>邮件系统中最近邮件是用户经常访问和修改的，三个月前的邮件或已归档的邮件不经常访问的。可以将用户的收件箱、发件箱里最近三个月的邮件放在一个库里（热库），之前的邮件或者已读的邮件放在另一个库里（冷库）。</li><li><strong>日志系统：</strong>在大型应用中，日志数据是非常庞大的，但并不是所有日志都需要经常查询或分析。可以将最近一段时间的活动日志存放在热库中，而将过去的历史日志存放在冷库中，以减轻热库的负载和优化查询性能。</li><li><strong>社交媒体平台</strong>：社交媒体平台上的用户数据量通常很大，但是只有少部分用户是活跃的，并且只有少量用户的数据会频繁访问和更新，如果所有用户都放在同一个库里，势必会影响活跃用户的查询效率。可以将活跃用户的个人信息、好友关系等存放在热库中，而将不活跃用户的数据存放在冷库中，以提升热库的性能和减少冷库的存储成本。</li><li><strong>电商平台：</strong>电商平台上的商品数据也可以进行冷热分离。热库中存放热门商品的基本信息和库存等，以支持频繁的查询和更新操作，而将不活跃或下架的商品信息存放在冷库中，以减少热库的负载和优化查询性能。</li><li><strong>客服工单：</strong>在我们日常操作时，经常能看到查询历史工单时会有个“近三个月工单”的选项，实际业务场景中，用户基本只会关注近三个月工单，而且这些工单也会经常需要进行修改、删除的操作，而对很早期的历史订单基本就没有修改、删除的需求，只有少量的查询需求。</li></ul><h4 id="数据层面拆分"><a href="#数据层面拆分" class="headerlink" title="数据层面拆分"></a>数据层面拆分</h4><ul><li><strong>按日期拆分：</strong>这种使用方式比较普遍，尤其是按照日期维度的拆分，其实在程序层面的改动很小，但是扩展性方面的收益很大。<ul><li>日维度拆分，如test_20191021</li><li>月维度拆分,如test_201910</li><li>年维度拆分,如test_2019</li></ul></li><li><strong>按主键范围拆分：</strong>例如【1,200w】主键在一个表，【200w，400w】主键在一个表。优点是单表数据量可控。缺点是流量无法分摊，写操作集中在最后面的表。</li><li><strong>中间表映射：</strong>表随意拆分，引入中间表记录查询的字段值，及它对应的数据在哪个表里。虽然灵活但是引入中间表让流程变复杂。</li><li><strong>hash切分：</strong>sharding_key%N。优点是数据分片均匀，流量分摊。缺点是扩容需要迁移数据，跨节点查询问题。</li><li><strong>按分区拆分：</strong>hash,range等方式。不建议，因为数据其实难以实现水平扩展。</li></ul><h3 id="分表字段（sharding-key）选择"><a href="#分表字段（sharding-key）选择" class="headerlink" title="分表字段（sharding_key）选择"></a>分表字段（sharding_key）选择</h3><p>最佳的分表字段应该是能够让数据分布均匀、频繁查询的字段及不可变的字段。通过选择最佳的分表字段，可提高系统性能和查询效率。</p><h4 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h4><ul><li><strong>主键ID：</strong>频繁查询并且唯一，非常适合作分表字段。<em>例如</em>，在用户表中，用户ID作为分表字段是一个不错的选择，因为用户ID是唯一的，而且在查询用户信息时经常会用到。</li><li><strong>时间字段：</strong>如果业务需要按时间范围查询数据，那么选择时间字段作为分表字段是合理的。<em>例如</em>，在日志表中，可以选择时间戳字段作为分表字段，以便按天、按月或按年分割数据，方便查询和维护。</li><li><strong>地理信息字段：</strong>如果业务需要按地区查询数据，那么选择地理信息字段作为分表字段是合适的。<em>例如</em>，在订单表中，可以选择订单地区字段作为分表字段，以便将订单数据按地区进行拆分，方便查询和扩展。</li><li><strong>关联字段：</strong>如果业务需要频繁进行关联查询，那么选择订单号等关联字段作为分表字段。<em>例如</em>，在订单表中，可以选择订单号作为分表字段，因为订单号唯一且包含业务信息，并且日常查询、关联查询都是根据订单号查询的，很少根据id查询，方便查询和维护。</li></ul><h4 id="选择分表字段的原则"><a href="#选择分表字段的原则" class="headerlink" title="选择分表字段的原则"></a>选择分表字段的原则</h4><ol><li><p><strong>数据分布均匀</strong></p><p>最佳的分表字段应该是能够让数据分布均匀的字段，这样可以避免某个表的数据过多，导致查询效率降低。在用户表中，如果以地区作为分表字段，可能会导致某些地区的数据过多，而某些地区的数据过少。</p></li><li><p><strong>频繁查询的字段</strong></p><p>尽量选择查询频率最高的字段（例如主键id），然后根据表拆分方式选择字段。在一个订单表中，如果经常需要根据用户ID查询订单信息，那么以用户ID作为分表字段是一个不错的选择。</p></li><li><p><strong>不可变字段</strong></p><p>最佳的分表字段还应该是不可变的字段，这样可以避免在数据迁移时出现问题。在一个商品表中，如果选择以商品名称作为分表字段，那么当商品名称发生变化时，就需要将数据移动到不同的表中，这样会增加系统的复杂度。</p></li></ol><h3 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h3><p>修改代码里的查询、更新语句，以便让其适应分库分表后的情况。</p><p><strong>查询语句改造：</strong></p><ul><li><p><strong>单库查询改为跨库查询：</strong>对于需要查询的字段，需要明确指定查询的库和表，以避免查询到错误的数据。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;            # 原查询语句</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> db.table_name <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;     # 修改后：其中 db 为目标数据库，table_name 为目标表</span><br></pre></td></tr></table></figure></li><li><p><strong>单表查询改为跨表查询：</strong>例如投诉记录表根据哈希取余的方式分成10个表，如果id%1=0，则查0号表complaint_records_0。</p></li></ul><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>最简单的就是停机迁移，复杂点的就是不停机迁移，要考虑增量同步和全量同步的问题。</p><h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p>老库迁移到新库期间，增删改命令的落库不能出错</p><ul><li>同步双写：同步写新库和老库；</li><li><strong>异步双写（推荐）：</strong> 写老库，监听binlog异步同步到新库</li><li>中间件同步工具：通过一定的规则将数据同步到目标库表</li></ul><h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p>老库到新库的数据迁移，要控制好迁移效率，解决增量数据的一致性。</p><ul><li><strong>定时任务查老库写新库</strong></li><li>使用中间件迁移数据，例如<code>Dbmate、Apache NiFi、Ladder、Phinx、Flyway、TiDB</code>等。</li></ul><h3 id="数据一致性校验和补偿"><a href="#数据一致性校验和补偿" class="headerlink" title="数据一致性校验和补偿"></a>数据一致性校验和补偿</h3><p>假设采用异步双写方案，在迁移完成后，逐条对比新老库数据，一致则跳过，<strong>不一致则补偿：</strong></p><ul><li>新库存在，老库不存在：新库删除数据</li><li>新库不存在，老库存在：新库插入数据</li><li>新库存在、老库存在：比较所有字段，不一致则将新库更新为老库数据</li></ul><h3 id="灰度切读"><a href="#灰度切读" class="headerlink" title="灰度切读"></a>灰度切读</h3><p>灰度发布指黑（旧版本）与白（新版本）之间，让一些用户继续用旧版本，一些用户开始用新版本，如果用户对新版本没什么意见，就逐步把所有用户迁移到新版本，实现平滑过渡发布。<strong>遵循原则如下：</strong></p><ul><li>有问题及时切回老库</li><li>灰度放量先慢后快，每次放量观察一段时间</li><li>支持灵活的规则：门店维度灰度、百 (万)分比灰度</li></ul><h3 id="停旧库、写新库"><a href="#停旧库、写新库" class="headerlink" title="停旧库、写新库"></a>停旧库、写新库</h3><p>下线老库，用新库读写。</p>]]></content>
    
    
    <summary type="html">‌数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，目标是将低效SQL语句转换为高效等效语句。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库-查询优化</title>
    <link href="https://southernfish.github.io/2025/07/26/database/db-mysql-6-query/"/>
    <id>https://southernfish.github.io/2025/07/26/database/db-mysql-6-query/</id>
    <published>2025-07-26T07:30:36.000Z</published>
    <updated>2025-07-28T10:27:55.449Z</updated>
    
    <content type="html"><![CDATA[<p>数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，核心目标是将低效SQL语句转换为高效等效语句。人工智能自动优化技术通过重写SQL语句实现性能提升。优化技术演变历经三代工具：第一代解析执行计划，第二代推荐索引优化，第三代提出语法改进建议。优化策略贯穿数据库生命周期，其中设计阶段优化成本最低且收益最大。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/139088747">【MySQL调优】如何进行MySQL调优？从参数,数据,建模,索引,SQL语句等方向，三万字详细解读MySQL的性能优化方案（2024版）</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130787410">MySQL高级篇——关联查询和子查询优化</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130790354">MySQL高级篇——排序、分组、分页优化</a></p></blockquote><h1 id="数据库引擎查询流程"><a href="#数据库引擎查询流程" class="headerlink" title="数据库引擎查询流程"></a>数据库引擎查询流程</h1><h2 id="通用查询流程"><a href="#通用查询流程" class="headerlink" title="通用查询流程"></a>通用查询流程</h2><ol><li><strong>解析 SQL 语句：</strong>数据库引擎先将 SQL 语句解析成内部的执行计划，包括了查询哪些数据表、使用哪些索引、如何连接多个数据表等信息。</li><li><strong>优化查询计划：</strong>数据库引擎对内部的执行计划进行优化，根据查询的复杂度、数据量和系统资源等因素，选择最优的执行计划。</li><li><strong>执行查询计划：</strong>数据库引擎根据执行计划，通过 I/O 操作读取数据表的数据，进行数据过滤、排序、分组等操作，最终返回结果集。</li><li><strong>缓存查询结果：</strong>如果查询结果集比较大或者查询频率较高，数据库引擎会将查询结果缓存在内存中，以加速后续的查询操作。</li></ol><h2 id="MySQL-中-select-的执行流程"><a href="#MySQL-中-select-的执行流程" class="headerlink" title="MySQL 中 select 的执行流程"></a>MySQL 中 select 的执行流程</h2><ol><li><strong>连接器：</strong>主要作用是建立连接、管理连接及校验用户信息。</li><li><strong>查询缓冲：</strong>查询缓冲是以key-value的方式存储，key就是查询语句，value就是查询语句的查询结果集；如果命中直接返回。<ul><li><strong>8.0版本废弃</strong>：注意，MySQL 8.0已经删除了查询缓冲。从MySQL 5.6版本开始，官方将Query Cache设置为了默认关闭。</li><li><strong>原因</strong>：官方给出的原因是此功能比较鸡肋，而且减少性能的可变性确实通常比提高峰值吞吐量更重要，尤其是在生产环境中。稳定的性能可以确保用户体验的一致性，并减少系统出现瓶颈或宕机的风险。</li><li><strong>方案</strong>：官方给出了所替代的解决方案建议——使用第三方工具客户端缓存ProxySQL 来代替Query Cache。</li></ul></li><li><strong>分析器：</strong>词法句法分析生成语法树。</li><li><strong>优化器：</strong>指定执行计划，选择查询成本最小的计划。</li><li><strong>执行器：</strong>根据执行计划，从存储引擎获取数据，并返回客户端</li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250727122422644.png" alt="image-20250727122422644"></p><h2 id="ProxySQL"><a href="#ProxySQL" class="headerlink" title="ProxySQL"></a>ProxySQL</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>一个MySQL中间件，一个高性能的 MySQL 代理，一个用 C++ 开发的轻量级产品。旨在提高 MySQL 服务器的性能、可伸缩性和可用性。MySQL官方推荐的Query Cache替换方案。</p><p><strong>同类产品：</strong>DBproxy、MyCAT、OneProxy</p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">sudo yum install proxysql</span><br><span class="line"># 配置： 修改<span class="operator">/</span>etc<span class="operator">/</span>proxysql.cnf 直接配置，或者访问管理接口配置</span><br><span class="line"><span class="comment">-- 连接到管理接口</span></span><br><span class="line">mysql <span class="operator">-</span>u admin <span class="operator">-</span>padmin <span class="operator">-</span>h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>P <span class="number">6032</span></span><br><span class="line"><span class="comment">-- 添加MySQL服务器</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers (hostgroup_id, hostname, port) <span class="keyword">VALUES</span> (<span class="number">0</span>, <span class="string">&#x27;192.168.1.100&#x27;</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="comment">-- 加载配置到运行时</span></span><br><span class="line">LOAD MYSQL SERVERS <span class="keyword">TO</span> RUNTIME;</span><br><span class="line"><span class="comment">-- 保存配置到磁盘</span></span><br><span class="line">SAVE MYSQL SERVERS <span class="keyword">TO</span> DISK;</span><br></pre></td></tr></table></figure><h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><ul><li><p><strong>查询缓存</strong></p></li><li><p><strong>负载均衡</strong>：支持自动摘除宕机的DB</p></li><li><p>读写分离</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 主库</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers (hostgroup_id, hostname, port) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;192.168.1.101&#x27;</span>, <span class="number">3306</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从库</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers (hostgroup_id, hostname, port) <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="string">&#x27;192.168.1.102&#x27;</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers (hostgroup_id, hostname, port) <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="string">&#x27;192.168.1.103&#x27;</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="comment">-- 将所有写操作（INSERT、UPDATE、DELETE）定向到主库</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;^INSERT&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;^UPDATE&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">1</span>, <span class="string">&#x27;^DELETE&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 将所有读操作（SELECT）定向到从库</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">1</span>, <span class="string">&#x27;^SELECT&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">-- 加载并保存配置</span></span><br><span class="line">LOAD MYSQL SERVERS <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">SAVE MYSQL SERVERS <span class="keyword">TO</span> DISK;</span><br></pre></td></tr></table></figure></li><li><p>实时监控</p></li><li><p>连接池</p></li><li><p>动态加载配置</p></li><li><p>访问控制</p></li><li><p>ProxySQL集群</p></li></ul><h1 id="连接查询优化"><a href="#连接查询优化" class="headerlink" title="连接查询优化"></a>连接查询优化</h1><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><ul><li><strong>外连接小表驱动大表</strong>：LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li><li><strong>内连接驱动表由优化器决定</strong>：INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li><li><strong>被驱动表优先创建索引</strong>：被驱动表的JOIN字段要创建索引；</li><li><strong>两表连接字段类型必须一致</strong>：两个表JOIN字段数据类型保持绝对一致。防止自动类型转换导致索引失效。</li><li><strong>关联替代子查询</strong>：能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)。子查询是一个SELECT查询的结果作为另一个SELECT语句的条件。</li><li><strong>多次查询代替子查询</strong>：不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li><li>衍生表建不了索引</li></ul><h2 id="被驱动表优先创建索引"><a href="#被驱动表优先创建索引" class="headerlink" title="被驱动表优先创建索引"></a>被驱动表优先创建索引</h2><p>外连接查询时，右表就是被驱动表，建议加索引。</p><p><strong>原因：</strong>因为MySQL连接查询底层是先查过滤条件下的左表，按左表查询的结果，再以<strong>连接字段</strong>作为条件查询结果，所以右表的连接字段加索引，将极大地提高查询性能。</p><blockquote><p><strong>驱动表与被驱动表：</strong></p><ul><li><strong>驱动表：</strong>在连接操作中，驱动表是首先被读取的表。MySQL会从驱动表中读取数据行，然后在被驱动表中寻找匹配的行。</li><li><strong>被驱动表：</strong>被驱动表是连接操作中第二个被读取的表。对于驱动表中的每一行，MySQL会在被驱动表中寻找匹配的行。</li></ul></blockquote><h2 id="左外连接：优先右表创建索引，连接字段类型要一致"><a href="#左外连接：优先右表创建索引，连接字段类型要一致" class="headerlink" title="左外连接：优先右表创建索引，连接字段类型要一致"></a>左外连接：优先右表创建索引，连接字段类型要一致</h2><p><strong>优先右表创建索引：</strong>因为左表是查所有数据，右表是按条件查询，所以右表的条件字段创建索引价值更高一点。</p><p><strong>连接字段类型要一致：</strong>两个表的card字段一定要是同一类型，如果类型不同会导致<strong>隐式类型转换</strong>从而索引失效。 </p><h2 id="内连接：驱动表由数据量和索引决定"><a href="#内连接：驱动表由数据量和索引决定" class="headerlink" title="内连接：驱动表由数据量和索引决定"></a>内连接：驱动表由数据量和索引决定</h2><p>内连接查到的是交集，两个表谁做驱动表查的结果是一样的。所以查询优化器会<strong>根据查询成本</strong>选择驱动表。驱动表就是主表，被驱动表就是从表。<strong>驱动表的选择依据：</strong></p><ul><li><strong>没索引的表：</strong>当只有一个表有索引时，查询优化器会选择没索引的表作为驱动表。</li><li><strong>小表：</strong>当两个表都有或都没有索引时，数据量小的表为驱动表。</li></ul><h2 id="join语句原理"><a href="#join语句原理" class="headerlink" title="join语句原理"></a>join语句原理</h2><p>join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会很长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。</p><ol><li><p><strong>驱动表和被驱动表</strong>：驱动表就是主表，被驱动表就是从表、非驱动表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 对于内连接来说：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ... </span><br><span class="line"># 优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。</span><br><span class="line"># 对于外连接来说：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a(f1 <span class="type">INT</span>, f2 <span class="type">INT</span>, INDEX(f1)) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> b(f1 <span class="type">INT</span>, f2 <span class="type">INT</span>) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> a <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> b <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line"># 测试</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">WHERE</span> (a.f2<span class="operator">=</span>b.f2);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">AND</span> (a.f2<span class="operator">=</span>b.f2);</span><br><span class="line"># 通常，大家会认为A就是驱动表，B就是被驱动表。但也未必。</span><br></pre></td></tr></table></figure></li><li><p><strong>Simple Nested-Loop Join (简单嵌套循环连接)</strong></p><p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result.. 以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726165251064.png" alt="image-20250726165251064"></p><p>这种方式效率是非常低的，以上述表A数据100条，表B数据1000条计算，则A*B=10万次。开销统计如下:</p><table><thead><tr><th align="left">开销统计</th><th align="left">SNLJ</th></tr></thead><tbody><tr><td align="left">外表扫描次数</td><td align="left">1</td></tr><tr><td align="left">内表扫描次数</td><td align="left">A</td></tr><tr><td align="left">读取记录数</td><td align="left">A+B * A</td></tr><tr><td align="left">JOIN比较次数</td><td align="left">B * A</td></tr><tr><td align="left">回表读取记录次数</td><td align="left">0</td></tr></tbody></table></li></ol><p>​    当然mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join优化算法。</p><ol start="3"><li><p><strong>Index Nested-Loop Join （索引嵌套循环连接）</strong></p><p>Index Nested-Loop Join其优化的思路主要是为了减少内存表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内存表的每条记录去进行比较，这样极大的减少了对内存表的匹配次数。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726165315601.png" alt="image-20250726165315601"></p><p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）。</p><table><thead><tr><th align="left">开销统计</th><th align="left">SNLJ</th><th>INLJ</th></tr></thead><tbody><tr><td align="left">外表扫描次数</td><td align="left">1</td><td>1</td></tr><tr><td align="left">内表扫描次数</td><td align="left">A</td><td>0</td></tr><tr><td align="left">读取记录数</td><td align="left">A+B * A</td><td>A+B(match)</td></tr><tr><td align="left">JOIN比较次数</td><td align="left">B * A</td><td>A*Index(Height)</td></tr><tr><td align="left">回表读取记录次数</td><td align="left">0</td><td>B(match) (if possible)</td></tr></tbody></table><p>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p></li><li><p><strong>Block Nested-Loop Join（块嵌套循环连接）</strong></p><p>如果存在索引，那么会使用index的方式进行ioin，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了!0的次数。为了减少被驱动表的<code>IO</code>次数，就出现了<code>Block Nested-Loop Join</code>的方式。<br>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了 **<code>join buffer缓冲区</code>**，将驱动表join相关的部分数据列(大小受join buffer的限制)缓存到join bufer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和ioinbuffer中的所有驱动表记录进行匹配(内存中操作)，将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><blockquote><p>注意：</p><p>这里缓存的不只是关联表的列，select后面的列也会缓存起来。</p><p>在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。</p></blockquote><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726165457696.png" alt="image-20250726165457696"></p><table><thead><tr><th align="left">开销统计</th><th align="left">SNLJ</th><th>INLJ</th><th>BNIJ</th></tr></thead><tbody><tr><td align="left">外表扫描次数</td><td align="left">1</td><td>1</td><td>1</td></tr><tr><td align="left">内表扫描次数</td><td align="left">A</td><td>0</td><td>A*used_column_size/join_buffer_size+1</td></tr><tr><td align="left">读取记录数</td><td align="left">A+B * A</td><td>A+B(match)</td><td>A+B*(A*used_column_size/join_buffer_size)</td></tr><tr><td align="left">JOIN比较次数</td><td align="left">B * A</td><td>A*Index(Height)</td><td>B*A</td></tr><tr><td align="left">回表读取记录次数</td><td align="left">0</td><td>B(match) (if possible)</td><td>0</td></tr></tbody></table><p>参数设置：</p><ul><li><p><strong><code>block_nested_loop</code><strong>：通过</strong>show variables like ‘%optimizer_switch%</strong> 查看 <strong>block_nested_loop</strong>状态。默认是开启的。</p></li><li><p><strong><code>join_buffer_size</code><strong>：驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认</strong>join_buffer_size=256k</strong>。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%join_buffer%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>join_buffer_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。</p></li><li><p><strong>Join小结</strong></p><ol><li><p><strong>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ</strong></p></li><li><p>永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）（小的度量单位指的是表行数 * 每行大小）</p></li><li><p>为被驱动表匹配的条件增加索引(减少内存表的循环匹配次数)</p></li><li><p>增大join buffer size的大小（一次索引的数据越多，那么内层包的扫描次数就越少）</p></li><li><p>减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）</p></li><li><p>Hash Join</p><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p><ul><li><p>Nested Loop：对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。</p></li><li><p>Hash Join是做<strong>大数据集连接</strong>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<strong>散列表</strong>，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p><ul><li><p>这种方式适合于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</p></li><li><p>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<strong>若干不同的分区</strong>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</p></li><li><p>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接（如WHERE A.COL1 = B.COL2），这是由Hash的特点决定的。</p></li></ul></li></ul><table><thead><tr><th>类别</th><th>Nested Loop</th><th>Hash Join</th></tr></thead><tbody><tr><td>使用条件</td><td>任何条件</td><td>等值连接(=)</td></tr><tr><td>相关资源</td><td>CPU、磁盘I/0</td><td>内存、临时空间</td></tr><tr><td>特点</td><td>当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果。</td><td>当缺乏索引或者索引条件模糊时，Hash Join比NestedLoop有效。在数据仓库环境下，如果表的纪录数多，效率高。</td></tr><tr><td>缺点</td><td>当索引丢失或者查询条件限制不够时，效率很低;当表的纪录数多时，效率低。</td><td>为建立哈希表，需要大量内存。第一次的结果返回较慢。</td></tr></tbody></table></li></ol></li></ol><hr><h1 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h1><p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即<strong>一个SELECT查询的结果作为另一个SELECT语句的条件</strong>。 子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作 。</p><p>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，<strong>子查询的执行效率不高。</strong>原因：</p><ol><li>执行子查询时，MySQL需要<strong>为内层查询语句的查询结果建立一个临时表</strong> ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</li><li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会 受到一定的影响。</li><li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li></ol><blockquote><p><strong>子查询原理：</strong></p><p>子查询是指在一个SQL语句中嵌套另一个完整的SQL查询。它可以作为主查询的一部分，也可以作为WHERE、FROM或HAVING子句的一部分。子查询的执行顺序是先执行子查询，然后将其结果作为外部查询的条件或数据源。</p></blockquote><h2 id="子查询优化成关联查询"><a href="#子查询优化成关联查询" class="headerlink" title="子查询优化成关联查询"></a>子查询优化成关联查询</h2><p><strong>性能：</strong></p><ul><li>数据量小、过滤条件简单时，子查询效率高一点；数据量大、过滤条件复杂时，关联查询效率高很多。综合考虑，建议关联查询。</li><li><strong>子查询的缺点：</strong><ul><li><strong>嵌套查询：</strong>子查询可能导致嵌套查询，一个子查询套另一个子查询，又套另一个子查询，这会增加查询的复杂性并降低性能。</li><li><strong>数据重复检索：</strong>子查询可能需要对数据进行多次检索，尤其是在相关子查询中。而连接则允许数据库一次性检索所有需要的数据，从而减少I/O操作和计算开销。</li></ul></li><li><strong>语义清晰度</strong>：还是建议使用关联查询，阅读起来更直白、明确，层次结构清晰，后期维护成本也越低，查询次数也一般更低一些。</li></ul><blockquote><p><strong>注意</strong>：如果见到<strong>子查询+范围查询</strong>的SQL，要直接进行优化，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查询每个学生的出生地</span><br><span class="line"><span class="keyword">SELECT</span> id, fullname, birth_city <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> id <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> person_id <span class="keyword">FROM</span> student);</span><br><span class="line"># 优化后</span><br><span class="line"><span class="keyword">SELECT</span> id, fullname, birth_city <span class="keyword">FROM</span> person p <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student s <span class="keyword">ON</span> p.id <span class="operator">=</span> s.person_id;</span><br></pre></td></tr></table></figure><p>因为范围查询会使索引失效，再加上使用子查询，优化前的SQL性能是很慢的。</p></blockquote><p><strong>结论</strong>：能够直接多表关联的尽量<strong>使用连接（JOIN）查询来替代子查询</strong>。连接查询 <strong>不需要建立临时表</strong> ，其 <strong>速度比子查询</strong> 要快 ，如果查询中使用索引的话，性能就会更好。子查询是一个SELECT查询的结果作为另一个SELECT语句的条件。</p><h2 id="多次查询代替子查询"><a href="#多次查询代替子查询" class="headerlink" title="多次查询代替子查询"></a>多次查询代替子查询</h2><p>在复杂SQL中，同一个子查询语句可能在整个SQL中多次出现，这就导致了性能浪费。这种情况下，结合Java代码多次查询而不用子查询，可以使这个重复子查询语句只查一次，从而提高性能。</p><blockquote><p><strong>误区</strong>：通常可能认为多次查询肯定没一次查询快，因为MySQL查询两次肯定就有两次I/O调用过程，而查询一次只有一次调用过程。</p><p>如果是简单SQL，只调用了一次子查询，那肯定是子查询快，当同一个子查询语句可能在整个SQL中多次出现时，用Java代码，肯定是更快的，虽然IO次数多，但这么多次子查询缩减成了一次，性能是快了的。</p></blockquote><p><strong>结论</strong>：不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</p><h2 id="临时表代替子查询"><a href="#临时表代替子查询" class="headerlink" title="临时表代替子查询"></a>临时表代替子查询</h2><p>如果一个复杂SQL中，多次用到了同一个子查询，可以尝试将其抽离出来，优化成临时表。这样可以避免重复计算、减少查询次数，从而提高查询性能。</p><p>并且可维护性也有效提高，每次修改时只需要修改这一个临时表，而不需要手动一个个修改子查询语句。</p><p>​    </p><blockquote><p>最终结论：<strong>尽量不要使用NOT IN或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</strong></p></blockquote><hr><h1 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h1><h2 id="排序优化建议"><a href="#排序优化建议" class="headerlink" title="排序优化建议"></a>排序优化建议</h2><blockquote><p><strong>问题</strong>：在 WHERE 条件字段上加索引，但是为什么在 <strong>ORDER BY 字段上还要加索引</strong>呢？</p></blockquote><p>MySQL支持两种排序方式： </p><ul><li><strong>Index排序：</strong>索引排序中，索引可以保证数据的有序性，不需要再进行排序，<strong>效率更高，推荐使用</strong>。</li><li><strong>FileSort排序：</strong>FileSort 排序则一般在<strong>内存中进行排序</strong>，占用<strong>CPU较多</strong>。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，<strong>效率较低。</strong></li></ul><p><strong>优化建议：</strong></p><ul><li><strong>优化器自动选择排序方式：</strong>MySQL支持索引排序和FileSort排序，索引保证记录有序性，性能高，推荐使用。FileSort排序是内存中排序，数据量大时产生临时文件在磁盘里排序，效率低还占用大量CPU。并不是说FileSort一定效率低，一些情况它可能效率高。例如没覆盖索引的左模糊、“不等于”查询，全表扫描效率比索引遍历再回表更高。</li><li>要符合最左前缀：where后条件和order by字段创建联合索引，顺序要需要符合最左前缀。例如索引(a,b,c)，查询where a=1 order by b,c。</li><li><strong>范围查询右边排序索引失效：</strong>例如索引(a,b,c)，查询where a&gt;1 order by b,c，导致b,c排序不能走索引，需要filesort。</li><li><strong>要么全升序要么全降序：</strong>排序顺序必须要么全部DESC，要么全部ASC。乱序会导致索引失效。</li><li><strong>待排序数量大时会导致索引失效：</strong>待排序数据量大约超过一万个，就不走索引走filesort了。建议用limit和where过滤，减少数据量。数据量很大时，索引排序完需要回表查所有数据，性能很差，还不如FileSort在内存中排序效率高。并不是说使用limit一定会走索引排序，关键看的是数据量，数据量过大时优化器会使用FileSort排序。</li><li><strong>优先范围字段加索引：</strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。这样即使范围查询导致排序索引失效，效率依然比只索引排序字段时候高。如果只能过滤一点点，那就优先索引放到排序字段上。</li><li><strong>调优FileSort ：</strong>无法使用 Index 排序时，需要对 FileSort 方式进行调优。例如增大sort_buffer_size（排序缓冲区大小）和 max_length_for_sort_data（排序数据最大长度）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 不加索引直接走filesort排序</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid;</span><br><span class="line"># 加索引后，<span class="keyword">order</span> <span class="keyword">by</span> 时不limit导致数据量过大,从而索引失效：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age,classId,name);</span><br><span class="line"># 索引失败。没有limit</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid;</span><br><span class="line"># 索引成功，key_len为<span class="number">73</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid LIMIT <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><p><strong>order by 时顺序错误，索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引age,classid,stuno</span><br><span class="line"># <span class="keyword">call</span> proc_drop_index(<span class="string">&#x27;atguigudb2&#x27;</span>,<span class="string">&#x27;student&#x27;</span>);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_stuno <span class="keyword">ON</span> student (age,classid,stuno);</span><br><span class="line"># 索引失效，不符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid LIMIT <span class="number">10</span>;</span><br><span class="line"># 索引失效，不符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid,name LIMIT <span class="number">10</span>;</span><br><span class="line"># 索引失效，不符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,stuno;</span><br><span class="line"># 全走索引，虽然不符合最左前缀，但因为查询量小，优化器先排序三个字段，再<span class="keyword">where</span>找<span class="number">10</span>个返回。</span><br><span class="line"># 优化器认为索引比filesort效率高，就用了索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,stuno LIMIT <span class="number">10</span>;</span><br><span class="line"># 索引成功，符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid,stuno LIMIT <span class="number">10</span>;</span><br><span class="line"># 索引成功，符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>order by 时规则不一致，索引失效（顺序错，不索引；方向反，不索引）</strong></p><p>必须符合最左前缀和“全升序或全降序”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引age,classid,stuno</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_stuno <span class="keyword">ON</span> student (age,classid,stuno);</span><br><span class="line"># 没符合“全升序或全降序”，索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>,classid <span class="keyword">ASC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 没符合最左前缀，索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid <span class="keyword">DESC</span>,name <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 没符合“全升序或全降序”，索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>,classid <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 符合最左前缀，符合“全升序或全降序”，索引成功</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>,classid <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>limit数据量小时，不满足最左前缀也可能走索引，先排序再where筛选。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_stuno <span class="keyword">ON</span> student (age,classid,stuno);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age,classId,name);</span><br><span class="line"># 都走了索引。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid LIMIT <span class="number">10</span>;</span><br><span class="line"># 都走了索引。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid,name;</span><br><span class="line"># 都没用索引，不符合最左前缀</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">45</span> <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br><span class="line"># 全走了索引。因为limit数据量小，优化器直接先用排序字段索引排序，然后再<span class="keyword">where</span>筛选<span class="number">10</span>个</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">45</span> <span class="keyword">order</span> <span class="keyword">by</span> age limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>范围查找导致索引失效</strong>：下面有索引(userDbid,addressDbid,createTime)，userDbid,addressDbid走了索引，因为addressDbid是范围查找，导致createTime索引失败。</p><h2 id="范围查询时索引字段选择"><a href="#范围查询时索引字段选择" class="headerlink" title="范围查询时索引字段选择"></a>范围查询时索引字段选择</h2><ol><li><strong>mysql自动选择最优的方案：</strong>两个索引同时存在，mysql自动选择最优的方案。（对于这个例子，mysql选择 idx_age_stuno_name）。但是， 随着数据量的变化，选择的索引也会随之变化的。</li><li><strong>过滤比例高时优先过滤字段加索引：</strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</li></ol><blockquote><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。</p></blockquote><p>案例分析：<strong>查询年龄为30岁的，且学生编号小于101000的学生，按用户名称排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME ;</span><br><span class="line"># 结论：type 是 <span class="keyword">ALL</span>，即最坏的情况。Extra 里还出现了 <span class="keyword">Using</span> filesort,也是最坏的情况。优化是必须的。</span><br></pre></td></tr></table></figure><p><strong>为了去掉 filesort 创建索引，查询效率高了一点</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age,NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME;</span><br><span class="line">只有age走了索引： 优化掉了 <span class="keyword">using</span> filesort</span><br></pre></td></tr></table></figure><p><strong>尽量让where的过滤条件和排序使用上索引，发现查询效率更高</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 建一个三个字段的组合索引，发现<span class="keyword">using</span> filesort依然存在：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_stuno_name <span class="keyword">ON</span> student (age,stuno,NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME;</span><br></pre></td></tr></table></figure><p>发现<code>using filesort</code>依然存在，所以name并没有用到索引，而且type还是range光看名字其实并不美好。因为<strong>stuno是一个范围过滤</strong>，所以索引后面的字段不会在使用索引了 。但分析发现<code>filesort</code>运行速度比索引还快，而且快了很多，几乎一瞬间就出现了结果。</p><p><strong>原因</strong>：所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对的 <code>stuno&lt;101000</code> 这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</p><h2 id="filesort-算法"><a href="#filesort-算法" class="headerlink" title="filesort 算法"></a>filesort 算法</h2><h3 id="双路排序和单路排序"><a href="#双路排序和单路排序" class="headerlink" title="双路排序和单路排序"></a>双路排序和单路排序</h3><p><strong>双路排序 （慢）</strong></p><ul><li><strong>MySQL 4.1之前</strong>是使用双路排序 ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段 。</li></ul><p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种 改进的算法，就是单路排序。</p><p><strong>单路排序 （快）</strong></p><p>从磁盘读取查询需要的 所有列 ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p><p><strong>结论及引申出的问题</strong></p><ul><li>由于单路是后出的，<strong>总体而言好过双路</strong></li><li>但是用单路有问题<ul><li>在sort_buffer中，单路要比多路多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了<strong>sort_buffer</strong>的容量，导致每次只能取<strong>sort_buffer</strong>容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次I/O。</li><li>单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</li></ul></li></ul><h3 id="调优filesort"><a href="#调优filesort" class="headerlink" title="调优filesort"></a><strong>调优</strong>filesort</h3><ol><li><p><strong>尝试提高 sort_buffer_size</strong></p><p>不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程<br>(connection)的1M-8M之间调整。MySQL5.7，InnoDB存储引擎默认值是1048576字节，1MB。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="operator">%</span>sort_buffer_size<span class="operator">%</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">+---------------------------+-----------+</span></span><br><span class="line"><span class="string">| Variable_name             | Value     |</span></span><br><span class="line"><span class="string">+---------------------------+-----------+</span></span><br><span class="line"><span class="string">| innodb_sort_buffer_size   | 1048576   |</span></span><br><span class="line"><span class="string">| myisam_sort_buffer_size   | 8388608   |</span></span><br><span class="line"><span class="string">| sort_buffer_size          | 262144    |</span></span><br><span class="line"><span class="string">+---------------------------+-----------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>尝试提高 max_length_for_sort_data</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%max_length_for_sort_data%&#x27;</span>; # 默认<span class="number">1924</span>字节</span><br></pre></td></tr></table></figure><p>提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort buffer size的概率就增大，明显症状是高的磁盘IO活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sort data，使用双路算法，否则使用单路算法.1024-8192字节之间调整。</p></li><li><p><strong>Order by 时select * 是一个大忌。最好只Query需要的字段。</strong></p><ul><li>当Query的字段大小总和小于<code>max_ength_for_sort_data</code>，而且排序字段不是TEXTBLOB 类型时，会用改进后的算法–单路排序，否则用老算法——多路排序。</li><li>两种算法的数据都有可能超出<code>sort_bufer_size</code>的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/0，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。</li></ul></li></ol><hr><h1 id="分组优化"><a href="#分组优化" class="headerlink" title="分组优化"></a>分组优化</h1><ul><li><p><strong>跟排序优化近似：</strong>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</p></li><li><p><strong>最左前缀：</strong>group by 先排序再分组，遵照索引建的最佳左前缀法则</p></li><li><p><strong>调优FileSort</strong>：当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</p></li><li><p><strong>where效率高于having</strong>，能写在where限定的条件就不要写在having中了。where是分组前过滤，having是分组后过滤。</p></li><li><p><strong>尽量不排序分组、节省cpu：</strong>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。<strong>Order by、group by、distinct这些语句较为耗费CPU</strong>，数据库的CPU资源是极其宝贵的。</p></li><li><p><strong>使用limit：</strong>包含<code>order by、group by、distinct</code>的查询语句，where条件过滤出的结果集请保持1000行以内，否则SQL会很慢。</p></li></ul><hr><h1 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h1><h2 id="深分页查询优化"><a href="#深分页查询优化" class="headerlink" title="深分页查询优化"></a>深分页查询优化</h2><p>一般分页查询时，通过创建<strong>覆盖索引</strong>能够比较好地提高性能。</p><p><strong>目前问题：</strong> offset非常大时，需要查询大量无用的数据量再分页，性能差。</p><p>一个常见问题：limit 2000000,10。此时需要MySQL排序前200000010 记录，仅仅返回2000000~2000010 的记录，其他记录丢弃，查询排序的代价常大。并且<code>select *</code> 需要回表，更耗费时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 直接查询 limit <span class="number">2000000</span>,<span class="number">10</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">2000000</span>,<span class="number">10</span>; </span><br><span class="line"># 优化方案一：主键自增的表：直接查范围之后的<span class="number">10</span>个数据。可以把Limit 查询转换成某个位置的查询 。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">2000000</span> LIMIT <span class="number">10</span>;</span><br><span class="line"># 优化方案二：主键不自增的表：当前表内连接排序截取后的主键表，连接字段是主键。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t,(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure><blockquote><p> 也可以用子查询，子查询优化成关联查询。</p></blockquote><h2 id="带排序的深分页优化"><a href="#带排序的深分页优化" class="headerlink" title="带排序的深分页优化"></a>带排序的深分页优化</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 优化前：查询根据age逆序排列的深分页</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span> LIMIT <span class="number">2000000</span>,<span class="number">10</span>; </span><br><span class="line"># 优化方案一：主键不有序的表根据主键排序，先给主键分页，然后内连接原表：当前表内连接排序截取后的主键表，连接字段是主键。因为查主键是在聚簇索引树查，不用回表，排序和分页很快</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t1,(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">desc</span> LIMIT <span class="number">2000000</span>,<span class="number">10</span>) t2 </span><br><span class="line"><span class="keyword">WHERE</span> t1.id<span class="operator">=</span>t2.id</span><br><span class="line"># 优化方案二：主键有序的表根据非主键排序，可以得到上一页最后一条记录x，那么目标页码的所有记录id都比x.id小（因为逆序，且排序依据其实是age,id），目标页码的所有记录age都比x.age小或等于。需要传参数。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> \#&#123;x.id&#125; <span class="keyword">AND</span> age <span class="operator">&lt;=</span> \#&#123;x.age&#125; <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">‌数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，目标是将低效SQL语句转换为高效等效语句。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库-优化</title>
    <link href="https://southernfish.github.io/2025/07/26/database/db-mysql-4-optimize/"/>
    <id>https://southernfish.github.io/2025/07/26/database/db-mysql-4-optimize/</id>
    <published>2025-07-26T05:30:36.000Z</published>
    <updated>2025-07-28T10:27:55.449Z</updated>
    
    <content type="html"><![CDATA[<p>数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，核心目标是将低效SQL语句转换为高效等效语句。人工智能自动优化技术通过重写SQL语句实现性能提升。优化技术演变历经三代工具：第一代解析执行计划，第二代推荐索引优化，第三代提出语法改进建议。优化策略贯穿数据库生命周期，其中设计阶段优化成本最低且收益最大。</p><blockquote><p>原文链接：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130355955">MySQL高级篇——性能分析工具</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/131059110">【MySQL调优】如何进行MySQL调优？一篇文章就够了！</a></p></blockquote><h1 id="数据库服务器的优化步骤"><a href="#数据库服务器的优化步骤" class="headerlink" title="数据库服务器的优化步骤"></a>数据库服务器的优化步骤</h1><p>在数据库调优中，目标是<strong>响应时间更快，吞吐量更大</strong>。利用宏观的<strong>监控工具</strong>和微观的<strong>日志分析</strong>可以帮我们快速找到调优的思路和方式。 </p><p><strong>调优流程：</strong></p><ol><li><strong>SHOW STATUS</strong>观察服务器状态，是否存在周期性波动；如果存在的话就<strong>缓存优化</strong>；</li><li>如果还存在不规则延迟或卡顿的话，就<strong>开启慢查询、explan分析查询语句</strong>；</li><li>如果发现sql等待时间长，就<strong>调优服务器参数</strong>；如果发现sql执行时间长，就<strong>索引优化、表优化；</strong></li><li>如果还存在不规则延迟或卡顿的话，就<strong>观察</strong>sql查询是否到瓶颈了；是的话就<strong>读写分离、分库分表。</strong></li></ol><p><strong>三种分析工具（SQL调优三步骤）：</strong>慢查询、EXPLAN、SHOW PROFLING</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726121610266.png" alt="image-20250726121610266"></p><p>整个流程划分成了观察（Show status） 和行动（Action） 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</p><p>优化方式<strong>硬件，系统配置，数据库表结构，SQL及索引</strong>，从左至右效果渐好，从右至左，成本渐高。</p><hr><h1 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数"></a>查看系统性能参数</h1><h2 id="SHOW-STATUS-LIKE-‘参数’"><a href="#SHOW-STATUS-LIKE-‘参数’" class="headerlink" title="SHOW STATUS  LIKE ‘参数’"></a>SHOW STATUS  LIKE ‘参数’</h2><p>在MySQL中，可以使用<strong>SHOW STATUS</strong> 语句查询一些MySQL<strong>数据库服务器</strong>的<strong>性能参数</strong>、执行频率。</p><p>SHOW STATUS语句语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p> 中括号代表可省略。</p><p>一些常用的性能参数如下：</p><ul><li><p><strong>Connections：</strong>连接MySQL服务器的次数。</p></li><li><p><strong>Uptime：</strong>MySQL服务器的上线时间。重启服务器后会重置。</p></li><li><p><strong>Slow_queries：慢查询的次数</strong>。查询时长超过指定时间，次数越少越好。</p></li><li><p>Innodb_rows_read：Select查询返回的行数</p></li><li><p>Innodb_rows_inserted：执行INSERT操作插入的行数</p></li><li><p>Innodb_rows_updated：执行UPDATE操作更新的行数</p></li><li><p>Innodb_rows_deleted：执行DELETE操作删除的行数</p></li><li><p>Com_select：查询操作的次数。</p></li><li><p>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</p></li><li><p>Com_update：更新操作的次数。</p></li><li><p>Com_delete：删除操作的次数。</p></li><li><p><strong>last_query_cost</strong>：查询优化器上一个查询的成本，最近一次删除用到数据页数量。</p></li></ul></blockquote><h2 id="查看SQL的查询成本"><a href="#查看SQL的查询成本" class="headerlink" title="查看SQL的查询成本"></a>查看SQL的查询成本</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br></pre></td></tr></table></figure><p>SQL查询是一个动态的过程，从页加载的角度来看:</p><ol><li><p><strong>缓冲池查询效率优于从磁盘查</strong></p><p>如果页就在数据库<strong>缓冲池</strong>中，那么<strong>效率是最高</strong>的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</p><blockquote><p>MySQL的缓冲池被分为多个不同的缓存池，其中包括：</p><ul><li>查询缓存：用来缓存查询结果。</li><li>InnoDB缓存池：用来缓存热点表和索引数据页。</li><li>MyISAM缓存池：用来缓存表数据块。</li></ul><p>当缓冲池中已经存储了较多的数据时，MySQL会使用一种叫做缓冲池替换算法的方法，将部分缓存数据替换出去，以腾出空间为新的数据做缓存。</p><p><strong>MySQL的缓冲池使用的是LRU（最近最少使用）算法</strong>，它会优先缓存最近使用的数据。当缓冲池的空间不足时，MySQL会将最不常用的数据从缓冲池中替换出去，以腾出空间缓存新的数据。</p></blockquote></li><li><p><strong>批量顺序查询平均下来每页查询更高</strong></p><p>如果从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用<strong>顺序读取</strong>的方式，<strong>批量对页进行读取</strong>，<strong>平均一页的读取效率就会提升</strong>很多，甚至要快于单个页面在内存中的随机读取。</p><p>首先要考虑数据存放的位置，如果是<strong>经常使用的数据就要尽量放到缓冲池</strong>中，其次可以充分利用磁盘的吞吐能力，一次性<strong>批量读取数据</strong>，这样单个页的读取效率也就得到了提升。 </p><blockquote><p><strong>测试缓冲池缓存已使用的表和索引到内存中，效率高：</strong>查询900001和 900001~9000100查询成本差很多，查询速度差不多</p><p>查询 <strong>id=900001</strong> 的记录，然后看下查询成本，可以直接在聚簇索引上进行查找：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询 id<span class="operator">=</span><span class="number">900001</span> 的记录</span><br><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>; </span><br><span class="line"># 运行结果（<span class="number">1</span> 条记录，运行时间为 <span class="number">0.042</span>s ）</span><br><span class="line"># 查询优化器的成本，实际上 只需要检索一个页</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">1.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br></pre></td></tr></table></figure><p>查询 id 在 <strong>900001</strong> 到 <strong>9000100</strong> 之间的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询 id 在 <span class="number">900001</span> 到 <span class="number">9000100</span> 之间的记录</span><br><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br><span class="line"># 运行结果（<span class="number">100</span> 条记录，运行时间为 <span class="number">0.046</span>s ）：</span><br><span class="line"># 查询优化器的成本，这时我们大概需要进行 <span class="number">20</span> 个页的查询。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">21.134453</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure><p>虽然页的数量是刚才的 20 倍，但<strong>查询的效率没有明显变化</strong>，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了<strong>顺序读取</strong>的方式将页面一次性加载到<strong>缓冲池</strong>中，然后再查找。虽然<strong>页数量</strong>（last_query_cost）<strong>增加了不少</strong>，但是通过缓冲池的机制，并<strong>没有增加多少查询时间。</strong></p><p><strong>为什么第二次是直接从缓冲池查</strong></p><p>因为 MySQL 缓存淘汰策略 LRU 最近最少使用，会优先缓存最近查询数据，优先淘汰最近最少使用数据。</p><p><strong>使用场景</strong>：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p></blockquote></li></ol><hr><h1 id="定位执行慢的-SQL：慢查询日志"><a href="#定位执行慢的-SQL：慢查询日志" class="headerlink" title="定位执行慢的 SQL：慢查询日志"></a>定位执行慢的 SQL：慢查询日志</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MySQL的慢查询日志，用来<strong>记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过 <code>long-query_time</code> 值的SQL，则会被记录到慢查询日志中。 long_query_time的默认值为 10，意思是运行10秒以上(不含10秒)的语句，认为是超出了最大忍耐时间值。</p><p>主要作用是发现执行时间特别长的 SOL 查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，结合explain进行全面分析，以解决问题。</p><p>默认情况下，MySQL数据库 没有开启慢查询日志 ，需要我们手动来设置这个参数。<strong>如果不是调优需要的话，一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的<strong>性能影响</strong>。慢查询日志支持将日志记录写入文件 。</p><h2 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h2><p>利用监控工具（例如<code>Prometheus+Grafana</code>）监控MySQL，发现查询性能变慢，报警提醒运维人员</p><p><strong>常见监控工具：</strong></p><ol><li><strong>MySQL Enterprise Monitor：</strong>由Oracle提供，它提供实时和历史的MySQL性能监控（查询性能、服务器状态、数据库复制等）。</li><li><strong>Percona Monitoring and Management：</strong>由Percona提供的开源工具，提供性能监控、查询分析、数据库配置等功能。</li><li><strong>MyTOP：</strong>一个基于命令行的工具，用于实时监控MySQL数据库的性能。</li><li><strong>MySQL Performance Schema：</strong>MySQL自带的性能监控工具，可以通过查询Performance Schema表来获取有关数据库性能和资源利用情况的详细信息。</li><li><strong>Nagios：</strong>一个通用的网络监控工具，可以使用插件来监控MySQL数据库的各种指标。</li><li><strong>Zabbix：</strong>一个通用的网络监控工具，可以使用插件来监控MySQL数据库的各种指标。</li><li><strong>Datadog：</strong>一个云端监控服务，提供对MySQL数据库的性能和状态的实时监控。</li><li><strong>Prometheus + Grafana：</strong>一组流行的开源工具，通过Prometheus监控MySQL数据库，使用Grafana创建仪表板进行可视化。</li></ol><h2 id="开启慢查询日志参数"><a href="#开启慢查询日志参数" class="headerlink" title="开启慢查询日志参数"></a>开启慢查询日志参数</h2><ol><li><p><strong>慢查询是否开启</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 慢查询是否开启</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> low_query_log   <span class="operator">|</span> OFF       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>开启慢查询日志slow_query_log</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 开启慢查询日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"># 查看下慢查询日志是否开启，以及慢查询日志文件的位置（默认为MySQL的数据目录）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> low_query_log          <span class="operator">|</span> <span class="keyword">ON</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> low_query_log_file   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu01<span class="operator">-</span>slow.log      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修改慢查询阈值long_query_time</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看慢查询的时间阈值</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"># 查看全局慢查询的时间阈值：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name     <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time   <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-----------+</span></span><br></pre></td></tr></table></figure><p><strong>临时修改慢查询的时间阈值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 当前回话</span><br><span class="line"><span class="keyword">set</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line"># 全局</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></table></figure><blockquote><p>对于 “global” 选项，是全局级别的配置参数。它可以在 MySQL 服务器启动时或 MySQL 安装时在 MySQL 配置文件中设置，或者通过 SET GLOBAL 命令在运行时更改。全局级别的配置参数对所有的 MySQL 连接都有效。</p></blockquote><p><strong>永久修改</strong>（重启数据库后依然有效，<strong>不建议永久修改</strong>，仅在优化时候打开，慢查询拖性能） ：修改<code>my.cnf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=ON <span class="comment"># 开启慢查询日志的开关</span></span><br><span class="line">slow_query_log_file=/var/lib/mysql/atguigu-slow.log <span class="comment">#慢查询日志的目录和文件名信息</span></span><br><span class="line">long_query_time=3 <span class="comment">#设置慢查询的闽值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 测试发现：设置<span class="keyword">global</span>的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语句</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">1</span>;                        # 设置全局慢查询阈值<span class="number">1</span>s</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;        # 全局<span class="number">1</span>s</span><br><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;            # 当前会话<span class="number">10</span>s</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="查看慢查询次数"><a href="#查看慢查询次数" class="headerlink" title="查看慢查询次数"></a>查看慢查询次数</h2><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h2><p><code>mysqldumpslow</code>是用于分析MySQL慢查询日志的命令行工具。通过解析慢查询日志，可以了解到数据库的性能问题，从而进行优化。</p><blockquote><p><strong>查看mysqldumpslow的帮助信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow <span class="comment">--help</span></span><br></pre></td></tr></table></figure><p><strong>mysqldumpslow</strong> 命令的具体参数如下：</p><ul><li>-a: 不将数字抽象成N，字符串抽象成S</li><li><strong>-s: 是表示按照何种方式排序：</strong><ul><li>c: 访问次数</li><li>l: 锁定时间</li><li>r: 返回记录</li><li><strong>t: 查询时间</strong></li><li>al:平均锁定时间</li><li>ar:平均返回记录数</li><li><strong>at:平均查询时间 （默认方式）</strong></li><li>ac:平均查询次数</li></ul></li><li><strong>-t: 即为返回前面多少条的数据；</strong></li><li>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</li></ul></blockquote><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 按照查询时间排序，查看最慢的<span class="number">10</span>个查询，可以使用如下命令</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 如果需要筛选特定的查询，可以使用 `<span class="operator">-</span>g` 参数</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g &quot;SELECT * FROM user&quot; <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 解析：该命令表示按照时间排序，显示最慢的<span class="number">10</span>个查询，其中关键字为 &quot;SELECT * FROM user&quot;。</span><br><span class="line"></span><br><span class="line"># 重新返回记录集最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 查询访问次数最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s c <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 查询按照时间排序的前<span class="number">10</span>条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g &quot;left join&quot; <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line"># 建议在使用这些命令时结合 <span class="operator">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log <span class="operator">|</span> more</span><br></pre></td></tr></table></figure><h2 id="关闭慢查询日志"><a href="#关闭慢查询日志" class="headerlink" title="关闭慢查询日志"></a>关闭慢查询日志</h2><p>MySQL服务器停止慢查询日志功能有两种方法：</p><p><strong>方式1：永久性方式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">#slow_query_log=OFF</span></span><br></pre></td></tr></table></figure><p><strong>mysql默认关闭慢查询日志</strong>，或者，把slow_query_log一项注释掉 或 删除</p><p>重启MySQL服务，执行如下语句查询慢日志功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;                 # 查询慢查询日志所在目录</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;     # 查询超时时长</span><br></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><p>使用SET语句来设置。停止MySQL慢查询日志功能，具体SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span>off;                 # golbal全局有效。</span><br><span class="line"># 重启MySQL服务，使用<span class="keyword">SHOW</span>语句查询慢查询日志功能信息，发现慢查询日志已经关闭成功。</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;                # 发现关闭成功</span><br><span class="line"># 慢查询阈值</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;       # <span class="number">10</span>s。前面改的时候没有加<span class="keyword">global</span>，所以重启服务器后阈值恢复<span class="number">10</span>s。</span><br></pre></td></tr></table></figure><h2 id="删除慢查询日志"><a href="#删除慢查询日志" class="headerlink" title="删除慢查询日志"></a>删除慢查询日志</h2><p><strong>手动删除</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用<span class="keyword">SHOW</span>语句显示慢查询日志信息，会得到慢查询日志的目录，在该目录下 手动删除慢查询日志文件 即可。</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> `slow_query_log<span class="operator">%</span>`;</span><br></pre></td></tr></table></figure><p><strong>自动删除</strong> </p><p>使用命令 mysqladmin flush-logs 来重新生成查询日志文件，执行完毕会在数据目录下重新生成慢查询日志文件。</p><p><strong>重新生成慢查询日志文件（直接删除旧的）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs slow</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong></p><p>慢查询日志都是使用<code>mysqladmin flush-logs</code>命令来<strong>删除重建</strong>的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p></blockquote><hr><h1 id="定位慢查询语句、查看-SQL-执行成本：show-profile"><a href="#定位慢查询语句、查看-SQL-执行成本：show-profile" class="headerlink" title="定位慢查询语句、查看 SQL 执行成本：show profile"></a>定位慢查询语句、查看 SQL 执行成本：show profile</h1><p>show profile 是 MySQL 提供的可以用来分析<strong>当前会话中</strong> <strong>SQL 都做了什么、执行的资源消耗工具的情况</strong>，可用于 sql 调优的测量。默认情况下处于关闭状态，并保存最近15次的运行结果。</p><p><code>SHOW PROFILE</code> 是一个用于查看会话执行的查询的性能分析信息的 MySQL 命令。它可以帮助开发人员和 DBA <strong>分析查询语句执行时的瓶颈</strong>，并找出哪些部分需要优化。 </p><blockquote><p><strong>SHOW VARIABLES</strong> 显示了 MySQL 服务器的当前配置变量，包括全局配置变量和会话配置变量，以及它们的值。SHOW VARIABLES 用于查看 MySQL 配置系统参数的详细信息并进行系统参数的修改。<br><strong>SHOW STATUS</strong> 显示服务器的性能参数，包括连接、线程、查询等方面的状态信息，以及它们的值。 </p></blockquote><p><strong>查看配置是否开启profile：</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"># 开启 <span class="keyword">show</span> profile</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> profiling         <span class="operator">|</span> <span class="keyword">ON</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"># 执行查询语句</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees;</span><br><span class="line"># <span class="keyword">show</span> profiles; 查询当前会话所有查询语句持续时间</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br><span class="line"># <span class="keyword">show</span> profile;查询当前会话最近<span class="keyword">sql</span>语句的执行成本</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profile;</span><br><span class="line"># 查询指定QueryID的cpu信息</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="number">2</span>;</span><br><span class="line"># 在<span class="keyword">SHOW</span> PROFILE 中可以查看不同部分的开销，比如 cpu、block.io 等</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>show profile的常用查询参数：</strong></p><ol><li><p>ALL：显示所有的开销信息。</p></li><li><p>BLOCK IO：显示块IO开销。</p></li><li><p>CONTEXT SWITCHES：上下文切换开销。</p></li><li><p>CPU：显示CPU开销信息。</p></li><li><p>IPC：显示发送和接收开销信息。</p></li><li><p>MEMORY：显示内存开销信 息。</p></li><li><p>PAGE FAULTS：显示页面错误开销信息。</p></li><li><p>SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。</p></li><li><p>SWAPS：显示交换次数开销信息。</p></li></ol><p><strong>日常开发需注意：</strong></p><ol><li><p> <strong>converting HEAP to MyISAM</strong>: 查询结果太大，内存不够，数据往磁盘上搬了。</p></li><li><p><strong>Creating tmp table</strong>：创建临时表。先拷贝数据到临时表，用完后再删除临时表。</p></li><li><p><strong>Copying to tmp table on disk</strong>：把内存中临时表复制到磁盘上，警惕！</p></li><li><p><strong>locked</strong>。</p></li></ol><p>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。</p><p><strong>注意：</strong>不过<strong>SHOW PROFILE命令将被弃用</strong>，但可以从 <strong>information_schema 中的 profiling 数据表</strong>进行查看。</p></blockquote><hr><h1 id="执行计划表：EXPLAIN"><a href="#执行计划表：EXPLAIN" class="headerlink" title="执行计划表：EXPLAIN"></a>执行计划表：EXPLAIN</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL的EXPLAIN是一种<strong>分析SQL语句查询性能的工具</strong>。当我们在MySQL中执行SELECT语句时，EXPLAIN可以帮助我们<strong>查看MySQL如何执行这个查询，即执行计划</strong>，包括<strong>使用哪些索引、选择哪些表、以及如何读取数据</strong>等信息。</p><p>EXPLAIN的使用方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> my_column <span class="operator">=</span> <span class="string">&#x27;my_value&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行以上命令后，MySQL会返回一张查询执行计划表，其中包含了MySQL执行这个查询的详细信息。通过分析查询执行计划表<strong>了解查询的性能瓶颈</strong>，以及如何优化查询语句，从而提高查询性能。  </p><p><strong>注意：</strong> </p><ul><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>部分统计信息是估算的，并非精确值</li></ul><blockquote><p><strong>MySQL中有专门负责优化SELECT语句的优化器模块</strong></p><p><strong>主要功能</strong>：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供<strong>它认为最优的 执行计划</strong> (他认为最优的数据检索方式，但不见得是DBA（数据库管理员）认为是最优的，这部分最耗费时间)。</p></blockquote><p><strong>能做什么？</strong></p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p><strong>官网介绍</strong></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">MySQL :: MySQL 5.7 Reference Manual :: 8.8.2 EXPLAIN Output Format</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">MySQL :: MySQL 8.0 Reference Manual :: 8.8.2 EXPLAIN Output Format</a></p><p><strong>版本情况</strong></p><ul><li><strong>MySQL 5.6.3以前只能 EXPLAIN SELECT</strong> ；<strong>MYSQL 5.6.3以后</strong>就可以 EXPLAIN SELECT，<strong>UPDATE， DELETE</strong></li><li>在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和 filtered中的信息。</li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line"># 一般指定在查询时不使用缓存</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE select_options</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure><p>除了以 SELECT 开头的查询语句，其余的 DELETE、INSERT、REPLACE 以及UPDATE 语句等都可以加上EXPLAIN</p><h2 id="执行计划表介绍"><a href="#执行计划表介绍" class="headerlink" title="执行计划表介绍"></a>执行计划表介绍</h2><h3 id="执行计划各个列的作用（概述）"><a href="#执行计划各个列的作用（概述）" class="headerlink" title="执行计划各个列的作用（概述）"></a>执行计划各个列的作用（概述）</h3><table><thead><tr><th>列</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>每个SELECT子句或者join操作都会被分配一个唯一的编号，编号越小优先级越高，id相同的语句可以被认为是一组。id为NULL表示独立的子查询，子查询优先级都比主查询高。</td></tr><tr><td>select_type</td><td>查询的类型。主查询(primary)、普通查询(simple)、联合查询、子查询(subquery)、derived(from表临时子查询)、union(union后查询)、union result()</td></tr><tr><td>table</td><td>表名。显示当前这行的数据是哪个表的。</td></tr><tr><td>partitions</td><td>匹配的分区信息。如果表未分区则为NULL。</td></tr><tr><td><strong>type</strong></td><td><strong>访问类型，根据索引、全表扫描等方法来执行查询的优化策略。</strong>all（全表扫描），ref（命中非唯一索引），index(没命中索引，扫描索引树再回表)、const（命中主键/唯一索引）、range(范围索引查询)、index_merge(使用多个索引)、 system(一行记录时,快速查询)。</td></tr><tr><td>possible_keys</td><td>可能用到的索引。列出MySQL能够使用哪些索引来查询。如果该列只有一个possible_keys，通常意味着这个查询是高效的。如果这个列有多个possible_keys，并且MySQL只使用了其中一个，则需要考虑是否需要在该列上增加一个联合索引。</td></tr><tr><td><strong>key</strong></td><td><strong>实际上使用的索引。</strong>如果没有明确的指定KEY，MySQL会根据查询条件自动选择最优的索引。</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息。常量等值查询const, 表达式/函数使用到时func,关联查询显示关联字段名</td></tr><tr><td><strong>rows</strong></td><td>预估的需要读取的记录条数。数值越小越好，表示结果集越小，查询越高效。</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比。这个值越小越好，说明可通过索引直接返回数据。</td></tr><tr><td><strong>Extra</strong></td><td>额外信息。看有没有走索引，还是全表扫描了。一般搭配type字段看。Using index(使用到覆盖索引)、Using where(未完全命中索引)、Using temporary(临时表存储结果集.排序/分组会使用)、Using filesort(排序操作未用索引)、Using join buffer(连接条件未用索引)、Impossible where(where约束语句可能有问题导致没有结果集)</td></tr></tbody></table><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p><strong>select_type：</strong>查询的类型，有以下几种取值：</p><ul><li>SIMPLE：不使用子查询或UNION，不包含UNION ALL的简单SELECT查询。</li><li>PRIMARY：最外层的SELECT查询。</li><li>DERIVED：以FROM子句中的子查询方式出现的SELECT语句。</li><li>UNION：UNION中的第二个或之后的SELECT查询。</li><li>UNION RESULT：从UNION的结果集中获取数据的SELECT查询。</li><li>SUBQUERY：不在FROM子句中出现的子查询，通常在SELECT语句中使用。</li><li>DEPENDENT SUBQUERY：子查询依赖外层查询的结果集。</li></ul><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p><strong>key：</strong>实际上使用的索引。在MySQL中创建索引时使用的是INDEX关键字，但在EXPLAIN执行计划表中，显示的是KEY，这是因为<strong>MySQL允许在创建索引时指定统计信息</strong>，例如最小值、最大值等，这些<strong>统计信息</strong>在索引中被视为<strong>索引键</strong>（Index key），所以在执行计划表中，显示为KEY。</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p><strong>type：</strong>访问类型，根据索引、全表扫描等方法来执行查询的优化策略。当 type 列的取值不是 Const 时，我们需要重点关注有关索引、缓存的性能调优，对 SQL 语句进行优化，适当修复可能的数据设计问题。</p><ul><li><p><strong>system：一行记录时,快速查询。</strong>只有一行数据即将被查询。这是最快的查询类型，通常出现在系统表的查询中。</p></li><li><p><strong>const：命中主键或唯一索引。</strong>使用主键或唯一索引查找单个行时使用，此时查询只能返回一行数据。这是一种非常快的查询类型。</p></li><li><p>eq_ref：连接使用唯一索引查找符合查询条件的数据时使用，每个连接类型都需要使用唯一索引进行访问，比ref执行速度更快。</p></li><li><p><strong>ref：命中非唯一索引。</strong>使用非唯一索引查找数据时使用，查询结果比eq_ref大，但仍很快。</p></li><li><p><strong>range：范围索引查询。</strong>使用索引范围查找数据时，可能会查找一定范围内的数据，如使用 BETWEEN 或 &gt; 或 &gt; &lt; 等操作时的查询。</p></li><li><p><strong>index：没命中索引，扫描非聚簇索引树再回表。</strong></p><ul><li><p>直接在某个索引树上做条件判断，并且不需要回表。全表扫描没有好的索引适用时使用，相比于全表扫描速度更快。</p></li><li><p>index是另外一种形式的全表扫描，扫描已有索引树然后回表取数据。和all相比，他要回表随机取数据，因此index不可能会比all快（取同一个表数据），官方手册说它的效率说的比all好，唯一可能的原因在于，按照索引扫描全表的数据是有序的。这样一来，结果不同，也就没法比效率的问题了。</p></li><li><p>比如：select t3.key1 from t3 where t3.key2 =6 ;当我们创建了联合索引idx_key1_key2(key1,key2)时，判断条件key2=6时，其虽然不满足索引的最左前缀原则，但是我们可以遍历idx_key1_key2这颗索引树，找到key2=6的记录即可。由于查询结果需要的key1在这个联合索引上，也不需要回表，此时就可以使用index。</p></li></ul></li><li><p><strong>all：全表扫描。</strong>扫描整个表以获得需要的数据，速度最慢，必须尽量避免使用。</p></li><li><p>unique_subquery：在对查询结果进行过滤或使用 IN 操作时，优化器会选择使用此类型的查询，使用了 In 操作符的子查询依赖于外层查询的唯一索引。</p></li><li><p>index_subquery：使用了 In 操作符但子查询使用的普通索引，而不是唯一索引。</p></li><li><p>range_check：在使用索引来检查外键参照时使用。</p></li><li><p>index_merge：使用多个索引。</p></li></ul><h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><ul><li><strong>using index：</strong>使用了覆盖索引，即不需要回表。查询的几个列正好都在这个聚簇索引树上。</li><li><strong>Using where：</strong>通过where过滤。没完全命中索引，需要回表。如index(a)，查的是where a=2 and b=3，查b=3时就要回表过滤。</li><li><strong>Using index condition：</strong>使用了索引下推。</li><li>Using temporary：临时表存储结果集.排序/分组会使用</li><li>Using filesort：排序操作未用索引</li><li>Using join buffer：连接条件未用索引</li><li>Impossible where：where约束语句可能有问题导致没有结果集</li></ul><h2 id="EXPLAIN四种输出格式"><a href="#EXPLAIN四种输出格式" class="headerlink" title="EXPLAIN四种输出格式"></a>EXPLAIN四种输出格式</h2><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式： <code>传统格式</code> ，<code>JSON格式</code> ， <code>TREE格式</code> 以及 <code>可视化输出</code> 。用户可以根据需要选择适用于自己的格式。</p><ol><li><p>传统格式：传统格式简单明了，输出是一个表格形式，概要说明查询计划。输出中缺少衡量执行好坏的重要属性 —— <code>成本</code>。</p></li><li><p>JSON格式：四种格式里面输出<code>信息最详尽</code>的格式，里面包含了执行的成本信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> ....</span><br></pre></td></tr></table></figure></li><li><p>TREE格式：TREE格式是8.0.16版本之后引入的新格式，主要根据查询的 <code>各个部分之间的关系</code> 和 <code>各部分的执行顺序</code> 来描述如何查询。</p></li><li><p>可视化输出：通过MySQL Workbench可视化查看执行计划。点击Workbench的放大镜图标，即可生成可视化的查询计划。</p><p>从左到右的连接顺序显示表。红色框表示 <code>全表扫描</code> ，而绿色框表示使用 <code>索引查找</code> 。对于每个表， 显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。 </p></li></ol><h2 id="SHOW-WARNINGS的使用"><a href="#SHOW-WARNINGS的使用" class="headerlink" title="SHOW WARNINGS的使用"></a>SHOW WARNINGS的使用</h2><p>在MySQL中，SHOW WARNINGS是一个可以查看最近一次执行的语句中产生的警告信息的命令。当MySQL执行语句时，如果发现一些不符合预期的情况，会产生一些警告信息，包括非致命性错误，例如某些类型的数据不能隐式转换或某些数据截断等。</p><p>执行SHOW WARNINGS命令时，MySQL会返回警告信息的详细列表，包括：</p><ul><li>Warning：该警告的类型</li><li>Level：该警告的级别，通常为Note、Warning或Error</li><li>Code：警告的返回代码</li><li>Message：警告信息的内容</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 可以使用<span class="keyword">SELECT</span>的方式来查看最近一次操作的警告信息：</span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS;</span><br><span class="line"># 也可以配合使用<span class="keyword">INSERT</span>、<span class="keyword">UPDATE</span>、<span class="keyword">DELETE</span>、<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>等命令，检查某个具体操作产生的警告信息：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_table (name, age) <span class="keyword">VALUES</span> (<span class="string">&#x27;John Doe&#x27;</span>, <span class="number">150</span>);</span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS;</span><br></pre></td></tr></table></figure><h2 id="EXPLAIN-ANALYZE命令"><a href="#EXPLAIN-ANALYZE命令" class="headerlink" title="EXPLAIN ANALYZE命令"></a>EXPLAIN ANALYZE命令</h2><p>MySQL 8.0引入了explain analyze命令，相比explain，它提供的是实际的查询计划，而explain提供的是预估查询计划。</p><p><strong>explain和explain analyze的区别：</strong></p><ul><li><strong>explain：</strong>只生成执行计划，不实际执行</li><li><strong>explain analyze：</strong>生成执行计划，并实际执行sql</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 分析人员表联查部门表</span><br><span class="line">EXPLAIN ANALYZE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> personnel p <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> department d <span class="keyword">on</span> p.department<span class="operator">=</span>d.id</span><br><span class="line"># 查询计划结果</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> Nested loop <span class="keyword">left</span> <span class="keyword">join</span>  (cost<span class="operator">=</span><span class="number">915.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1980</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.333</span>.<span class="number">.14</span><span class="number">.500</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2453</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Table</span> scan <span class="keyword">on</span> p  (cost<span class="operator">=</span><span class="number">222.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1980</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.283</span>.<span class="number">.8</span><span class="number">.625</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2453</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>: (p.DEPARTMENT <span class="operator">=</span> d.ID)  (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.002</span>.<span class="number">.0</span><span class="number">.002</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">2453</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> Single<span class="operator">-</span><span class="type">row</span> index lookup <span class="keyword">on</span> d <span class="keyword">using</span> <span class="keyword">PRIMARY</span> (ID<span class="operator">=</span>p.DEPARTMENT)  (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.002</span>.<span class="number">.0</span><span class="number">.002</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">2453</span>)</span><br></pre></td></tr></table></figure><p><strong>结果分析</strong>：</p><p><strong>第一行：</strong>Nested loop left join  (cost=915.25 rows=1980) (actual time=0.333..14.500 rows=2453 loops=1)</p><ul><li><strong>Nested loop left join:</strong> 执行的最外层操作，表示使用嵌套循环的左连接。</li><li><strong>成本估计</strong>: (cost=915.25 rows=1980)：预计消耗915.25ms并返回1980行。</li><li><strong>实际时间</strong>: (actual time=0.333..14.500 rows=2453 loops=1)：实际读取第一行平均花费0.333ms，返回所有行平均花费14.500ms，共循环调用该迭代器1次，返回2453行。</li></ul><p><strong>第二行：</strong>Table scan on p  (cost=222.25 rows=1980) (actual time=0.283..8.625 rows=2453 loops=1)</p><ul><li><strong>Table scan on p:</strong> 对人员表的全表扫描。</li><li><strong>成本估计</strong>: (cost=222.25 rows=1980)：预计消耗222.25ms并返回1980行。</li><li><strong>实际时间</strong>: (actual time=0.283..8.625 rows=2453 loops=1)：实际读取第一行平均花费0.283ms，返回所有行平均花费8.625ms，共循环调用该迭代器1次，返回2453行。</li></ul><p><strong>第三行：</strong>Filter: (p.DEPARTMENT = d.ID)  (cost=0.25 rows=1) (actual time=0.002..0.002 rows=1 loops=2453)</p><ul><li><p><strong>Filter: (p.DEPARTMENT = d.ID):</strong> 执行对 md_gams_jc_department 表中 p.DEPARTMENT = d.ID 条件的过滤操作。</p></li><li><p><strong>成本估计</strong>: (cost=0.25 rows=1)：预计消耗0.25ms并返回1行。</p></li><li><p><strong>实际时间</strong>: (actual time=0.002..0.002 rows=1 loops=2453)：过滤操作平均花费0.002ms，共循环调用该迭代器2453次，返回1行。</p></li></ul><p><strong>第四行：</strong>Single-row index lookup on d using PRIMARY …… (actual time=0.002..0.002 rows=1 loops=2453)</p><ul><li><strong>Single-row index lookup on d using PRIMARY (ID=p.DEPARTMENT):</strong> 对部门表使用主键索引进行单行查找，其中 ID=p.DEPARTMENT。</li><li><strong>成本估计</strong>: (cost=0.25 rows=1)：预计消耗0.25ms并返回1行。</li><li><strong>实际时间</strong>: (actual time=0.002..0.002 rows=1 loops=2453)：查找操作平均花费0.002ms，共循环调用该迭代器2453次，返回1行。</li></ul><hr><h1 id="分析优化器执行计划：trace"><a href="#分析优化器执行计划：trace" class="headerlink" title="分析优化器执行计划：trace"></a>分析优化器执行计划：trace</h1><p>在MySQL中，可以使用trace命令来进行优化器执行计划的跟踪和分析。trace命令可以显示MySQL优化器在生成执行计划时所采取的决策，包括哪些表被处理，以及使用哪些索引、算法等。</p><p>使用trace命令需要先启用<code>general_log</code>和<code>performance_schema</code>两个系统变量，其次需要使用SET语句来设置一些参数，例如<code>trace-unique-check、trace-max-protocol、trace-protocol、trace-feature、trace-feature-check</code>等。设置完成后，可以通过<code>SET global trace_format=&#39;json&#39;</code>语句来选择输出结果的格式。</p><p>下面是对使用trace命令的一个简单示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>设置参数：</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_feature <span class="operator">=</span> <span class="string">&#x27;qa&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@max</span>_execution_time<span class="operator">=</span><span class="number">50000</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_level <span class="operator">=</span> <span class="string">&#x27;+ddl,+engine&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_feature_check <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_unique_check <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_protocol <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@trace</span>_max_protocol <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"># <span class="number">2.</span>启用general_log和performance_schema：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> performance_schema <span class="operator">=</span> <span class="keyword">on</span>;</span><br><span class="line"># <span class="number">3.</span>执行查询并查看结果：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> my_table</span><br><span class="line"><span class="keyword">WHERE</span> my_column <span class="operator">=</span> <span class="string">&#x27;some_value&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> SESSION STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Last_Query_Plan&#x27;</span>;</span><br><span class="line"># <span class="number">4.</span>关闭general_log和performance_schema：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> general_log <span class="operator">=</span> off;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> performance_schema <span class="operator">=</span> off;</span><br></pre></td></tr></table></figure><p>在trace输出中，可以看到优化器在执行计划中使用的索引、执行算法、行数估计等细节信息。通过分析trace结果，可以找到一些性能问题的根源，并进行相应的调整和优化。但要注意，trace命令可能会带来额外的性能消耗和IO开销，不应该在生产环境中长期启用。</p><hr><h1 id="MySQL监控分析视图-sys-schema"><a href="#MySQL监控分析视图-sys-schema" class="headerlink" title="MySQL监控分析视图-sys schema"></a>MySQL监控分析视图-sys schema</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>MySQL在8.0版本引入了sys schema，该模式包含用于监视和分析MySQL服务器性能的视图和函数。sys schema提供了一组易于使用的视图和函数，可以帮助我们更好地理解和分析MySQL数据库的行为和性能。</p><p>以下是sys schema中一些常用的监控分析视图：</p><ul><li><p>sys.statements_with_sorting: 显示哪些语句使用了排序操作，包括使用哪些排序操作、每个语句排序次数及排序操作的资源消耗。</p></li><li><p>sys.statements_with_runtimes_in_95th_percentile`: 显示执行时间最长的语句。</p></li><li><p>sys.io_global_by_file_by_bytes: 显示每个文件的磁盘IO字节数，可以用来检测IO瓶颈。</p></li><li><p>sys.memory_by_host_by_current_bytes: 显示每个客户端的当前内存使用情况，可以用于检测内存泄漏或内存占用高的情况。</p></li><li><p>sys.waits_global_by_latency: 显示哪些等待操作最耗费时间，可以帮助我们找到性能问题的瓶颈所在。</p></li><li><p>sys.processlist: 显示当前正在运行的线程和进程的信息，包括执行的语句、查询ID、用户、主机、线程ID和状态等信息。</p></li></ul><p><strong>sys schema</strong>中的视图和函数提供了更深入的MySQL性能分析和监控功能，可以帮助我们更好地理解MySQL数据库的行为和性能瓶颈。 </p><ol><li><strong>主机相关</strong>：以host_summary开头，主要汇总了IO延迟的信息。</li><li><strong>Innodb相关</strong>：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。</li><li><strong>I/o相关</strong>：以io开头，汇总了等待I/O、I/O使用量情况。</li><li><strong>内存使用情况</strong>：以memory开头，从主机、线程、事件等角度展示内存的使用情况</li><li><strong>连接与会话信息</strong>：processlist和session相关视图，总结了会话相关信息。</li><li><strong>表相关</strong>：以schema_table开头的视图，展示了表的统计信息。</li><li><strong>索引信息</strong>：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li><li><strong>语句相关</strong>：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。</li><li><strong>用户相关</strong>：以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。</li><li><strong>等待事件相关信息</strong>：以wait开头，展示等待事件的延迟情况。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><p>索引情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查询冗余索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_redundant_indexes;</span><br><span class="line"># <span class="number">2.</span> 查询未使用过的索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line"># <span class="number">3.</span> 查询索引的使用情况</span><br><span class="line"><span class="keyword">select</span> index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line"><span class="keyword">from</span> sys.schema_index_statistics <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>表相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查询表的访问量</span><br><span class="line"><span class="keyword">select</span> table_schema,table_name,<span class="built_in">sum</span>(io_read_requests<span class="operator">+</span>io_write_requests) <span class="keyword">as</span> io </span><br><span class="line"><span class="keyword">from</span> sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema,table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"># <span class="number">2.</span> 查询占用bufferpool较多的表</span><br><span class="line"><span class="keyword">select</span> object_schema,object_name,allocated,data</span><br><span class="line"><span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated limit <span class="number">10</span>;</span><br><span class="line"># <span class="number">3.</span> 查看表的全表扫描情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>语句相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 监控<span class="keyword">SQL</span>执行的频率</span><br><span class="line"><span class="keyword">select</span> db,exec_count,query <span class="keyword">from</span> sys.statement_analysis <span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line"># <span class="number">2.</span> 监控使用了排序的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,first_seen,last_seen,query <span class="keyword">from</span> sys.statements_with_sorting limit <span class="number">1</span>;</span><br><span class="line"># <span class="number">3.</span> 监控使用了临时表或者磁盘临时表的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line"><span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables <span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables<span class="operator">+</span>tmp_disk_tables) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></li><li><p>I/O相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查看消耗磁盘IO的文件</span><br><span class="line"><span class="keyword">select</span> file,avg_read,avg_write,avg_read<span class="operator">+</span>avg_write <span class="keyword">as</span> avg_io</span><br><span class="line"><span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>Innodb 相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 行锁阻塞情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h1><h2 id="基础优化"><a href="#基础优化" class="headerlink" title="基础优化"></a>基础优化</h2><h3 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h3><ul><li><strong>缓冲池优化：</strong>调整缓冲池大小innodb_buffer_pool_size。</li><li><strong>引入内存结构数据库：</strong>例如Redis。</li></ul><p><strong>提示</strong>：InnoDB使用缓冲池缓存记录和索引</p><h4 id="缓冲池优化"><a href="#缓冲池优化" class="headerlink" title="缓冲池优化"></a>缓冲池优化</h4><p><strong>缓冲池：</strong>MySQL的缓冲池被分为多个不同的缓存池，其中包括：</p><ul><li><strong>查询缓存：</strong>用来缓存查询结果。</li><li><strong>InnoDB缓存池：</strong>用来缓存热点表和索引数据页。</li><li><strong>MyISAM缓存池：</strong>用来缓存表数据块。</li></ul><p>缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</p><p><strong>缓冲池的淘汰策略：</strong></p><p>LRU算法。MySQL的缓冲池默认使用的是LRU（最近最少使用）淘汰策略，它会优先缓存最近使用的数据。当缓冲池的空间不足时，MySQL会将最不常用的数据从缓冲池中替换出去，以腾出空间缓存新的数据。</p><blockquote><p><strong>lru算法底层原理：</strong></p><p>底层是双向链表（因为经常要移动元素），链表首部是最常使用元素，尾部是最少使用元素。</p><p>每次刚访问的数据会移动到链表首部，刚添加的数据也会添加到链表首部。超出maxmemory会淘汰链表尾部元素，它也最长时间没有被使用的数据。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726175640829.png" alt="image-20250726175640829"></p></blockquote><p><strong>缓冲池相关参数：</strong></p><ul><li><p><strong>MyISAM缓冲池大小：</strong>key_buffer_size：该参数用来设置MyISAM索引的缓存大小。如果应用程序中涉及到大量的索引查询，可以适当提高该值。一般来说，key_buffer_size占用总内存的1/4到1/3比较合适。</p></li><li><p><strong>InnoDB缓冲池大小：</strong>innodb_buffer_pool_size：该参数用来设置InnoDB缓冲池的大小。<strong>InnoDB</strong>存储引擎使用<strong>缓冲池来缓存数据和索引文件</strong>。如果InnoDB表的读写频次较高，建议将该值设置为物理内存的70%到80%。</p></li><li><p><strong>排序缓冲区大小：</strong>sort_buffer_size：该参数用来设置排序缓冲区大小。如果查询中涉及到ORDER BY或GROUP BY操作，可以适当提高该值。一般来说，sort_buffer_size占用总内存的1/4到1/3比较合适。</p></li><li><p><strong>读取缓冲区大小：</strong>read_buffer_size和read_rnd_buffer_size：这两个参数是用来设置读取缓冲区大小的，默认值为128 KB。如果应用程序中经常进行大文件的读取操作，可以适当提高这两个参数。</p></li><li><p><strong>binlog大小：</strong>binlog_cache_size：该参数是用来设置二进制日志的缓存大小。如果应用程序中需要持久化一些数据，可以开启二进制日志，并适当调整该参数。</p></li></ul><p><strong>参数配置方法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>查看当前缓冲池参数：</span><br><span class="line"><span class="keyword">show</span> VARIABLES  <span class="keyword">like</span> <span class="string">&#x27;key_buffer_size&#x27;</span>;</span><br><span class="line"># <span class="number">2.</span>修改缓冲池参数：</span><br><span class="line"># <span class="number">2.1</span> 在运行中的MySQL实例中临时设置这个值（这不会持久保存，重启后会失效）：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> key_buffer_size <span class="operator">=</span> <span class="number">67108864</span>;  <span class="comment">-- 64MB</span></span><br><span class="line"># 在MySQL配置文件（通常是 my.cnf 或 my.ini）中进行更改，然后重启MySQL服务使更改生效：</span><br><span class="line">[mysqld]</span><br><span class="line">key_buffer_size <span class="operator">=</span> <span class="number">64</span>M</span><br></pre></td></tr></table></figure><h4 id="Redis优化"><a href="#Redis优化" class="headerlink" title="Redis优化"></a>Redis优化</h4><p>Redis是一个基于内存的NoSQL数据库，MySQL是一个基于磁盘的关系型数据库。内存的读写速度是远高于磁盘的，所以对于一些多读少写的热点数据，搭配Redis存储数据，可以极大地提高数据的访问速度。</p><blockquote><p>参考文章：<a href="/2025/07/26/database/db-redis/">Redis</a></p></blockquote><h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p>服务器加内存条、升级SSD固态硬盘、把磁盘I/O分散在多个设备、配置多处理器。</p><h3 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h3><ol><li><p>关闭不必要的服务和日志：调优结束关闭慢查询日志；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 临时关闭慢查询日志，如果想永久关闭，需要修改my.ini或my.cnf配置文件</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;OFF&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>调整最大连接数：max_connections 。MySQL5.5及之后版本默认最大连接数是151，可根据实际场景压测得出合适的最大连接数。</p><ul><li><p>MySQL5.5 ～ 5.7：默认的最大连接数都是 151，上限为：100000</p></li><li><p>MySQL5.0 版本：默认的最大连接数为 100，上限为 16384</p></li><li><p>MySQL8.0 版本: 默认的最大连接数是 151</p></li><li><p>修改最大链接数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>查看当前最大连接数：</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"># <span class="number">2.</span>临时修改最大连接数（重启后失效）：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_connections <span class="operator">=</span><span class="number">1000</span></span><br><span class="line"># <span class="number">3.</span>永久修改连接数（重启后有效）：</span><br><span class="line"># 在Linux系统中，配置文件通常是<span class="operator">/</span>etc<span class="operator">/</span>my.cnf或<span class="operator">/</span>etc<span class="operator">/</span>mysql<span class="operator">/</span>my.cnf。</span><br><span class="line"># 在Windows系统中，通常是 [安装目录下]\MySQL Server <span class="number">5.7</span>\my.ini。</span><br><span class="line">[mysqld]</span><br><span class="line">max_connections <span class="operator">=</span> <span class="number">1000</span></span><br><span class="line"># Linux，重启</span><br><span class="line">sudo systemctl restart mysql</span><br><span class="line"># windows，服务重启：服务管理器<span class="operator">-</span>搜索MySQL<span class="operator">-</span>重启服务</span><br></pre></td></tr></table></figure></li></ul></li><li><p>线程池缓存线程数：thread_cache_size，缓存空闲线程，有连接时直接分配该线程处理连接；</p></li><li><p>缓冲池大小：innodb_buffer_pool_size 。</p></li></ol><h3 id="定期清理垃圾"><a href="#定期清理垃圾" class="headerlink" title="定期清理垃圾"></a>定期清理垃圾</h3><p>对于不再使用的表、数据、日志、缓存等，应该及时清理，避免占用过多的MySQL资源，从而提高MySQL的性能。</p><h4 id="清理不再使用的表"><a href="#清理不再使用的表" class="headerlink" title="清理不再使用的表"></a>清理不再使用的表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除这些表：</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"># 保留表结构但删除所有数据</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure><h4 id="清理过期数据"><a href="#清理过期数据" class="headerlink" title="清理过期数据"></a>清理过期数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 一些场景下，某个时期之前的数据都不再需要，可以清理这些数据</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> createTime <span class="operator">&lt;</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">30</span> <span class="keyword">DAY</span>;</span><br><span class="line"># 创建一个MySQL事件来定期清理过期数据</span><br><span class="line"><span class="keyword">CREATE</span> EVENT clean_up_event</span><br><span class="line"><span class="keyword">ON</span> SCHEDULE <span class="keyword">EVERY</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br><span class="line">DO</span><br><span class="line">  <span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> created_at <span class="operator">&lt;</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">30</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure><h4 id="清理日志"><a href="#清理日志" class="headerlink" title="清理日志"></a>清理日志</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 清理<span class="number">2023</span>年之前的日志</span><br><span class="line">PURGE <span class="type">BINARY</span> LOGS BEFORE <span class="string">&#x27;2023-01-01 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="清理缓存池"><a href="#清理缓存池" class="headerlink" title="清理缓存池"></a>清理缓存池</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RESET QUERY CACHE;</span><br><span class="line"># 或者修改配置文件，禁用查询缓存以避免潜在的性能问题：</span><br><span class="line">[mysqld]</span><br><span class="line">query_cache_type <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">query_cache_size <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="优化表：OPTIMIZE-TABLE"><a href="#优化表：OPTIMIZE-TABLE" class="headerlink" title="优化表：OPTIMIZE TABLE"></a>优化表：OPTIMIZE TABLE</h4><p>在 MySQL 数据库中，OPTIMIZE TABLE 是一个重要的命令，用于优化表的性能和空间利用。通过重新组织表的存储结构，去除碎片、重建索引，OPTIMIZE TABLE 可以帮助提高查询性能、减少存储空间占用以及减少数据碎片。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><p><strong>优化原理：</strong></p><p>删除delete语句留下来的垃圾碎片。使用delete语句删除数据时，delete语句只会将记录的位置或者数据页标记为”可复用”，但是数据库磁盘文件的大小不会改变，即表空间不会被回收，此时使用该命令可以释放空间，压缩数据文件。</p><p><strong>底层原理：</strong>执行OPTIMIZE TABLE命令后，MySQL会进行以下几个步骤</p><ol><li><strong>创建临时表</strong>：MySQL 首先会创建一个与原表结构相同的临时表。</li><li><strong>原表数据复制到临时表</strong>：将原表中的数据复制到临时表中。</li><li><strong>临时表去碎片</strong>：在数据复制的过程中，MySQL 会对数据进行整理和重组，去除碎片，提高数据的连续性。</li><li><strong>删旧表留新表</strong>：当数据复制完成并且表被优化后，MySQL 会删除原表，然后将临时表重命名为原表的名称。</li></ol><h4 id="分析表：ANALYZE-TABLE"><a href="#分析表：ANALYZE-TABLE" class="headerlink" title="分析表：ANALYZE TABLE"></a>分析表：ANALYZE TABLE</h4><p>MySQL 的Optimizer（优化元件）在优化SQL语句时，首先需要收集一些相关信息，其中就包括表的cardinality（散列程度），它表示某个索引对应的列包含多少个不同的值——如果cardinality大大少于数据的实际散列程度，那么索引就基本失效了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><p><strong>对不同存储引擎的效果：</strong></p><ul><li><strong>InnoDB：</strong>对 InnoDB 表执行 ANALYZE TABLE 会重新计算表和索引的统计信息，并更新优化器统计信息。</li><li><strong>MyISAM：</strong>对 MyISAM 表执行 ANALYZE TABLE 会分析表的关键字分布，并更新索引统计信息。</li><li><strong>其他存储引擎：</strong>对其他存储引擎（如 MEMORY 或 ARCHIVE），效果类似，即更新表和索引的统计信息。</li></ul><h4 id="计划任务清理数据、日志、优化表"><a href="#计划任务清理数据、日志、优化表" class="headerlink" title="计划任务清理数据、日志、优化表"></a>计划任务清理数据、日志、优化表</h4><p>对于以上的清理垃圾方案，可以写一个定时任务，定期统一清理垃圾数据、优化表的存储空间和索引。</p><h5 id="方案一：创建cron作业"><a href="#方案一：创建cron作业" class="headerlink" title="方案一：创建cron作业"></a>方案一：创建cron作业</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编辑crontab</span></span><br><span class="line"><span class="comment"># 使用crontab命令编辑当前用户的cron作业列表。对于系统级别的作业，可以使用sudo运行crontab。</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 或者，为特定用户编辑cron作业：</span></span><br><span class="line">sudo crontab -u username -e</span><br><span class="line"><span class="comment"># 2. 编写cron作业</span></span><br><span class="line"><span class="comment"># 在打开的编辑器中，添加新的cron作业，每行代表一个作业，执行指定路径下的脚本：</span></span><br><span class="line">0 2 * * * /path/to/cleanup_script.sh</span><br></pre></td></tr></table></figure><blockquote><p>cron表达式格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command-to-be-executed</span><br><span class="line">- - - - -</span><br><span class="line">| | | | |</span><br><span class="line">| | | | +----- Day of the week (0 - 7) (Sunday=0 or 7)</span><br><span class="line">| | | +------- Month (1 - 12)</span><br><span class="line">| | +--------- Day of the month (1 - 31)</span><br><span class="line">| +----------- Hour (0 - 23)</span><br><span class="line">+------------- Minute (0 - 59)</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例清理脚本</strong>：/path/to/cleanup_script.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># MySQL credentials</span></span><br><span class="line">USER=<span class="string">&quot;your_username&quot;</span></span><br><span class="line">PASSWORD=<span class="string">&quot;your_password&quot;</span></span><br><span class="line">DATABASE=<span class="string">&quot;your_database&quot;</span></span><br><span class="line"><span class="comment"># 清理过期数据</span></span><br><span class="line">mysql -u <span class="variable">$USER</span> -p<span class="variable">$PASSWORD</span> -e <span class="string">&quot;DELETE FROM table_name WHERE created_at &lt; NOW() - INTERVAL 30 DAY;&quot;</span> <span class="variable">$DATABASE</span></span><br><span class="line"><span class="comment"># 清理二进制日志</span></span><br><span class="line">mysql -u <span class="variable">$USER</span> -p<span class="variable">$PASSWORD</span> -e <span class="string">&quot;PURGE BINARY LOGS BEFORE NOW() - INTERVAL 7 DAY;&quot;</span></span><br><span class="line"><span class="comment"># 优化表</span></span><br><span class="line">mysql -u <span class="variable">$USER</span> -p<span class="variable">$PASSWORD</span> -e <span class="string">&quot;OPTIMIZE TABLE table_name;&quot;</span> <span class="variable">$DATABASE</span></span><br></pre></td></tr></table></figure><h5 id="方案二：使用Spring定时任务"><a href="#方案二：使用Spring定时任务" class="headerlink" title="方案二：使用Spring定时任务"></a>方案二：使用Spring定时任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤①：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootTaskApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Springboot22TaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步骤②：在task包下定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 具体清理垃圾的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何想对定时任务进行详细配置，可以通过配置文件进行</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">       <span class="attr">scheduling:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">           <span class="attr">size:</span> <span class="number">1</span> <span class="comment">#任务调度线程池大小 默认 1</span></span><br><span class="line">      <span class="attr">thread-name-prefix:</span> <span class="string">ssm_</span>           <span class="comment">#调度线程名称前缀 默认 scheduling-      </span></span><br><span class="line">        <span class="attr">shutdown:</span></span><br><span class="line">          <span class="attr">await-termination:</span> <span class="literal">false</span>         <span class="comment">#线程池关闭时等待所有任务完成</span></span><br><span class="line">          <span class="attr">await-termination-period:</span> <span class="string">10s</span>     <span class="comment">#调度线程关闭前最大等待时间，确保最后一定关闭</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong></p><ol><li>spring task需要使用注解@EnableScheduling开启定时任务功能</li><li>为定时执行的的任务设置执行周期，描述方式cron表达式</li></ol></blockquote><h3 id="使用合适的存储引擎"><a href="#使用合适的存储引擎" class="headerlink" title="使用合适的存储引擎"></a>使用合适的存储引擎</h3><p>MyISAM：适合读取频繁，写入较少的场景（因为表级锁、B+树叶存地址）</p><p>InnoDB：适合并发写入的场景（因为行级锁、B+树叶存记录）。</p><h3 id="读写分离与分库分表"><a href="#读写分离与分库分表" class="headerlink" title="读写分离与分库分表"></a>读写分离与分库分表</h3><blockquote><p>参考文章：<a href="/2025/07/26/database/db-mysql-5-sharding/">MySQL数据库-表设计优化、读写分离与分库分表</a></p></blockquote><p><strong>读写分离</strong>：读写分离能有效提高查询性能。主从同步用到bin log和relay log。</p><p><strong>分库分表</strong>：数据量级到达千万级以上后，垂直拆分（分库）、水平拆分（分表）、垂直+水平拆分（分库分表）。</p><h2 id="表设计优化"><a href="#表设计优化" class="headerlink" title="表设计优化"></a>表设计优化</h2><blockquote><p>参考文章：<a href="/2025/07/26/database/db-mysql-5-sharding/">MySQL数据库-表设计优化、读写分离与分库分表</a></p></blockquote><ol><li>混合业务分表、冷热数据分表</li><li>联合查询改为中间关系表</li><li>遵循三个范式</li><li>字段建议非空约束</li><li>反范式：使用冗余字段</li><li>数据类型优化</li></ol><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="索引优化思路"><a href="#索引优化思路" class="headerlink" title="索引优化思路"></a>索引优化思路</h3><p>都有哪些维度可以进行数据库调优？简言之：</p><ul><li><p>索引失效、没有充分利用到索引——<strong>建立索引</strong></p></li><li><p>关联查询太多JOIN（设计缺陷或不得已的需求）——<strong>SQL优化</strong></p></li><li><p>服务器调优及各个参数设置（关闭慢查询日志、缓冲、线程数等）——<strong>调整my.cnf</strong></p></li><li><p>数据过多——<strong>分库分表</strong></p></li><li><p><strong>定期清理垃圾：</strong>对于不再使用的表、数据、日志、缓存等，应该及时清理，避免占用过多的MySQL资源，从而提高MySQL的性能。</p></li><li><p><strong>使用合适的存储引擎：</strong>MyISAM比较适合读取频繁，写入较少的场景（因为表级锁、B+树叶存地址），而InnoDB比较适合并发写入的场景（因为行级锁、B+树叶存记录）。</p></li></ul><p>关于数据库调优的知识非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。</p><p>虽然SQL查询优化的技术有很多，但是大方向上完全可以分成<strong>物理查询优化</strong>和<strong>逻辑查询优化</strong>两大块。</p><ul><li><strong>物理查询优化</strong>：<strong>索引</strong>和<strong>表连接方式</strong>等技术来进行优化，这里重点需要掌握索引的使用。</li><li><strong>逻辑查询优化</strong>：通过SQL<strong>等价变换</strong>提升查询效率，即换一种查询写法效率可能更高。</li></ul><h3 id="索引失效的11种情况"><a href="#索引失效的11种情况" class="headerlink" title="索引失效的11种情况"></a>索引失效的11种情况</h3><p><strong>用不用索引，最终都是优化器说了算：</strong></p><p>优化器是基于什么的优化器? 基于 **cost开销(CostBaseOptimizer)**，它不是基于规则(Rule-Basedoptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</p><h4 id="查询条件相关"><a href="#查询条件相关" class="headerlink" title="查询条件相关"></a>查询条件相关</h4><ul><li><p><strong>隐式类型转换</strong>：当查询条件中的数据类型与索引列的数据类型不匹配时，会触发隐式转换，导致索引失效。例如，索引列是<code>varchar</code>类型，查询时使用了数字类型。</p></li><li><p><strong>左模糊匹配</strong>：使用<code>like</code>语句进行模糊查询时，如果通配符<code>%</code>在最左边，无法利用索引的有序性，索引失效。如<code>select * from users where name like &#39;%张%&#39;</code>。</p></li><li><p><strong>索引列参与运算</strong>：对索引列进行运算，如<code>age + 1 &gt; 30</code>，数据库需对每行数据计算后才能比较，无法直接利用索引，索引失效。</p></li><li><p><strong>函数操作索引字段</strong>：在查询条件中对索引列使用函数，如<code>date_format(created_at, &#39;%y-%m&#39;)</code>，函数转换会破坏索引的有序性，导致索引失效。</p></li><li><p><strong>最左前缀原则违反</strong>：对于联合索引，必须从左到右连续使用，即最左优先，否则索引失效。</p><p><strong>结论</strong>：MySQL可以为多个字段创建索引，一个索引可以包含16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong>。</p><p><strong>例如</strong>：联合索引<code>(country, city, age)</code>，查询条件为<code>city=&#39;北京&#39; and age&gt;25</code>，跳过了第一个字段<code>country</code>字段，索引失效。</p></li><li><p><strong>范围条件右边的列索引失效</strong>：（a,b,c）联合索引，查询条件a,b,c，如果b使用了范围查询，那么b右边的c索引失效。这里右边看的联合索引的键右边。</p><p><strong>解决办法</strong>：新建联合索引（a,c,b）或（c,a,b），把需要范围查询的字段放在最后</p><p><strong>范围包括</strong>：(&lt;) (&lt;=) (&gt;) (&gt;=) 和 between。</p></li><li><p><strong>or连接非索引字段</strong>：<code>or</code>条件要求所有涉及的列都有索引，否则索引失效。如<code>select * from users where age=25 or address=&#39;北京&#39;</code>，<code>address</code>无索引。</p></li><li><p><strong>使用不等号（!= / &lt;&gt;）</strong>：因为“不等于”不能精准匹配，全表扫描二级索引树再回表效率不如直接全表扫描聚簇索引树。使用不等号进行查询时，如果需要扫描大部分数据，优化器可能会放弃索引。如<code>select * from orders where status != &#39;completed&#39;</code>。</p></li><li><p><strong>索引选择性过低</strong>：当索引列的值过于重复，区分度低于30%时，优化器可能认为全表扫描更高效，从而放弃使用索引。</p></li></ul><h4 id="查询操作相关"><a href="#查询操作相关" class="headerlink" title="查询操作相关"></a>查询操作相关</h4><ul><li><strong>使用not in / not exists</strong>：<code>not in</code>和<code>not exists</code>操作符在某些情况下会导致索引失效，尤其是当查询结果集较大时。如<code>select * from user where id not in (1,2,3)</code>。</li><li><strong>使用is null / is not null</strong>：虽然<code>is null</code>或<code>is not null</code>条件可以使用索引，但如果索引列中的数据分布不均匀，查询可能仍然会导致索引失效，特别是在大数据量的情况下。</li><li><strong>全表扫描更快的情况</strong>：当查询结果超过表总行数的30%时，MySQL可能会认为全表扫描比索引查询更快，从而选择全表扫描。</li><li><strong>使用distinct</strong>：在某些情况下，<code>distinct</code>查询可能会导致MySQL不使用索引，尤其是在查询中涉及多个字段时。</li></ul><h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><ul><li><p><strong>排序顺序不同</strong>：<code>order by</code>中的字段与<code>where</code>条件中的字段不一致时，可能会导致索引失效。如<code>select id_no,name,email from db_staff where id_no &gt; &#39;110112202409881120&#39; order by create_time</code>。</p></li><li><p><strong>查询不在索引范围内</strong>：如果查询条件不在索引覆盖范围内，索引失效。如<code>select * from test_001 where user_age = 2500</code>。</p></li><li><p><strong>不同字符集导致索引失败，建议utf8mb4</strong>：不同的字符集进行比较前需要进行<strong>转换</strong>会造成索引失效。</p><p>数据库和表的字符集统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，可以<strong>避免由于字符集转换产生的乱码</strong>。</p></li><li><p><strong>主键插入顺序尽量自增</strong></p><p>对于使用 InnoDB 存储引擎的表来说，在没有显式的创建索引时，表中的数据实际上都是存储在<strong>聚簇索引的叶子节点</strong>的。而记录又是存储在数据页中的，数据页和记录又是按照记录<strong>主键值从小到大</strong>的顺序进行排序。所以如果 插入 的记录的 主键值是依次增大 的话，那每插满一个数据页就换到下一个数据页继续插，而插入的<strong>主键值忽大忽小</strong>的话，假设某个数据页存储的记录已经满了，再插入数据就需要把当前 <strong>页面分裂</strong> 成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着 <strong>性能损耗</strong> ！</p><p><strong>建议</strong>：让主键 <strong><code>AUTO_INCREMENT</code></strong> ，插入数据时存储引擎会自动填入自增主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p></li></ul><h3 id="遵循索引设计原则"><a href="#遵循索引设计原则" class="headerlink" title="遵循索引设计原则"></a>遵循索引设计原则</h3><ol><li><p>命名：索引的字段个数尽量别超过5个，命名格式“idx_col1_col2”</p></li><li><p>在频繁查询（特别是分组、范围、排序查询）的列建立索引；</p></li><li><p>频繁更新的表，不要创建过多索引</p></li><li><p>唯一特性的字段，适合创建索引；</p></li><li><p>很长的varchar字段，适合根据区分度和长度创建前缀索引；</p></li><li><p>多个字段都要创建索引时，联合索引优于单值索引；</p></li><li><p>避免创建过多索引，避免索引失效；</p></li><li><p><strong>尽量用有序的字段作为主键索引</strong>：防止乱序时新主键前移到已满的数据页，导致插入后分裂数据页，造成性能损耗； </p></li></ol><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><blockquote><p>参考文章：<a href="/2025/07/26/database/db-mysql-6-query/">MySQL数据库-查询优化</a></p></blockquote><ol><li>连接查询优化<ol><li>优化方案</li><li>左外连接：优先右表创建索引，连接字段类型要一致</li><li>内连接：驱动表由数据量和索引决定</li><li>join语句原理</li></ol></li><li>子查询优化<ol><li>子查询优化成关联查询</li><li>多次查询代替子查询</li><li>临时表代替子查询</li></ol></li><li>排序优化<ol><li>排序优化建议</li><li>范围查询时索引字段选择</li><li>filesort 算法</li></ol></li><li>分组优化</li><li>分页查询优化<ol><li>深分页查询优化</li><li>带排序的深分页优化</li></ol></li></ol><h3 id="尽量覆盖索引"><a href="#尽量覆盖索引" class="headerlink" title="尽量覆盖索引"></a>尽量覆盖索引</h3><blockquote><p><strong>详细请参考：</strong><a href="/2025/07/25/database/db-mysql-3-index/">MySQL数据库-索引</a></p></blockquote><h3 id="字符串前缀索引"><a href="#字符串前缀索引" class="headerlink" title="字符串前缀索引"></a>字符串前缀索引</h3><blockquote><p><strong>详细请参考：</strong><a href="/2025/07/25/database/db-mysql-3-index/">MySQL数据库-索引</a></p></blockquote><h3 id="尽量使用索引下推"><a href="#尽量使用索引下推" class="headerlink" title="尽量使用索引下推"></a>尽量使用索引下推</h3><blockquote><p><strong>详细请参考：</strong><a href="/2025/07/25/database/db-mysql-3-index/">MySQL数据库-索引</a></p></blockquote><p>MySQL5.6支持。一个索引包含了满足查询结果的数据。因为不需要回表，故查询效率高。覆盖索引时<strong>左模糊和不等于</strong>不能让索引失效。</p><h3 id="写多读少时尽量用普通索引"><a href="#写多读少时尽量用普通索引" class="headerlink" title="写多读少时尽量用普通索引"></a>写多读少时尽量用普通索引</h3><p>查询时普通索引和唯一索引效率差不多；更新时普通索引效率更高，因为有change buffer（写缓存）将更新后的数据页缓存到内存，下次访问时或后台定期会执行merge操作，将该数据页写入磁盘。change buffer在事务提交时会写入redo log，保证数据持久化。</p><p><strong>普通索引</strong>：不加任何限制条件，如create index idx_name on student(name)。</p><p><strong>唯一索引</strong>：UNIQUE参数限制索引唯一，如create UNIQUE index idx_name on student(name)。</p><blockquote><p><strong>详细请参考：</strong><a href="/2025/07/25/database/db-mysql-3-index/">MySQL数据库-索引</a></p></blockquote><hr><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="EXISTS-和-IN-的区分"><a href="#EXISTS-和-IN-的区分" class="headerlink" title="EXISTS 和 IN 的区分"></a>EXISTS 和 IN 的区分</h2><p><strong>问题：</strong>不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗？</p><p><strong>回答：</strong>索引是个前提，其实选择与否还是要看表的大小。可将选择标准理解为 <strong>小表驱动大表</strong>。在这种方式下效率是最高的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 比如下面这样:</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> CC <span class="keyword">IN</span> (<span class="keyword">SELECT</span> CC <span class="keyword">FROM</span> B);                     # 当B小于A</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> CC <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.CC<span class="operator">=</span>A.CC);     # 当A小于B时</span><br><span class="line"># 当A小于B时，用 <span class="keyword">EXISTS</span>。因为 <span class="keyword">EXISTS</span> 的实现，相当于外表循环，实现的逻辑类似于</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> B</span><br><span class="line">        if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span></span><br><span class="line"># 当B小于A时，用 <span class="keyword">IN</span>。因为实现的逻辑类似于</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> B</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> A</span><br><span class="line">        if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span></span><br></pre></td></tr></table></figure><p>遵循小表驱动大表原则，左边表小就是EXISTS，左边表大就用IN。</p><p><strong>小表驱动大表是为了减少连接次数</strong>：连接查询的原理是先查左表，再根据连接字段查右表，然后过滤右表的条件。因为相比普通的查询，连接查询要左表右表都查一次，肯定没有只查一次快，所以连接次数越少越好。</p><h2 id="建议COUNT-或COUNT-1"><a href="#建议COUNT-或COUNT-1" class="headerlink" title="建议COUNT(*)或COUNT(1)"></a>建议COUNT(*)或COUNT(1)</h2><p>**统计行数尽量用COUNT(1),COUNT(*)**：这时查询优化器会优先选用有索引的、占用空间最小的二级索引树进行统计，只有找不到非聚簇索引树时采用使用聚簇索引树统计，空间占用大。当然也能COUNT(最小空间二级索引字段)，但麻烦不如交给优化器自动选择。</p><p>问：在 MySQL 中统计数据表的行数，可以使用三种方式： SELECT COUNT(*) 、 SELECT COUNT(1) 和 SELECT COUNT(具体字段) ，使用这三者之间的查询效率是怎样的？</p><p>答：如果要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p><ul><li><p><strong>count（1）：</strong>统计整个表的记录行数。括号里表示一个固定值，可以是任何固定的数字字符，是个常量。在InnoDB存储引擎中，查询优化器会优先选择占用空间最小的二级索引树进行统计。COUNT(*) 和COUNT(1)都是对所有结果进行COUNT(*)，两者<strong>本质上没有区别</strong>，性能上也没有显著差别，因为优化器会处理为相同的查询计划。。有 WHERE 子句是对所有符合筛选条件的数据行进行统计，没有 WHERE子句，则是对数据表的数据行数进行统计。</p></li><li><p><strong>count（*）：</strong>统计整个表的记录行数，与count（1）执行结果相同，但是执行会根据目标表的不同进行优化。</p></li><li><p><strong>count（列名）：</strong>统计某一列的非空记录数。它会统计指定列中不为NULL的行数，忽略NULL值。</p></li><li><p><strong>count(distinct(列名)) ：</strong>统计某一列的非空去重记录数。其实是 count(列名) + distinct 的结果集，指定列不为NULL，并且在字段值重复的情况下只统计一次</p></li></ul><p><strong>MylSAM 统计只需O(1)：</strong>如果是 <strong>MylSAM 存储引擎，统计数据表的行数只需要 O(1)的复杂度</strong>，因为每张 MyISAM 的数据表都有一个 meta 信息存储了 <strong>row_count 值</strong>，而一致性则由表级锁来保证。 如果是InnoDB 存储引擎，因为<strong>innoDB</strong> 支持事务，采用行级锁和 MVCC机制，无法像 MyISAM 维护1个row_count变量，因此<strong>需要采用扫描全表，是O(n)的复杂度</strong>，进行循环+计数的方式来完成统计。</p><p><strong>选择建议：</strong>在ImnoDB中，如果采用<strong>COUNT(具体字段)<strong>来统计数据行数，要</strong>尽量采用二级索引</strong>。因为主键是聚簇索引，聚簇索引叶节点包含整个记录，统计时要加载到内存的数据量更大，性能就差一点。对于COUNT(*)和 COUNT(1)来说，它们不需要查找具体的行，只是统计行数，<strong>系统会自动采用占用空间更小的二级索引来进行统计</strong>。 如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h2 id="建议SELECT-字段-而不是SELECT"><a href="#建议SELECT-字段-而不是SELECT" class="headerlink" title="建议SELECT(字段)而不是SELECT(*)"></a>建议SELECT(字段)而不是SELECT(*)</h2><p>在表查询中，建议明确字段，不要使用 <code>*</code> 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。<strong>原因</strong>：</p><ol><li>MySQL 在解析的过程中，会通过查询数据字典<strong>将<code>*</code>按序转换成所有列名</strong>，会大大耗费资源和时间。</li><li>无法使用覆盖索引</li></ol><blockquote><p><strong>数据库引擎的查询流程：</strong>参考文章<a href="/2025/07/26/database/db-mysql-6-query/">MySQL数据库-查询优化</a></p></blockquote><h2 id="LIMIT-1-对优化的影响"><a href="#LIMIT-1-对优化的影响" class="headerlink" title="LIMIT 1 对优化的影响"></a>LIMIT 1 对优化的影响</h2><p>针对的是<strong>会扫描全表的 SQL 语句</strong>，如果可以<strong>确定结果集只有一条</strong>，加上 LIMIT 1 时，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。</p><h2 id="全表扫描时尽量用“LIMIT”"><a href="#全表扫描时尽量用“LIMIT”" class="headerlink" title="全表扫描时尽量用“LIMIT”"></a>全表扫描时尽量用“LIMIT”</h2><p>当进行全表扫描并且明确时，使用LIMIT可以在达到指定数量后停止扫描，减少不必要的开销。</p><p>例如根据学号查询学生，根据身份证号查询人，根据订单号查询订单，当我们明确知道需要精准查询时，用Limit 1 总错不了。</p><p>当然如果走了唯一索引，就无需用limit了，查到对应记录会直接返回；如果走了普通索引，并且对应记录重复数据很多的话，用limit也会提高一些性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 根据学号（假设学号是按班级隔离的）和班级号精准查询学生</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">where</span> stuno <span class="operator">=</span><span class="number">23</span> <span class="keyword">and</span> classid<span class="operator">=</span><span class="number">1</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="使用limit-N，少用limit-M，N"><a href="#使用limit-N，少用limit-M，N" class="headerlink" title="使用limit N，少用limit M，N"></a>使用limit N，少用limit M，N</h2><p><strong>避免大偏移量的LIMIT</strong>：在大表或M值较大时，LIMIT M, N的性能较差，因为需要扫描并丢弃前M条记录。可以通过记录上次查询的最大ID来优化分页。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> last_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="将长事务拆为多个小事务"><a href="#将长事务拆为多个小事务" class="headerlink" title="将长事务拆为多个小事务"></a>将长事务拆为多个小事务</h2><ul><li><p><strong>提交事务可以释放的资源</strong>：回滚段上用于恢复数据的信息、锁、redo / undo log buffer 中的空间。</p></li><li><p><strong>多使用COMMIT</strong>：长事务会持有锁和占用资源较长时间，拆分为小事务并频繁COMMIT可以释放锁、减少资源占用。</p></li></ul><p>尽量多使用 COMMIT，用编程式事务而不是声明式事务，降低事务粒度。<strong>示例：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.查询a</span></span><br><span class="line">    <span class="comment">// 2.查询b</span></span><br><span class="line">    <span class="comment">// 3.数据处理</span></span><br><span class="line">    <span class="comment">// 4.保存c表</span></span><br><span class="line">    <span class="comment">// 5.保存b表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.查询a</span></span><br><span class="line">    <span class="comment">// 2.查询b</span></span><br><span class="line">    <span class="comment">// 3.数据处理</span></span><br><span class="line">    <span class="comment">// 4.落库</span></span><br><span class="line">    savaFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savaFun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.保存c表</span></span><br><span class="line">    <span class="comment">// 2.保存d表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先查再删改"><a href="#先查再删改" class="headerlink" title="先查再删改"></a>先查再删改</h2><p>UPDATE、DELETE语句一定要有明确的WHERE条件。</p><p><strong>确保WHERE条件明确</strong>：在执行UPDATE或DELETE操作前，先SELECT一下并不会让性能变差，它可以确保有明确的WHERE条件，避免误操作和全表扫描。</p><h2 id="尽量UNION-ALL而不是UNION"><a href="#尽量UNION-ALL而不是UNION" class="headerlink" title="尽量UNION ALL而不是UNION"></a>尽量UNION ALL而不是UNION</h2><p><strong>UNION ALL</strong>：UNION ALL 和 UNION 都用于组合两个或多个查询结果集。UNION ALL在组合时，<strong>不进行去重操作</strong>，比UNION更快，适用于不需要去重的场景。</p><h2 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h2><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p><p>COMMIT 所释放的资源：</p><ul><li>回滚段上用于恢复数据的信息</li><li>被程序语句获得的锁</li><li><code>redo / undo log buffer</code> 中的空间</li><li>管理上述 3 种资源中的内部花费</li></ul>]]></content>
    
    
    <summary type="html">‌数据库系统优化是通过调整数据库结构、参数及应用程序以提升系统性能的技术，目标是将低效SQL语句转换为高效等效语句。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://southernfish.github.io/2025/07/26/database/db-redis/"/>
    <id>https://southernfish.github.io/2025/07/26/database/db-redis/</id>
    <published>2025-07-26T02:15:36.000Z</published>
    <updated>2025-07-28T10:27:55.449Z</updated>
    
    <content type="html"><![CDATA[<p>Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</p><blockquote><p>参考原文：</p><p><a href="https://developer.aliyun.com/article/1608405">Redis缓存与数据库如何保证一致性？同步删除+延时双删+异步监听+多重保障方案</a></p></blockquote><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis 是一个使<strong>用 C 语言开发的高速缓存数据库</strong>。</p><h2 id="Redis-的功能"><a href="#Redis-的功能" class="headerlink" title="Redis 的功能"></a>Redis 的功能</h2><p>数据缓存功能、分布式锁的功能、持久化机制、支持事务、支持消息队列、键过期、lua脚本（基于C语言，性能快）。</p><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><p><strong>应用场景：</strong>缓存热点且不经常修改的数据、计数器、限时业务、分布式锁（set nx）、队列等。</p><ul><li>记录帖子点赞数、点击数、评论数</li><li>缓存近期热帖</li><li>缓存文章详情信息</li><li>记录用户会话信息</li></ul><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li><strong>数据库：</strong>Redis是一款基于键值对的、线程安全的NoSQL数据库；</li><li><strong>内存读写性能：</strong>它在内存中读写性能非常高，每秒可以处理超过百万次的读写操作。</li><li><strong>服务端线程安全，客户端线程不安全：</strong>Redis服务端是线程安全的，永远只有主线程一个线程进行读写，不需要任何的同步机制。虽然Redis6.0增加了多线程的模型，但多线程目的只是为了处理网络的IO事件，读写指令的执行依然由主线程自己处理。Redis客户端层面线程不安全，要引入原子指令（例如INCR是给数值原子性加1）、分布式锁、lua脚本保证Redis的原子操作。</li></ul><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><ul><li><strong>实现方式：</strong>MULTI（开启事务，将命令都放进队列里），EXEC（执行事务），DISCARD（取消事务，清空队列）。</li><li><strong>不支持回滚：</strong>在语法正确的情况下，Redis事务一定会执行成功。只有语法错误时才会导致事务失败，而语法问题应该在开发时就避免，所以为了提高性能，Redis事务不支持回滚。事务是一个原子操作，要么全部执行，要么全不执行。</li><li><strong>不完全满足ACID特性：</strong>Redis只满足隔离性和持久性，不满足原子性和一致性。<ul><li><strong>原子性：</strong>事务的所有操作，要么全部成功，要么全部失败。Redis不满足原子性，单个 Redis 命令的执行是原子性的，但事务失败后无法回滚。</li><li><strong>一致性：</strong>事务前后，数据库的约束没有被破坏，保持前后一致。Redis连约束这个概念都没有。</li><li><strong>隔离性：</strong>操作同一资源的并发事务之间相互隔离，不会互相干扰。Redis满足隔离性，因为redis server是单线程的，串行化执行事务，肯定是满足隔离性的。</li><li><strong>持久性：</strong>事务的结果最终一定会持久化到数据库，宕机等故障也无法影响。Redis在开启aof并指定立刻持久化命令时，满足持久性。rdb模式会丢失部分数据，不满足持久性。</li></ul></li></ul><h2 id="Redis的瓶颈"><a href="#Redis的瓶颈" class="headerlink" title="Redis的瓶颈"></a>Redis的瓶颈</h2><ul><li><strong>内存：</strong>因为读写在内存中进行，内存大小会影响Redis性能。可以通过加内存、读写分离优化性能。</li><li><strong>网络带宽：</strong>网络 IO是Redis最大瓶颈，即客户端和服务端之间的网络传输延迟。Redis6.0引入网络IO多线程模型，提高了性能瓶颈。</li></ul><h2 id="Redis-为什么是单线程的"><a href="#Redis-为什么是单线程的" class="headerlink" title="Redis 为什么是单线程的"></a>Redis 为什么是单线程的</h2><p>因为 <strong>cpu 不是 Redis 的瓶颈</strong>，Redis 的瓶颈<strong>最有可能是机器内存或者网络带宽</strong>。既然<strong>单线程容易实现</strong>，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>关于 <code>Redis</code> 的性能，官方网站也有，普通笔记本轻松处理<strong>每秒几十万的请求</strong>。<br>而且单线程并不代表就慢，<code>nginx</code> 和 <code>nodejs</code> 也都是高性能单线程的代表。</p><p><strong>Redis读写为什么不采用多线程？</strong></p><ul><li><strong>CPU不是瓶颈：</strong>Redis在内存中读写性能非常高，CPU不是Redis的瓶颈，无需使用多线程。</li><li><strong>担心加锁影响性能：</strong>多线程情况下，想实现线程安全必须加锁，加锁将极大地影响性能。</li></ul><p> <strong>为什么单线程还读写性能这么高？</strong></p><ul><li><strong>基于内存：</strong>Redis是基于内存的，内存的读写速度非常快；</li><li><strong>上下文切换：</strong>单线程避免了不必要的上下文切换和竞争条件；</li><li><strong>IO多路复用：</strong>底层采用NIO（非阻塞IO），NIO采用IO多路复用技术，一个线程通过多路复用器处理多个连接。IO多路复用技术选用epoll调用模型，红黑树存所有事件，链表存就绪事件。epoll_wait函数链表，通知应用程序读写操作。</li></ul><h2 id="Redis-支持的数据类型"><a href="#Redis-支持的数据类型" class="headerlink" title="Redis 支持的数据类型"></a>Redis 支持的数据类型</h2><p><code>string</code>（字符串）、<code>list</code>（列表）、<code>hash</code>（字典）、<code>set</code>（集合）、<code>zset</code>（有序集合）。</p><h2 id="Redis-持久化的两种方式"><a href="#Redis-持久化的两种方式" class="headerlink" title="Redis 持久化的两种方式"></a>Redis 持久化的两种方式</h2><p><strong>持久化机制：</strong></p><p><code>RDB（Redis Database）</code>：指定的时间间隔能对你的数据进行快照存储。</p><ul><li><strong>数据备份机制RDB（默认）：数据</strong>每隔一段时间写进磁盘rdb文件，故障后从文件读。可以在redis.conf配置多少秒内多少key修改时自动bgsave。占CPU和内存但恢复快，不能恢复完整数据。save命令是主进程立即执行一次RDB，其他所有命令进程阻塞。bgsave是子进程fork主进程，阻塞并拷贝一份主进程的页表（虚拟内存到物理内存的映射关系），然后子进程写数据到rdb文件，主进程继续处理用户请求。</li></ul><p><code>AOF（Append Only File）</code>：每一个收到的写命令都<strong>通过write函数追加到文件中</strong>。</p><ul><li><strong>追加文件机制AOF</strong>：命令日志按指定频率（默认立刻，在redis.conf配置为缓存一秒）写进磁盘aof文件，可以按条件（redis.conf配置，比上次重写aof文件超过多少百分比时自动重写、aof文件超过多大自动重写）自动重写aof文件中的命令（多次更新同一数据只有最近一次更新有效），故障后从文件读命令恢复数据。不占CPU和内存占IO，能恢复完整或故障1s前的数据但恢复慢。</li></ul><h2 id="Redis-淘汰策略有哪些"><a href="#Redis-淘汰策略有哪些" class="headerlink" title="Redis 淘汰策略有哪些"></a>Redis 淘汰策略有哪些</h2><p><code>volatile-lru</code>：从已<strong>设置过期时间的数据集</strong>（<code>server.db[i].expires</code>）中挑选<strong>最近最少使用的数据</strong>淘汰。<br><code>volatile-ttl</code>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选<strong>将要过期的数据</strong>淘汰。<br><code>volatile-random</code>：从已设置过期时间的数据集（<code>server db[i].expires</code>）中<strong>任意选择数据</strong>淘汰。<br><code>allkeys-lru</code>：从<strong>数据集</strong>（<code>server.db[i].dict</code>）中挑选<strong>最近最少使用的数据</strong>淘汰。<br><code>allkeys-random</code>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。<br><code>no-enviction</code>（驱逐）：<strong>禁止驱逐数据</strong>。</p><h2 id="哨兵和集群机制"><a href="#哨兵和集群机制" class="headerlink" title="哨兵和集群机制"></a>哨兵和集群机制</h2><p><code>Redis哨兵（Sentinel）</code>是一个高可用性解决方案。哨兵系统可以<strong>监测Redis主从服务器的健康状态，自动执行故障转移，选举新的主服务器，并通知应用程序新主服务器的地址</strong>。哨兵还负责通知管理员，发送警报，并执行自定义脚本响应各种事件。<br><code>Redis集群（Cluster）</code>提供了一个<strong>数据分区（sharding）和自动管理的环境，支持在多个节点间进行数据共享</strong>。它能够在<strong>节点间自动分配数据，并在节点故障时提供自动的故障转移功能</strong>。集群通过分片来提高数据库的可扩展性，并能在不中断服务的情况下，动态地添加或移除节点。</p><h2 id="Redis-和-memcache-的区别"><a href="#Redis-和-memcache-的区别" class="headerlink" title="Redis 和 memcache 的区别"></a>Redis 和 memcache 的区别</h2><ul><li><strong>存储方式不同：</strong><code>memcache</code> 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；<code>Redis</code> 有<strong>部份存在硬盘上，这样能保证数据的持久性</strong>。</li><li><strong>数据支持类型：</strong>memcache 对数据类型支持相对简单；Redis 有<strong>复杂的数据类型</strong>。</li><li><strong>使用底层模型不同：</strong>它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，<strong>Redis 自己构建了 vm 机制</strong>，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li><strong>value 值大小不同：Redis 最大可以达到 512mb；</strong>memcache 只有 1mb。</li></ul><h2 id="jedis-和-Redisson-的区别"><a href="#jedis-和-Redisson-的区别" class="headerlink" title="jedis 和 Redisson 的区别"></a>jedis 和 Redisson 的区别</h2><p><code>jedis</code>：提供了比较全面的 Redis 命令的支持。<br><code>Redisson</code>：实现了<strong>分布式和可扩展的 Java 数据结构</strong>，与 jedis 相比 Redisson 的<strong>功能相对简单，不支持排序、事务、管道、分区等 Redis 特性</strong>。</p><h2 id="Redis-支持的-Java-客户端都有哪些"><a href="#Redis-支持的-Java-客户端都有哪些" class="headerlink" title="Redis 支持的 Java 客户端都有哪些"></a>Redis 支持的 Java 客户端都有哪些</h2><p>支持的 Java 客户端有 <code>Redisson</code>、<code>jedis</code>、<code>lettuce</code> 等。</p><h2 id="Redis-如何做内存优化"><a href="#Redis-如何做内存优化" class="headerlink" title="Redis 如何做内存优化"></a>Redis 如何做内存优化</h2><p><strong>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储</strong>，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p><h2 id="Redis-常见的性能问题及解决"><a href="#Redis-常见的性能问题及解决" class="headerlink" title="Redis 常见的性能问题及解决"></a>Redis 常见的性能问题及解决</h2><p><strong>主服务器写内存快照，会阻塞主线程的工作</strong>，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以<strong>主服务器最好不要写内存快照</strong>。<br><code>Redis 主从复制</code>的性能问题，为了主从复制的速度和连接的稳定性，<strong>主从库最好在同一个局域网内</strong>。</p><h2 id="Redis的缓存穿透、缓存击穿、缓存雪崩"><a href="#Redis的缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="Redis的缓存穿透、缓存击穿、缓存雪崩"></a>Redis的缓存穿透、缓存击穿、缓存雪崩</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透：缓存和数据库中都没有的数据，可用户仍源源不断的发起请求</strong>，导致每次请求都到数据库，从而压垮数据库<br><strong>解决办法</strong></p><ul><li><strong>业务层校验</strong><ul><li>用户发过来的请求，<strong>根据请求参数进行校验</strong>，对于明显错误的参数，直接拦截返回。</li><li>如请求参数为主键自增id，那么对于请求小于0的id参数，可以直接返回错误请求。</li></ul></li><li><strong>不存在数据设置短过期时间</strong><ul><li>对于某个查询为空的数据，可以将这个空结果进行<code>Redis</code>缓存，但设置很短的过期时间，如30s，可以根据实际业务设定。</li></ul></li><li><strong>布隆过滤器</strong><ul><li>布隆过滤器是<strong>一种数据结构，利用极小的内存，可以判断大量的数据</strong>“一定不存在或者可能存在”。</li><li>对于缓存击穿，我们可以将查询的数据条件都哈希到一个足够大的布隆过滤器中，用户发送的<strong>请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了</strong>，从而避免下一步对数据库的压力。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620114220915.png" alt="image-20250620114220915"></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿：Redis中一个<code>热点key</code>在失效的同时，大量的请求过来</strong>，从而会全部到达数据库，压垮数据库。<br><strong>解决办法</strong></p><ul><li><strong>设置热点数据永不过期</strong><ul><li>对于某个需要频繁获取的信息，缓存在Redis中，并设置其永不过期。</li><li>当然这种方式比较粗暴，对于某些业务场景是不适合的。</li></ul></li><li><strong>定时更新</strong><ul><li>比如这个热点数据的过期时间是1h，那么每到59minutes时，</li><li>通过定时任务去更新这个热点key，并重新设置其过期时间。</li></ul></li><li><strong>互斥锁（常用</strong>）<ul><li>在<code>Redis</code>中根据key获得value为空时先锁上，再从数据库加载，加载完毕，释放锁。</li><li>若其他线程也在请求该key时，获取锁失败，则睡眠一段时间（如100ms）后重试。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620115506995.png" alt="image-20250620115506995"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩：Redis中缓存的数据大面积同时失效，或者Redis宕机</strong>，从而会导致大量请求直接到数据库，压垮数据库。<br><strong>解决办法</strong></p><ul><li><strong>设置有效期均匀分布</strong><ul><li>避免缓存设置相近的有效期，我们可以在设置有效期时增加随机值；</li><li>或者统一规划有效期，使得过期时间均匀分布。</li></ul></li><li><strong>数据预热</strong><ul><li>对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。</li></ul></li><li><strong>保证Redis服务高可用</strong><ul><li>为防止Redis集群单节点故障，可以通过哨兵模式和集群模式实现高可用。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620115530134.png" alt="image-20250620115530134"></p><hr><h1 id="Redis和数据库数据一致性"><a href="#Redis和数据库数据一致性" class="headerlink" title="Redis和数据库数据一致性"></a>Redis和数据库数据一致性</h1><p><strong>合理设置缓存的过期时间</strong>。<br>新增、更改、删除数据库操作时<strong>同步更新 Redis</strong>，可以使<strong>用事务机制来保证数据的一致性</strong>。</p><h2 id="四种基础同步策略"><a href="#四种基础同步策略" class="headerlink" title="四种基础同步策略"></a><strong>四种基础同步策略</strong></h2><h3 id="同步策略"><a href="#同步策略" class="headerlink" title="同步策略"></a><strong>同步策略</strong></h3><p>保证缓存和数据库的双写一致性，共有<strong>四种同步策略</strong>，即先更新缓存再更新数据库、先更新数据库再更新缓存、先删除缓存再更新数据库、先更新数据库再删除缓存。 </p><ul><li>先更新缓存再更新数据库：第二步失败缓存库是脏数据</li><li><strong>先更新数据库再更新缓存：</strong>第二步失败缓存库是旧数据</li><li>先删除缓存再更新数据库：第二步失败缓存库是空数据</li><li><strong>先更新数据库、再删除缓存（推荐）：</strong>第二步失败缓存库是旧数据 </li></ul><h3 id="更新缓存还是删除缓存"><a href="#更新缓存还是删除缓存" class="headerlink" title="更新缓存还是删除缓存"></a>更新缓存还是删除缓存</h3><h4 id="更新缓存的优缺点"><a href="#更新缓存的优缺点" class="headerlink" title="更新缓存的优缺点"></a>更新缓存的优缺点</h4><p>更新缓存的优点是每次数据变化时都能<strong>及时地更新缓存</strong>，这样不容易出现查询未命中的情况，但这种操作的<strong>消耗很大</strong>，如果数据需要经过复杂的计算再写入缓存的话，频繁的更新缓存会影响到服务器的性能。如果是写入数据比较频繁的场景，可能会导致频繁的更新缓存却没有业务来读取该数据。</p><h4 id="删除缓存的优缺点（推荐）"><a href="#删除缓存的优缺点（推荐）" class="headerlink" title="删除缓存的优缺点（推荐）"></a><strong>删除缓存</strong>的优缺点（推荐）</h4><p>删除缓存的优点是<strong>操作简单</strong>，无论更新的操作复杂与否，都是直接删除缓存中的数据。这种做法的缺点则是，当删除了缓存之后，下一次容易出现未命中的情况，那么这时就需要再次读取数据库。 </p><p>那么对比而言，<strong>删除缓存无疑是更好的选择</strong>。 </p><h3 id="先操作数据库还是先删除缓存"><a href="#先操作数据库还是先删除缓存" class="headerlink" title="先操作数据库还是先删除缓存"></a>先操作数据库还是先删除缓存</h3><h4 id="先删除缓存再操作数据库的优缺点"><a href="#先删除缓存再操作数据库的优缺点" class="headerlink" title="先删除缓存再操作数据库的优缺点"></a><strong>先删除缓存再操作数据库的优缺点</strong></h4><p><strong>情况1：数据库和缓存内容不一致</strong></p><p>线程1删除缓存后还没有来得及更新数据库时，线程2读缓存，由于缓存中的数据已经被线程1清空了所以线程2需要去数据库读数据，然后把读到的结果保存到缓存中。此时线程1更新更新数据库成功。就会出现数据库和缓存内容不一致。</p><p><strong>情况2：缓存击穿，数据库卡死</strong></p><p>线程1删除缓存后还没有来得及更新数据库时，来了大量的读请求，由于缓存中没有数据，导致缓存击穿直接将大量请求访问到数据库，导致数据库崩溃。</p><h4 id="先操作数据库再删除缓存的优缺点（推荐）"><a href="#先操作数据库再删除缓存的优缺点（推荐）" class="headerlink" title="先操作数据库再删除缓存的优缺点（推荐）"></a>先操作数据库再删除缓存的优缺点（推荐）</h4><p><strong>脏数据问题：</strong>先操作数据库但删除缓存失败的话，导致缓存库里一直存留着旧数据，而我们数据库里存的是新数据。</p><p><strong>解决办法：异步重试机制</strong></p><p>出现上述问题的时候，我们一般采用重试机制解决，而为了避免重试机制影响主要业务的执行，一般建议重试机制采用<strong>异步</strong>的方式执行。当我们采用重试机制之后由于存在并发，先删除缓存依然可能存在缓存中存储了旧的数据，而数据库中存储了新的数据，二者数据不一致的情况。</p><h3 id="最优同步策略：先更新数据库、再删除缓存"><a href="#最优同步策略：先更新数据库、再删除缓存" class="headerlink" title="最优同步策略：先更新数据库、再删除缓存"></a>最优同步策略：<strong>先更新数据库、再删除缓存</strong></h3><p><strong>先更新数据库、再删除缓存是影响更小的方案</strong>。如果第二步出现失败的情况，则可以采用<strong>重试机制</strong>解决问题。</p><p><strong>同步删除方案：</strong> 先更新数据库、再删除缓存。适用于不强制要求数据一致性的情景</p><p><strong>流程：</strong>先更新数据库、再删除缓存。</p><p><strong>问题：</strong></p><ul><li><strong>并发时脏数据：</strong>在查询数据库到写缓存期间其他线程执行了一次更新删除，导致缓存的数据是旧数据</li><li><strong>缓存删除失败：</strong>删除失败导致缓存库还是旧数据</li></ul><h2 id="同步删除-可靠消息方案"><a href="#同步删除-可靠消息方案" class="headerlink" title="同步删除+可靠消息方案"></a><strong>同步删除+可靠消息方案</strong></h2><p><strong>同步删除+可靠消息删除：</strong> 适用于不强制要求数据一致性的情景</p><p><strong>流程：</strong>先更新数据库、再删除缓存，如果删除失败就发可靠MQ不断重试删除缓存，直到删除成功或重试5次。</p><p><strong>问题：</strong>MQ多次重试失败，导致长期脏数据。</p><h2 id="延时双删：更高一致性方案"><a href="#延时双删：更高一致性方案" class="headerlink" title="延时双删：更高一致性方案"></a><strong>延时双删：更高一致性方案</strong></h2><p><strong>延时双删方案：</strong>比同步删除策略一致性更高的方案。</p><p><strong>流程：</strong>先删除缓存再更新数据库，大约在数据库从库更新后再删一次。</p><p><strong>问题：</strong>时间无法控制，不能保证在数据库从库更新后删除缓存。若在从库更新前删除，用户再在更新前查从库又把脏数据写在缓存里了。</p><h2 id="异步监听-可靠消息删除方案"><a href="#异步监听-可靠消息删除方案" class="headerlink" title="异步监听+可靠消息删除方案"></a><strong>异步监听+可靠消息删除方案</strong></h2><p><strong>异步监听+可靠消息删除：</strong>很多大厂正在使用的方案。</p><p><strong>流程：</strong></p><ol><li>更新数据库后不做操作；</li><li><code>Canal</code>等组件监听binlog发现有更新时就发可靠MQ删除缓存；</li><li>如果删除缓存失败，就基于手动<code>ack、retry</code>等机制，让消息在有限次数之内不断重试。</li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250722220829774.png" alt="image-20250722220829774"></p><p><strong>优点：</strong></p><ul><li>异步删除，性能更高；</li><li>可靠消息重试机制，多次删除保证删除成功。</li></ul><p><strong>问题：</strong>要求<code>canal</code>等<code>binlog</code>抓取组件高可用，如果canal故障，会导致长期脏数据。</p><h2 id="多重保障：最终强一致方案"><a href="#多重保障：最终强一致方案" class="headerlink" title="多重保障：最终强一致方案"></a>多重保障：最终强一致方案</h2><p><strong>多重保障方案：</strong>同步删除+ 异步监听+可靠消息删除，缓存时设置过期时间，查询时强制主库查；适合于强制要求数据一致性的情况</p><ol><li><strong>同步删除：</strong>先更新数据库、再删除缓存；之后本链路禁止再查该数据，防止没来得及删缓存就又查到旧缓存数据。</li><li><strong>Canal监听：</strong>Canal等组件监听binlog发现有更新时就发可靠MQ删除缓存；第二重保证删缓存成功；</li><li><strong>延迟消息校验一致性：</strong>Canal等组件监听binlog，发延迟MQ，N秒后校验缓存一致性；</li><li><strong>缓存过期时间：</strong>每次缓存时设置过期时间；第三重保证删缓存成功；</li><li><strong>强制Redis主库查：</strong>以后查缓存时强制从缓存主库查；因为主从同步有延迟，同时不用担心主库压力大，因为分片集群机制。</li></ol><hr><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><strong>分布式锁</strong></p><ul><li>控制分布式系统<strong>不同进程共同访问共享资源</strong>的一种锁的实现。</li><li>如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往<strong>需要互斥来防止彼此干扰，以保证一致性</strong>。</li></ul><p><strong>特征</strong></p><ul><li><code>互斥性</code>: 任意时刻，只有一个客户端能持有锁。</li><li><code>锁超时释放</code>：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。</li><li><code>可重入性</code>:一个线程如果获取了锁之后,可以再次对其请求加锁。</li><li><code>高性能和高可用</code>：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。</li><li><code>安全性</code>：锁只能被持有的客户端删除，不能被其他客户端删除。</li></ul><p><strong>Redis分布式锁</strong></p><ul><li>其实就是在系统里面<strong>占一个“坑”，其他程序也要占“坑”时，占用成功了就可继续执行，失败了只能放弃或稍后重试</strong>。</li></ul><h2 id="Redis-分布式锁的缺陷"><a href="#Redis-分布式锁的缺陷" class="headerlink" title="Redis 分布式锁的缺陷"></a>Redis 分布式锁的缺陷</h2><p>Redis 分布式锁不能解决超时的问题，分布式锁<strong>有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题</strong>。</p><h2 id="Redis分布式锁实现"><a href="#Redis分布式锁实现" class="headerlink" title="Redis分布式锁实现"></a>Redis分布式锁实现</h2><h3 id="方案一：SETNX-EXPIRE"><a href="#方案一：SETNX-EXPIRE" class="headerlink" title="方案一：SETNX + EXPIRE"></a>方案一：SETNX + EXPIRE</h3><p><strong>先用<code>setnx</code>来抢锁，抢到之后，再用<code>expire</code>给锁设置一个过期时间，防止锁忘记了释放</strong>。<br>SETNX 是<code>SET IF NOT EXISTS</code>的简写。命令格式是<code>SETNX key value</code>，若 key不存在，则SETNX成功返回1，若这个key已经存在，则返回0。<br>该方案中，setnx和expire两个命令分开了，<strong>不是原子操作</strong>。若执行完setnx加锁，正要执行expire设置过期时间时，进程crash或要重启维护了，那么这个锁就“长生不老”了，<strong>别的线程永远获取不到锁</strong>。<br>假设某电商网站的<strong>某商品做秒杀活动</strong>，key可以设置为<code>key_resource_id,value</code>设置任意值，<em>伪代码如下</em>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.setnx(key_resource_id, lock_value) == 1)&#123; // 加锁</span><br><span class="line">  expire(key_resource_id，100);// 设置过期时间</span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="keyword">do</span> something // 业务请求</span><br><span class="line">  &#125; <span class="function"><span class="title">catch</span></span>()&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125; finally&#123;</span><br><span class="line">    jedis.del(key_resource_id); // 释放锁</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二：SETNX-value值是-系统时间-过期时间"><a href="#方案二：SETNX-value值是-系统时间-过期时间" class="headerlink" title="方案二：SETNX + value值是(系统时间+过期时间)"></a>方案二：SETNX + value值是(系统时间+过期时间)</h3><p>为了<em>解决发生异常锁得不到释放的场景</em>，<strong>把过期时间放到<code>setnx</code>的<code>value</code>值里面</strong>。若加锁失败，再拿出value值校验一下即可</p><p>但这个方案有<strong>缺点</strong>：<br>过期时间是客户端自己生成的（<code>System.currentTimeMillis()</code>是当前系统的时间），要求分布式环境下，每个<strong>客户端的时间必须同步</strong>。<br>若锁过期的时候，并发多个客户端同时请求过来，都执行<code>jedis.getSet()</code>，最终只能有一个客户端加锁成功，但该客户端锁的过期时间，可能被别的客户端覆盖。<br><strong>该锁没有保存持有者的唯一标识，可能被别的客户端释放/解锁。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">long expires = System.currentTimeMillis() + expireTime;// 系统时间+设置的过期时间</span><br><span class="line">String expiresStr = String.value0f(expires);</span><br><span class="line">// 如果当前锁不存在，返回加锁成功</span><br><span class="line"><span class="keyword">if</span>(jedis.setnx(key resource <span class="built_in">id</span>,expiresStr) == 1)&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 如果锁已经存在，获取锁的过期时间</span><br><span class="line">String currentValueStr = jedis.get(key resource <span class="built_in">id</span>);</span><br><span class="line">// 如果杂取到的过期时间，小于系统当前时间，表示已经过期</span><br><span class="line"><span class="keyword">if</span>(currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis())&#123;</span><br><span class="line">  // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span><br><span class="line">  String oldValueStr =jedis.getSet(key resource <span class="built_in">id</span>, expiresStr);</span><br><span class="line">  <span class="keyword">if</span>(oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr))&#123;</span><br><span class="line">    // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 其他情况，均返回加锁失败</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="方案三：使用Lua脚本-包含SETNX-EXPIRE两条指令"><a href="#方案三：使用Lua脚本-包含SETNX-EXPIRE两条指令" class="headerlink" title="方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)"></a>方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)</h3><p>可以使用Lua脚本来保证原子性（包含<code>setnx</code>和<code>expire</code>两条指令）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// lua脚本如下：</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>,KEYS[1],ARGV[1]) == 1 <span class="keyword">then</span></span><br><span class="line">   redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[1],ARGV[2])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">return</span> 0</span><br><span class="line">end;</span><br><span class="line">// 加锁代码如下：</span><br><span class="line">String lua_scripts = <span class="string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class="line">        <span class="string">&quot; redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;   </span><br><span class="line">Object result = jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));</span><br><span class="line">//判断是否成功</span><br><span class="line"><span class="built_in">return</span> result.equals(1L);</span><br></pre></td></tr></table></figure><h3 id="方案四：SET的扩展命令（SET-EX-PX-NX）"><a href="#方案四：SET的扩展命令（SET-EX-PX-NX）" class="headerlink" title="方案四：SET的扩展命令（SET EX PX NX）"></a>方案四：SET的扩展命令（SET EX PX NX）</h3><p>巧用Redis的SET指令扩展参数，它也是原子性的！伪代码如下：<br><code>SET key value[EX seconds][PX milliseconds][NX|XX]</code></p><ul><li><code>NX</code>：表示key不存在时，才能set成功，也保证只有第一个客户端请求才能获得锁。其他客户端请求只能等其释放锁，才能获取。</li><li><code>EX seconds</code>：设定key的过期时间，时间单位是秒。</li><li><code>PX milliseconds</code>：设定key的过期时间，单位为毫秒</li><li><code>XX</code>：仅当key存在时设置值</li></ul><p>这个方案可能<strong>存在问题</strong>：</p><ul><li><strong>锁过期释放了，业务还没执行完</strong>。<ul><li>假设线程a获取锁成功，一直在执行临界区的代码。100s过去后，它还没执行完。但锁已过期，此时线程b请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么临界区的业务代码都不是严格串行执行的了。</li></ul></li><li><strong>锁被别的线程误删</strong><ul><li>假设线程a执行完后，去释放锁。但它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但线程b临界区业务代码可能都还没执行完。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.set(key_resource <span class="built_in">id</span>, lock_value, <span class="string">&quot;NX&quot;</span>,<span class="string">&quot;EX&quot;</span>，100s) == 1)&#123; // 加锁</span><br><span class="line">  try &#123;</span><br><span class="line">    // <span class="keyword">do</span> something 业务处理</span><br><span class="line">  &#125; <span class="function"><span class="title">catch</span></span>()&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    jedis.del(key_resource_id); // 释放锁</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案五：SET-EX-PX-NX-校验唯一随机值，再删除"><a href="#方案五：SET-EX-PX-NX-校验唯一随机值，再删除" class="headerlink" title="方案五：SET EX PX NX  + 校验唯一随机值，再删除"></a>方案五：SET EX PX NX  + 校验唯一随机值，再删除</h3><p>既然锁可能被别的线程误删，那我们<strong>给value值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下</strong>，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.<span class="built_in">set</span>(key _resource id, uni_request id, <span class="string">&quot;NX&quot;</span>,<span class="string">&quot;EX&quot;</span>，<span class="number">100</span>s) == <span class="number">1</span>)&#123; <span class="comment">// 加锁</span></span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="comment">// do something 业务处理</span></span><br><span class="line">  &#125; catch()&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    <span class="comment">// 判断是不是当前线程加的锁, 是才释放</span></span><br><span class="line">    <span class="keyword">if</span>(uni request id.equals(jedis.get(key resource id)))&#123;</span><br><span class="line">      jedis.del(lockKey);<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断是不是当前线程加的锁 和 释放锁 不是原子操作</strong>。调用<code>jedis.del()</code>释放锁时，可能这把锁已经不属于当前客户端，会解除他人加的锁。<br>为了更严谨，用lua脚本代替。lua脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[1]) == ARGV[1] <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[1])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h3 id="方案六：Redisson框架"><a href="#方案六：Redisson框架" class="headerlink" title="方案六：Redisson框架"></a>方案六：Redisson框架</h3><p><code>Redisson</code>框架下，只要线程加锁成功，就会启动一个<code>watch dog</code>看门狗（一个后台线程），每隔10秒检查一下，若线程1还持有锁，就会不断延长锁key的生存时间。因此，<code>Redisson</code><strong>解决了<em>锁过期释放，业务没执行完</em>问题</strong>。Redisson底层原理如图所示：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620122023110.png" alt="image-20250620122023110"></p><h3 id="方案七：多机实现的分布式锁Redlock-Redisson"><a href="#方案七：多机实现的分布式锁Redlock-Redisson" class="headerlink" title="方案七：多机实现的分布式锁Redlock+Redisson"></a>方案七：多机实现的分布式锁Redlock+Redisson</h3><p>前六种方案都是基于单机版。但Redis一般都是集群部署的（如图）：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620122038873.png" alt="image-20250620122038873"></p><p>若线程一在Redis的master节点上拿到了锁，但加锁的key还没同步到slave节点。恰好这时master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁，但线程一也已经拿到锁了，锁的安全性就没了。</p><h3 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h3><p><strong>Redlock核心思想：</strong><br>搞多个<code>Redis master</code>部署，以保证它们不会同时宕掉。并且<strong>这些master节点是完全相互独立的，相互之间不存在数据同步</strong>。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。<br><strong>RedLock的简化实现步骤：</strong></p><ul><li>按顺序向<code>N</code>（N=5）个master节点请求加锁</li><li>根据设置的超时时间来判断，是不是要跳过该master节点。</li><li>如果**大于等于<code>N/2+1</code>**（5/2+1=3）个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功。</li><li>如果获取锁失败，解锁！</li></ul><p><strong>RedLock的实现步骤：</strong></p><ul><li><p>获取当前时间，以毫秒为单位。</p></li><li><p>按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，且超时时间要小于锁的失效时间。</p><ul><li>（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间，就假设超时时间是50ms）。若超时则跳过该master节点，尽快尝试下一个master节点。</li></ul></li><li><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如图，10s&gt; 30ms+40ms+50ms+40ms+50ms）</p><ul><li><p>如果<strong>获取到了锁</strong>，key的真正有效时间就变了，需要减去获取锁所使用的时间。</p></li><li><p>如果<strong>获取锁失败</strong>（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也<strong>需要解锁</strong>，以防止有些漏网之鱼）。</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/1750393665152.png" alt="1750393665152"></p>]]></content>
    
    
    <summary type="html">‌Redis(Remote Dictionary Server)，远程字典服务，是用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言的API。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="Redis" scheme="https://southernfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库-索引</title>
    <link href="https://southernfish.github.io/2025/07/25/database/db-mysql-3-index/"/>
    <id>https://southernfish.github.io/2025/07/25/database/db-mysql-3-index/</id>
    <published>2025-07-25T02:30:36.000Z</published>
    <updated>2025-07-28T10:27:55.448Z</updated>
    
    <content type="html"><![CDATA[<p>索引是数据库中用来提高数据检索效率的<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>。它类似于书籍的目录，可以帮助用户快速找到所需的数据，而不必扫描整个数据集。在数据库系统中，索引可以显著提高查询性能。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130355955">MySQL高级篇——性能分析工具</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130804019">MySQL高级篇——覆盖索引、前缀索引、索引下推、SQL优化、主键设计</a></p></blockquote><h1 id="索引的分类与使用"><a href="#索引的分类与使用" class="headerlink" title="索引的分类与使用"></a>索引的分类与使用</h1><p>索引是<strong>满足某种特定查找算法的数据结构</strong>，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 <strong><code>B+ 树</code><strong>实现的，</strong><code>B+ 树</code>的搜索效率，可到达二分法的性能</strong>，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><ol><li>从<strong>功能逻辑</strong>上说，索引主要有 4 种，分别是<strong>普通索引、唯一索引、主键索引、全文索引</strong>。</li><li>按照<strong>物理实现方式</strong>，索引可以分为 2 种：<strong>聚簇索引和非聚簇索引</strong>。</li><li>按照作用<strong>字段个数</strong>进行划分，分成<strong>单列索引和联合索引</strong>。</li></ol><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>在创建普通索引时，<strong>不附加任何限制条件</strong>，只是用于提高查询效率。这类索引可以创建在<strong>任何数据类型</strong>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>使用UNIQUE参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该<strong>索引的值</strong>必须是<strong>唯一</strong>的，但<strong>允许有多个空值</strong>。在一张数据表里可以有多个唯一索引。</p><p><strong>唯一约束和唯一索引的区别：</strong></p><ul><li>唯一约束和唯一索引，都可以实现列数据的唯一，列值可以有null。</li><li><strong>唯一约束自动创建不独立的唯一索引：</strong>创建唯一约束，会自动创建一个同名的唯一索引，该索引<strong>不能单独删除</strong>，删除约束会自动删除索引。唯一约束是通过唯一索引来实现数据的唯一。</li><li>创建一个唯一索引，这个索引就是独立，可以单独删除。</li><li>如果一个列上想有约束和索引，且两者可以单独的删除。可以先建唯一索引，再建同名的唯一约束。</li><li><strong>外键必须是唯一约束：</strong>如果表的一个字段，要作为另外一个表的外键，这个字段必须有唯一约束（或是主键），如果只是有唯一索引，就会报错。</li></ul><h3 id="主键索引（唯一非空）"><a href="#主键索引（唯一非空）" class="headerlink" title="主键索引（唯一非空）"></a>主键索引（唯一非空）</h3><p>主键索引就是一种特殊的唯一性索引，在<strong>唯一</strong>索引的基础上增加了<strong>不为空</strong>的约束，也就是NOTNULL+UNIQUE，<strong>一张表最多只有一个主键索引</strong>。这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>在表中的<strong>单个字段</strong>上创建<strong>索引</strong>。单列索引<strong>只根据该字段</strong>进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p><h3 id="多列-组合、联合-索引"><a href="#多列-组合、联合-索引" class="headerlink" title="多列(组合、联合)索引"></a>多列(组合、联合)索引</h3><p>多列索引是在表的<strong>多个字段组合</strong>上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但只有查询条件中使用了这些字段中的第一个字段时才会被使用。使用组合索引时<strong>遵循最左前缀集合</strong>。</p><blockquote><p><strong>最左前缀集合：</strong>指的是由多个列组成的联合索引，在查询时只会使用最左边的几个列进行索引查询。具体来说，如果一个联合索引包含了列A、B和C三列，那么MySQL只能使用A、A+B或者A+B+C这三种方式进行查询。而不能仅仅使用B或者C列进行查询。</p></blockquote><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用**[分词术]<strong>等多种算法智能</strong>分析<strong>出文本文字中</strong>关键词的频率和重要性<strong>，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常</strong>适合大型数据集**，对于小的数据集，它的用处比较小。</p><p>使用<strong>参数FULLTEXT</strong>可以设置索引为全文索引。在定义索引的列上支持值的全文查找，<strong>允许</strong>在这些索引列中插入<strong>重复值和空值</strong>。全文索引只能创建在CHAR、VARCHAR或TEXT类型及其系列类型的字段上，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT类型该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p><p>全文索引典型的有两种类型：<strong>自然语言的全文索引和布尔全文索引</strong></p><p>自然语言搜索引擎将计算每一个文档对象和查询的<strong>相关度</strong>。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中<strong>出现次数越少</strong>的词语，匹配时的<strong>相关度就越高</strong>。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</p><p>MySQL数据库从3.23.23版开始支持全文索引，但MySQL5.6.4以前只有Myisam支持，5.6.4版本以后innodb才支持，但是官方版本不支持中文分词，需要第三方分词插件。在<strong>5.7.6版本</strong>，MySQL内置了<strong>ngram全文解析器</strong>，用来<strong>支持亚洲语种的分词</strong>。试或使用全文索引时，要先看一下自己的MySQL版本、存储引擎和数据类型是否支持全文索引。</p><p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被solrElasticSearch等专门的搜索引擎所替代。</p><h3 id="空间索引（不常用）"><a href="#空间索引（不常用）" class="headerlink" title="空间索引（不常用）"></a>空间索引（不常用）</h3><p>使用<strong>参数SPATIAL</strong>可以设置索引为空间索引。空间索引只能建立在<strong>空间数据类型</strong>上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON等。</p><p>目前<strong>只有MyISAM存储引擎支持空间检索</strong>，而且<strong>索引的字段不能为空值</strong>。对于初学者来说，这类索引<strong>很少会用到</strong>。</p><p><strong>小结：不同的存储引擎支持的索引类型也不一样</strong></p><ul><li><strong>InnoDB</strong>：支持B-tree、Full-text等索引，不支持Hash索引</li><li><strong>MyISAM</strong>：支持B-tree、Full-text等索引，不支持Hash索引</li><li><strong>Memory</strong>：支持B-tree、Hash等索引，不支持Full-text索引</li><li><strong>NDB</strong>：支持Hash索引，不支持B-tree、Full-text等索引</li><li><strong>Archive</strong>：不支持B-tree、Hash、Full-text等索引</li></ul><h2 id="建表时创建索引"><a href="#建表时创建索引" class="headerlink" title="建表时创建索引"></a>建表时创建索引</h2><p>MySQL支持多种方法在单个或多个列上创建索引： 在<strong>创建表</strong>的定义语句 <strong>CREATE TABLE</strong> 中指定索引列，使用<strong>ALTER TABLE</strong>语句在<strong>存在的表上创建索引</strong>，或者使用<strong>CREATE INDEX</strong>语句在已<strong>存在的表上添加索引</strong>。</p><h3 id="约束字段会隐式自动创建索引"><a href="#约束字段会隐式自动创建索引" class="headerlink" title="约束字段会隐式自动创建索引"></a>约束字段会隐式自动创建索引</h3><p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义<strong>主键约束、外键约束或者唯一性约束</strong>而不论创建哪种约束，在定义<strong>约束的同时相当于</strong>在指定列上<strong>创建</strong>了一个<strong>索引</strong>。</p><p>例如下面部门员工表的主键、唯一字段都<strong>隐式的</strong>创建了索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">    dept_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,        # 主键会自动创建主键索引</span><br><span class="line">    dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">    emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    emp_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,                # 唯一约束会自动创建唯一索引</span><br><span class="line">    dept_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> emp_dept_id_fk <span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="显式、创建表的时候创建索引"><a href="#显式、创建表的时候创建索引" class="headerlink" title="显式、创建表的时候创建索引"></a>显式、创建表的时候创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 [字段名 字段类型]</span><br><span class="line">[<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY] [索引名] (字段名 [length]) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>UNIQUE 、FULLTEXT 和SPATIAL 为可选参数</strong>，分别表示唯一索引、全文索引和空间索引；</li><li><strong>INDEX 与KEY 为同义词</strong>，两者的作用相同，用来指定创建索引；</li><li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li><li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li><strong>length</strong> 为可选参数，表示<strong>索引的长度</strong>，只有字符串类型的字段才能指定索引长度；</li><li><strong>ASC 或DESC</strong> 指定<strong>升序或者降序的索引值存储</strong>。</li></ul></blockquote><p><strong>常见索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#  <span class="number">1.</span>创建普通索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    ...</span><br><span class="line">    year_publication <span class="keyword">YEAR</span>,            # 被索引的字段</span><br><span class="line">    INDEX(year_publication)         # 普通索引，不附加任何限制条件；不指定索引名，那么默认字段名为索引名；</span><br><span class="line">);</span><br><span class="line"># <span class="number">2.</span>创建唯一索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                # 被索引的字段</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX uk_idx_id(id)        # 索引的值必须是唯一的，但允许有空值。</span><br><span class="line">);</span><br><span class="line"># <span class="number">3.</span>主键索引</span><br><span class="line"># <span class="number">3.1</span> 设定为主键后数据库会自动建立索引，innodb为聚簇索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED AUTO_INCREMENT ,    # 被索引字段</span><br><span class="line">    ...</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id)                            # 主键索引，唯一不为空</span><br><span class="line">);</span><br><span class="line"># <span class="number">3.2</span> 删除主键索引，修改主键索引：必须先删除掉(<span class="keyword">drop</span>)原索引，再新建(<span class="keyword">add</span>)索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY ;</span><br><span class="line"># <span class="number">4.</span>创建单列索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    INDEX single_idx_name(name(<span class="number">20</span>))</span><br><span class="line">);</span><br><span class="line"># <span class="number">5.</span>创建组合索引：在表中的id、name和age字段上建立组合索引 </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    INDEX multi_idx(id,name,age)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">6.</span>创建全文索引</span><br><span class="line"># <span class="number">6.1</span> 在表中的info字段上建立全文索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    ...</span><br><span class="line">    info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;    # 在MySQL5<span class="number">.7</span>及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</span><br><span class="line"># <span class="number">6.2</span> 给title和body字段添加全文索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span> (<span class="number">200</span>),</span><br><span class="line">    body TEXT,</span><br><span class="line">    FULLTEXT index (title, body)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB ;</span><br><span class="line"># 全文索引用<span class="keyword">match</span><span class="operator">+</span>against方式查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title,body) AGAINST (‘查询字符串’);</span><br><span class="line"># <span class="keyword">like</span>方式的的查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> body <span class="keyword">LIKE</span> ‘<span class="operator">%</span>查询字符串<span class="operator">%</span>’;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><ol><li>使用全文索引前，搞清楚版本支持情况；</li><li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li><li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li></ol></blockquote><h3 id="在已存在的表上创建索引"><a href="#在已存在的表上创建索引" class="headerlink" title="在已存在的表上创建索引"></a>在已存在的表上创建索引</h3><p>在已经存在的表中创建索引可以使用<strong>ALTER TABLE</strong>语句或者<strong>CREATE INDEX</strong>语句。</p><p><strong>方法一：</strong> 使用<strong>ALTER TABLE</strong>语句创建索引 ALTER TABLE语句创建索引的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p><strong>方法二（推荐）：</strong>使用<strong>CREATE INDEX</strong>创建索引 CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，CREATE INDEX<strong>被映射到一个ALTER TABLE语句上</strong>，基本语法结构为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p><strong>示例：</strong>在学生表上，给年纪、班级字段创建联合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid <span class="keyword">ON</span> student(age,classId);</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>使用<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>删除索引 <span class="keyword">ALTER</span> <span class="keyword">TABLE</span>删除索引的基本语法格式如下：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br><span class="line"># <span class="number">2.</span> 使用<span class="keyword">DROP</span> INDEX语句删除索引 <span class="keyword">DROP</span> INDEX删除索引的基本语法格式如下：</span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong></p><p>删除表中的列时，若待删除列为索引的组成部分，则该列也会从索引中删除。当组成索引的所有列都被删除，则整个索引将被删除。</p></blockquote><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建联合索引并查看</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age,classId,name);</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><hr><h1 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h1><h2 id="适合创建索引的情况"><a href="#适合创建索引的情况" class="headerlink" title="适合创建索引的情况"></a>适合创建索引的情况</h2><ol><li><p><strong>唯一特性的字段，适合创建索引</strong></p><p>业务上具有唯一特性（例如唯一约束、主键约束）的字段，<strong>即使是组合字段</strong>，也必须建成唯一索引。</p></li><li><p><strong>频繁作为where条件的字段，适合创建索引</strong></p><p>某字段在SELECT语句的 <strong>WHERE 条件</strong>中经常被使用到，那么就需要给这个字段创建索引了。尤其是在<strong>数据量大</strong>的情况下，创建普通索引就可以<strong>大幅提升</strong>数据查询的<strong>效率</strong>。</p></li><li><p><strong>经常分组或排序查询的字段，适合创建索引</strong></p><p>本身索引就已经排好序了，而且B+树叶节点一起组成双向链表，很适合范围查询。很适合建立索引。</p><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 <strong>GROUP BY</strong> 对数据进行分组查询，或者使用 <strong>ORDER BY</strong> 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待<strong>排序的列有多个</strong>，可以在这些列上建立<strong>联合索引</strong>。</p></li><li><p><strong>增改语句的查询条件字段，适合创建索引</strong></p><p>UPDATE、DELETE 的 WHERE 条件列。对数据按照某个条件进行<strong>查询后</strong>再进行 <strong>UPDATE 或 DELETE</strong> 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。</p><p><strong>原理</strong>：因为需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</p></li><li><p><strong>DISTINCT字段，适合创建索引</strong></p><p>有时候我们需要对某个字段进行<strong>去重</strong>，使用 <strong>DISTINCT</strong>，那么对这个字段创建索引，也会提升查询效率。因为索引会对数据按照某种顺序进行排序，<strong>排序后再去重</strong>会快很多。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p><strong>多表连接时，连接表数量别超过3张，where字段和连接字段，适合创建索引</strong></p><ul><li><p><strong>连接表的数量</strong>尽量别超过 3 张，因为每增一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询效率。</p></li><li><p>对 <strong>WHERE 条件创建索引</strong>，因为 WHERE 才是对数据条件的过滤。数据量非常大时，没有 WHERE 条件过滤是非常可怕的。</p></li><li><p>对用于<strong>连接的字段创建索引</strong>，并且该字段在多张表中的类型必须一致。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p></li></ul></li><li><p><strong>数据范围越小的字段，越适合创建索引</strong></p><p>这里说的类型大小指的就是该类型表示的<strong>数据范围的大小</strong>。</p><p>在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<code>TINYINT、MEDIUMINT、INT、BIGINT</code>等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，<strong>尽量让索引列使用较小的类型</strong>，比如<strong>能使用INT就不要使用BIGINT</strong>，能使用MEDIUMINT就不要使用INT。因为:</p><p><strong><code>数据类型越小，在查询时进行的比较操作越快</code><strong>。数据类型越小，索引占用的</strong>存储空间就越少</strong>，在一个数据页内就可以放下更多的记录，从而<strong>减少磁盘I/0</strong>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</p><p>该建议对于表的<strong>主键</strong>来说<strong>更加适用</strong>，因为不仅是聚簇索引中会存储主键值，其他所有的<strong>二级索引</strong>的节点处都会<strong>存储一份记录的主键值</strong>，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。</p></li><li><p><strong>很长的varchar字段，适合创建前缀索引</strong></p><p>假设<strong>字符串很长</strong>，那存储一个<strong>字符串</strong>就需要<strong>占用</strong>很大的<strong>存储空间</strong>。在需要为这个字符串列建立索引时意味着在对应的B+树中有这么两个问题:</p><p>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大；</p><p>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。我们可以通过<strong>截取字符串区分度高的前缀子串建立索引</strong>，这个就叫<strong>前缀索引</strong>。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了符串的比较时间，还大体能解决排序的问题。</p><p><strong>计算区分度度：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>);  # <span class="keyword">left</span>()函数用于取字符串前缀</span><br></pre></td></tr></table></figure><blockquote><p><strong>案例</strong>：创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shop(address <span class="type">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> shop <span class="keyword">add</span> index(address(<span class="number">12</span>));</span><br></pre></td></tr></table></figure><p><strong>问题是截取多少</strong>：截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。</p><p><strong>计算不同的长度的区分性，通过区分度判断</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 完整字段在全部数据中的选择度</span><br><span class="line">select count(distinct address) / count(*) from shop;</span><br><span class="line"># 通过不同长度去计算，与全表的选择性对比</span><br><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure><p><strong>索引列前缀对排序的影响</strong>：Alibaba《Java开发手册》</p><p>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，<strong>根据实际文本区分度决定索引长度</strong>。</p><p><strong>说明</strong>：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90% 以上，可以使用 <code>count(distinct left(列名, 索引长度))/count(*)</code>的区分度来确定。</p></blockquote></li><li><p><strong>区分度高的字段，适合作为索引</strong></p></li><li><p><strong>联合索引，将频繁查询的列放到左侧</strong></p></li></ol><p>   这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。</p><ol start="11"><li><p><strong>多个字段都要创建索引时，联合索引优于单值索引</strong></p></li><li><p><strong>单张表索引数建议别超过6个</strong></p><ul><li>每个索引都需要<strong>占用磁盘空间</strong>，索引越多，需要的磁盘空间就越大</li><li>索引会<strong>影响INSERT、DELETE、UPDATE等语句的性能</strong>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li><li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会<strong>增加MySQL优化器生成执行计划时间</strong>，降低查询性能。</li></ul></li></ol><h2 id="不适合创建索引的情况"><a href="#不适合创建索引的情况" class="headerlink" title="不适合创建索引的情况"></a>不适合创建索引的情况</h2><ol><li><p> <strong>在where中使用不到的字段，不要设置索引</strong></p></li><li><p><strong>数据量小的表，不要设置索引</strong></p><p>在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。</p></li><li><p> <strong>有大量重复数据的列上，不要设置索引</strong></p></li></ol><p>   当数据重复度大，比如<strong>高于 10%</strong> 的时候，也不需要对这个字段使用索引。 </p><p>   例如100万数据量的学生表，只有10个男生，其他都是女生，性别字段就别设置索引。 </p><ol start="4"><li><p><strong>经常更新的表，不要创建过多索引</strong></p><ul><li><p><strong>频繁更新的字段</strong>不一定要创建索引。因为<strong>更新数据</strong>的时候，也<strong>需要更新索引</strong>，如果索引太多，在更新索引的时候也会造成<strong>负担</strong>，从而影响效率。</p></li><li><p>避免对<strong>经常更新的表</strong>创建过多索引，并且索引中的列尽可能少。此时虽然提高了查询速度，同时却会<strong>降低更新表的速度</strong>。 </p></li></ul></li><li><p><strong>不建议用无序的值作为索引</strong></p><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p></li><li><p><strong>删除很少使用的索引</strong></p><p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的<strong>一些索引</strong>可能<strong>不再需要</strong>。数据库管理员应当定期找出这些索引，将它们<strong>删除</strong>，从而<strong>减少索引对更新操作的影响</strong>。</p></li><li><p><strong><code>不要定义</code>冗余或重复的索引</strong></p><p><strong>冗余索引示例</strong>：个人信息表，<strong>联合索引最左边字段不需再创建索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(<span class="number">10</span>), birthday, phone_number),</span><br><span class="line">    KEY idx_name (name(<span class="number">10</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过idx_name_birthday_phone_number <strong>联合索引</strong>就可以对<strong>name 列进行快速搜索</strong>，再创建一个<strong>专门针对name 列的索引就算是一个冗余索引</strong>，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p><p><strong>重复索引示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> repeat_index_demo (</span><br><span class="line">    col1 <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    col2 <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> uk_idx_c1 (col1),</span><br><span class="line">    INDEX idx_c1 (col1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是<strong>主键本身就会生成聚簇索引</strong>，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p></li></ol><h2 id="创建索引的一些建议"><a href="#创建索引的一些建议" class="headerlink" title="创建索引的一些建议"></a>创建索引的一些建议</h2><p><strong>一般性建议</strong></p><ul><li>对于单列索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择能够当前query中where子句中更多的索引。</li><li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li></ul><p><strong>总之，书写SQL语句时，尽量避免造成索引失效的情况</strong></p><hr><h1 id="MySQL8-0索引新特性"><a href="#MySQL8-0索引新特性" class="headerlink" title="MySQL8.0索引新特性"></a>MySQL8.0索引新特性</h1><h2 id="支持降序索引"><a href="#支持降序索引" class="headerlink" title="支持降序索引"></a>支持降序索引</h2><p>创建降序的外键索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts1(a <span class="type">int</span>,b <span class="type">int</span>,index idx_a_b(a,b <span class="keyword">desc</span>));</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> ts1\G</span><br><span class="line"># 在MySQL <span class="number">8.0</span>版本中查看数据表ts1的结构，可以发现是降序</span><br><span class="line"># 在MySQL <span class="number">5.7</span>版本中查看数据表ts1的结构，索引仍然是默认的升序，</span><br></pre></td></tr></table></figure><h2 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h2><p>在<strong>MySQL 5.7版本及之前</strong>，只能通过<strong>显式</strong>的方式<strong>删除索引</strong>。此时，如果发现<strong>删除索引后出现错误</strong>，又<strong>只能</strong>通过<strong>显式创建索引</strong>的方式<strong>将删除的索引创建回来</strong>。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p><p>将待删除的索引设置为隐藏索引，mysql确认删除索引后不会出错后再彻底删除索引。</p><p>从MySQL 8.x开始支持<strong>隐藏索引</strong>（invisible indexes） ，只需要将<strong>待删除的索引设置为隐藏索引</strong>，使<strong>查询优化器不再使用这个索引</strong>（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何影响，就可以<strong>彻底删除索引</strong>。这种通过<strong>先将索引设置为隐藏索引，再删除索引</strong>的方式就是软删除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name INVISIBLE;     # 切换成隐藏索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name VISIBLE;         # 切换成非隐藏索引</span><br></pre></td></tr></table></figure><hr><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><h2 id="什么是覆盖索引"><a href="#什么是覆盖索引" class="headerlink" title="什么是覆盖索引"></a>什么是覆盖索引</h2><p><strong>覆盖索引：</strong>一个索引包含了满足查询结果的数据就叫做覆盖索引，不需要回表等操作。</p><p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。</p><p>覆盖索引是<strong>非聚簇索引</strong>的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列 （即建索引的字段正好是覆盖查询条件中所涉及的字段）。简单说就是， <strong>索引列+主键</strong> 包含 <strong>SELECT 到 FROM之间查询的列</strong> 。</p><h2 id="覆盖索引情况下，“不等于”索引生效"><a href="#覆盖索引情况下，“不等于”索引生效" class="headerlink" title="覆盖索引情况下，“不等于”索引生效"></a>覆盖索引情况下，“不等于”索引生效</h2><p><strong>没覆盖索引情况下，“不等于”索引失效：</strong></p><p>没覆盖索引的情况下，使用“不等于”导致索引失效。因为如果使用索引，则需要依次遍历非聚簇索引B+树里所有叶节点，时间复杂度O(n)，找到记录后还要回表，加在一起效率不如全表扫描，所以查询优化器就选择全表扫描了。</p><p><strong>覆盖索引情况下，“不等于”索引生效：</strong></p><p>覆盖索引，查的两个字段被联合索引给覆盖了，性能更高。虽然还是需要依次遍历非聚簇索引B+树里所有叶节点，时间复杂度O(n)，但是不需要回表了，整体效率比不用索引更高，查询优化器就又使用索引了。</p><h2 id="覆盖索引情况下，左模糊查询索引生效"><a href="#覆盖索引情况下，左模糊查询索引生效" class="headerlink" title="覆盖索引情况下，左模糊查询索引生效"></a>覆盖索引情况下，左模糊查询索引生效</h2><p><strong>没覆盖索引的情况下，左模糊查询导致索引失效</strong></p><p>原因同 <code>没覆盖索引情况下，“不等于”索引失效</code></p><p><strong>覆盖索引情况下，左模糊查询索引生效</strong></p><p>主要原因也是因为走非聚簇索引B+树遍历叶节点，不回表，效率会比全表扫描时高，查询优化器选择效率高的方案。</p><h2 id="覆盖索引的利弊"><a href="#覆盖索引的利弊" class="headerlink" title="覆盖索引的利弊"></a>覆盖索引的利弊</h2><p><strong>好处：</strong></p><ol><li><p><strong>避免回表（Innodb表进行索引的二次查询）</strong></p><p>Innodb是以聚簇索引的顺序来存储的，对lnnodb来说，二级索引在叶子节点中所保存的是行的主键信息，若是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。</p><p>在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。</p></li><li><p><strong>可以把随机IO变成顺序IO加快查询效率</strong></p><p>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据I0要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO 转变成索引查找的 顺序IO。</p><p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p></li></ol><p><strong>弊端：</strong>索引字段的维护总是有代价的。在建立冗余索引来支持覆盖索引时需要权衡考虑。这是业务DBA，即业务数据架构师的工作。</p><hr><h1 id="给字符串添加索引"><a href="#给字符串添加索引" class="headerlink" title="给字符串添加索引"></a>给字符串添加索引</h1><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>MySQL是支持前缀索引的。默认地，如果你<strong>创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建一张教师表，表定义如下：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(</span><br><span class="line">ID <span class="type">bigint</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">email <span class="type">varchar</span>(<span class="number">64</span>),</span><br><span class="line">...</span><br><span class="line">)engine<span class="operator">=</span>innodb;</span><br><span class="line"># 给email这个字段添加索引</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index1(email);</span><br><span class="line"># 或</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p><strong>使用index1</strong>（索引包含整个字符串），执行顺序如下：</p><ol><li>从index1索引树找到满足索引值是’ <a href="mailto:&#x7a;&#104;&#97;&#110;&#103;&#115;&#x73;&#x78;&#121;&#122;&#64;&#x78;&#x78;&#x78;&#x2e;&#x63;&#111;&#109;">&#x7a;&#104;&#97;&#110;&#103;&#115;&#x73;&#x78;&#121;&#122;&#64;&#x78;&#x78;&#x78;&#x2e;&#x63;&#111;&#109;</a>’的这条记录，取得ID2的值；</li><li><strong>回表</strong>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li><li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’ <a href="mailto:&#x7a;&#x68;&#97;&#110;&#103;&#115;&#x73;&#120;&#121;&#122;&#64;&#120;&#x78;&#x78;&#46;&#99;&#x6f;&#x6d;">&#x7a;&#x68;&#97;&#110;&#103;&#115;&#x73;&#120;&#121;&#122;&#64;&#120;&#x78;&#x78;&#46;&#99;&#x6f;&#x6d;</a> ’的 条件了，循环结束。</li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p><p><strong>使用index2</strong>（索引包含字符串前缀email(6)），执行顺序如下：</p><ol><li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li><li><strong>回表</strong>到主键上查到主键值是ID1的行，判断出email的值不是’ <a href="mailto:&#x7a;&#104;&#97;&#x6e;&#103;&#x73;&#115;&#x78;&#x79;&#x7a;&#64;&#120;&#120;&#x78;&#x2e;&#99;&#x6f;&#109;">&#x7a;&#104;&#97;&#x6e;&#103;&#x73;&#115;&#x78;&#x79;&#x7a;&#64;&#120;&#120;&#x78;&#x2e;&#99;&#x6f;&#109;</a> ’，这行记录丢弃；</li><li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到<strong>回表到</strong>ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，<strong>直到在index2上取到的值不是’zhangs’时</strong>，循环结束。</li></ol><p>使用前缀索引，定义好长度，<strong>就可以做到既节省空间，又不用额外增加太多的查询成本。</strong>注意：区分度越高，意味着重复的键值越少。</p><h2 id="前缀索引不能用覆盖索引"><a href="#前缀索引不能用覆盖索引" class="headerlink" title="前缀索引不能用覆盖索引"></a>前缀索引不能用覆盖索引</h2><p>因为非聚簇索引树查到的数据是前缀和id，前缀不是完整数据，必须要回表到聚簇索引树。</p><p>所以使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p><hr><h1 id="索引下推（ICP）"><a href="#索引下推（ICP）" class="headerlink" title="索引下推（ICP）"></a>索引下推（ICP）</h1><p><strong>索引下推</strong>(ICP，<code>Index Condition Pushdown</code>)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。</p><ul><li><p><strong>如果没有ICP</strong>：联合索引某字段是模糊查询（非左模糊）时，该字段进行条件判断后，后面几个字段不能用来直接条件判断，必须回表后再判断。</p></li><li><p><strong>启用ICP 后</strong>：联合索引某字段是模糊查询（非左模糊）时，该字段进行条件判断后，后面几个字段可以直接条件判断，判断过滤后再回表对不包含在联合索引内的字段条件进行判断。主要优化点是在回表之前过滤，减少回表次数。</p><p><strong>主要应用</strong>：模糊查询（非左模糊）导致索引里该字段后面的字段无序，必须要回表判断，而使用了索引下推，就不需要回表，直接在联合索引树里判断。</p></li></ul><p><strong>举例：</strong></p><p><strong>不支持索引下推的联合索引：</strong>例如索引(name,age)，查询name like ‘z%’ and age=？，模糊查询导致age无序。在联合索引树查询时只会查name，后面的age乱序不能直接进行条件判断，必须回表后再判断age。</p><p><strong>而支持索引下推的联合索引：</strong>例如索引(name,age)，查询name like ‘z%’ and age and address，在联合索引树查询时不止查name，还会判断后面的age，过滤后再回表判断address。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_age <span class="keyword">ON</span> student(name,age);</span><br><span class="line">#索引失败；非覆盖索引时，左模糊导致索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="keyword">like</span> <span class="string">&#x27;%bc%&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">#索引成功；MySQL5<span class="number">.6</span>引入索引下推，<span class="keyword">where</span>后面的name和age都在联合索引里，可以又过滤又索引，不用回表，索引生效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `name` <span class="keyword">like</span> <span class="string">&#x27;bc%&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">#索引成功；name走索引，age用到索引下推过滤，classid不在联合索引里，需要回表。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `name` <span class="keyword">like</span> <span class="string">&#x27;bc%&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classid<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>好处:</strong> 某些场景下ICP可以大大<strong>减少回表次数</strong>，提高性能。ICP可以减少存储引擎必须访问基表的次数和MySQL服务器必须访问存储引擎的次数。但是，ICP的 加速效果 取决于<strong>在存储引擎内通过 ICP筛选</strong> 的数据的比例。</p><h2 id="ICP的使用条件"><a href="#ICP的使用条件" class="headerlink" title="ICP的使用条件"></a>ICP的使用条件</h2><ul><li>表的访问类型为 range 、 ref 、 eq_ref 或者 ref_or_null 。</li><li><strong>存储引擎：</strong>ICP可以用于InnDB和MyISAM存储引擎</li><li><strong>必须二级索引：</strong>对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少全行读取次数，从而减少I/O操作。</li><li><strong>必须不是覆盖索引：</strong>当SQL使用覆盖索引时，不支持ICP优化方法。因为这种情况下使用ICP不会减少I/O。</li><li>相关子查询的条件不能使用ICP</li><li><strong>必须5.6版本及以上：</strong>MySQL 5.6版本引入并默认开启，之前版本不支持索引下推。</li><li><strong>必须where字段在索引列中：</strong>并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录到server端做where过滤。</li></ul><h2 id="ICP的开启-关闭"><a href="#ICP的开启-关闭" class="headerlink" title="ICP的开启/关闭"></a>ICP的开启/关闭</h2><ul><li><p>默认情况下启动索引条件下推。可以通过设置系统变量<strong>optimizer_switch</strong>控制：<strong>index_condition_pushdown</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 打开索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=on&#x27;</span>;</span><br><span class="line"># 关闭索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>当使用索引条件下推是，<strong>EXPLAIN</strong>语句输出结果中<strong>Extra</strong>列内容显示为<strong>Using index condition</strong>。</p></li></ul><h2 id="开启和关闭ICP性能对比"><a href="#开启和关闭ICP性能对比" class="headerlink" title="开启和关闭ICP性能对比"></a>开启和关闭ICP性能对比</h2><p>使用 ICP 优化的查询效率会好一些。数据量大的情况下效果更明显。</p><hr><h1 id="普通索引-vs-唯一索引"><a href="#普通索引-vs-唯一索引" class="headerlink" title="普通索引 vs 唯一索引"></a>普通索引 vs 唯一索引</h1><p>有一个主键列为ID的表，表中有字段k，并且在k上有索引，假设字段 k 上的值都不重复。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    index (k)</span><br><span class="line">)engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><h2 id="查询性能近似"><a href="#查询性能近似" class="headerlink" title="查询性能近似"></a>查询性能近似</h2><p>假设，执行查询的语句是 select id from test where k=5。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。所以唯一索引查询性能略高，特别是重复记录很多的时候。</li></ul><p>整体来说，二者性能差距很小，因为 InnoDB 是以页为单位读写的，所以可能对于普通索引的扫描过程来说就是在内存中进行，除非是需要跨页查询了，那还要继续读取下一页数据。</p><h2 id="普通索引更新性能更高"><a href="#普通索引更新性能更高" class="headerlink" title="普通索引更新性能更高"></a>普通索引更新性能更高</h2><ul><li><p>普通索引更新性能更高，特别是目标页不在内存中场景。</p></li><li><p>因为普通索引有change buffer（写缓存）将更新后的数据页缓存到内存，下次访问时或后台定期会执行merge操作，将该数据页写入磁盘。（change buffer在事务提交时会写入redo log，保证数据持久化）而唯一索引不支持写缓存，而且插入前要判断唯一性，这部分会影响性能。</p></li></ul><p><strong>写缓存（change buffer）：</strong></p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下， <strong>InooDB会将这些更新操作缓存在change buffer中</strong> ，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p><strong>merge ：</strong>将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge 。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge 操作。</p><p>如果能够将更新操作先记录在change buffer， <strong>减少读磁盘</strong> ，语句的执行速度会得到明显的提升。而且， 数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 <strong>避免占用内存</strong>，提高内存利用率。</p><p><strong>唯一索引的更新就不能使用change buffer</strong> ，实际上也只有普通索引可以使用。</p><blockquote><p><strong>做好区分：</strong></p><ul><li>读数据用的是<strong>缓冲池buffer pool</strong>；</li><li>重做日志有个<strong>redo log buffer</strong>，是将缓冲池里更新的数据写入redo log buffer，事务提交时根据刷盘策略，将redo log buffer刷盘到redo log file或page cache。</li></ul></blockquote><h2 id="change-buffer-使用场景"><a href="#change-buffer-使用场景" class="headerlink" title="change buffer 使用场景"></a>change buffer 使用场景</h2><ul><li>普通索引和唯一索引应该怎么选择？其实，这两类索引在<strong>查询能力上是没差别的</strong>，主要考虑的是<strong>对更新性能的影响</strong>。所以，建议你<strong>尽量选择普通索引</strong> 。</li><li>在实际使用中会发现， 普通索引 和 change buffer 的配合使用，对于 <strong>数据量大</strong> 的表的更新优化 还是很明显的。</li><li><strong>不适合change buffer情况：</strong>如果所有的更新后面，都马上伴随着对这个记录的查询 ，那么你应该关闭change buffer 。而在其他情况下，change buffer都能提升更新性能。</li><li>事务提交的时候，change buffer 的操作也会记录到<strong>redo log中</strong>，所以崩溃恢复时，change buffer 也可以找回来。</li><li>由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受 ，从性能角度出发建议优先考虑非唯一索引。但是如果”业务可能无法确保”的情况下，怎么处理：<ul><li><strong>首先</strong>， 业务正确性优先 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能 问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一 个排查思路。</li><li><strong>然后</strong>，在一些“ 归档库 ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年， 然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率， 可以考虑把表里面的唯一索引改成普通索引。</li></ul></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><p><strong>数据唯一、多读少写：</strong>使用唯一索引，因为它查询性能高，写性能差。</p></li><li><p><strong>数据唯一、少读多写</strong>：使用普通索引+代码逻辑保持唯一。</p><ul><li><strong>更新之后需要立刻查询</strong>：关闭 change buffer。不然要经历<code>更新操作存入change buffer → 加载数据页到内存（缓冲池）→ 更新 → change buffer删除对应更新操作 → 查询</code>的过程，影响性能。关闭后流程是<code>加载数据页到内存（缓冲池）→ 更新 → 查询</code>。</li><li><strong>更新之后不需要立刻查询：</strong>保持change buffer打开。</li></ul></li><li><p><strong>数据不唯一：</strong>使用普通索引，不能使用唯一索引。</p></li></ul><hr><h1 id="主键设计思路"><a href="#主键设计思路" class="headerlink" title="主键设计思路"></a>主键设计思路</h1><p>聊一个实际问题：淘宝的数据库，主键是如何设计的？</p><p>某些错的离谱的答案还在网上年复一年的流传着，甚至还成为了所谓的MySQL军规。其中，一个最明显的错误就是关于MySQL的主键设计。</p><h2 id="自增主键的缺点"><a href="#自增主键的缺点" class="headerlink" title="自增主键的缺点"></a>自增主键的缺点</h2><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点，总体来看存在以下几方面的问题：</p><ul><li><p><strong>可靠性不高</strong></p><p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。</p></li><li><p><strong>安全性不高</strong></p><p><strong>回溯问题：</strong>例如，在一个新表中插入三条主键为1、2、3的数据行，这时候用<code>SHOW CREATE TABLE</code>命令查看该表的<code>AUTO_INCREMENT</code>的值是4，这是没问题的。</p><p>然后把ID=3的数据行删掉，再次查询<code>AUTO_INCREMENT</code>的值，依然是4，这也是没问题的。</p><p>但如果<strong>重启</strong>一下MySQL，这个<strong>值就会变回3</strong>，而不是4，发生了回溯。</p></li><li><p><strong>性能差</strong></p><p>自增ID的性能较差，需要在数据库服务器端生成。</p></li><li><p><strong>需要额外执行函数得知自增值，影响性能</strong></p><p>业务还需要额外执行一次类似 <strong>last_insert_id() 的函数</strong>才能知道刚才插入的自增值，这需要多一次网络交互。在海量并发的系统中，多1条SQL，就多一次<strong>性能上的开销</strong>。</p></li><li><p><strong>全局不唯一，高并发时自增锁竞争影响性能</strong></p><p>自增ID是局部唯一，只在当前数据库实例中唯一，而非全局唯一，在任意服务器间都是唯一的。不适用于分布式系统。</p></li><li><p><strong>分库分表、数据迁移时，自增不再适用。</strong></p></li></ul><h2 id="业务字段尽量不要做主键"><a href="#业务字段尽量不要做主键" class="headerlink" title="业务字段尽量不要做主键"></a>业务字段尽量不要做主键</h2><p>建议<strong>尽量不要用跟业务有关的字段做主键</strong>。毕竟，作为项目设计的技术人员，谁也无法预测 在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</p><blockquote><p><strong>经验：</strong> 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而<strong>更改主键设置的成本非常高。</strong></p></blockquote><h2 id="淘宝订单号的主键设计"><a href="#淘宝订单号的主键设计" class="headerlink" title="淘宝订单号的主键设计"></a>淘宝订单号的主键设计</h2><p>在淘宝的电商业务中，订单服务是一个核心业务。列举几个淘宝订单号信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1550672064762308113</span><br><span class="line">1481195847180308113</span><br><span class="line">1431156171142308113</span><br></pre></td></tr></table></figure><p>订单号是19位的长度，且订单的最后5位都是一样的，都是08113。且订单号的前面14位部分是单调递增的。</p><p>大胆猜测，<strong>淘宝的订单ID设计应该是：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">订单ID <span class="operator">=</span> 时间 <span class="operator">+</span> 去重字段 <span class="operator">+</span> 用户ID后<span class="number">6</span>位尾号</span><br></pre></td></tr></table></figure><p>这样的设计能做到全局唯一，且对分布式系统查询及其友好。</p><h2 id="推荐的主键设计"><a href="#推荐的主键设计" class="headerlink" title="推荐的主键设计"></a>推荐的主键设计</h2><h3 id="核心与非核心业务主键策略选择"><a href="#核心与非核心业务主键策略选择" class="headerlink" title="核心与非核心业务主键策略选择"></a>核心与非核心业务主键策略选择</h3><p><strong>非核心业务</strong> ：对应表的主键自增ID，如告警、日志、监控等信息。</p><p><strong>核心业务</strong> ：主键设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调 递增是希望插入时不影响数据库性能。推荐使用MySQL8.0 改造为<strong>有序UUID</strong>，具体通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID。</p><h3 id="UUID的特点"><a href="#UUID的特点" class="headerlink" title="UUID的特点"></a>UUID的特点</h3><p><strong>全局唯一</strong>，占用36字节，数据无序，插入性能差。</p><p><strong>认识UUID：</strong></p><p>MySQL数据库的UUID组成如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID <span class="operator">=</span> 时间<span class="operator">+</span>UUID版本（<span class="number">16</span>字节）<span class="operator">-</span> 时钟序列（<span class="number">4</span>字节） <span class="operator">-</span> MAC地址（<span class="number">12</span>字节）</span><br></pre></td></tr></table></figure><p>以UUID值e0ea12d4-6473-11eb-943c-00155dbaa39d举例</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250726152443274.png" alt="image-20250726152443274"></p><p><strong>为什么UUID是全局唯一的？</strong> </p><p>在UUID中<strong>时间部分占用60位</strong>，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00 到现在的100ns的计数。可以看到UUID存储的<strong>时间精度</strong>比TIMESTAMPE更高，<strong>时间维度发生重复的概率降低到1/100ns</strong>。</p><p><strong>时钟序列</strong>是为了<strong>避免</strong>时钟被回拨导致产生<strong>时间重复</strong>的可能性。<strong>MAC地址用于全局唯一</strong>。</p><p><strong>为什么UUID占用36个字节？</strong></p><p>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</p><p><strong>为什么UUID是随机无序的呢？</strong></p><p>因为UUID的设计中，将<strong>时间低位放在最前面</strong>，而这部分的数据是一直在变化的，并且是无序。</p><h3 id="MySQL-8-0主键方案：有序UUID"><a href="#MySQL-8-0主键方案：有序UUID" class="headerlink" title="MySQL 8.0主键方案：有序UUID"></a>MySQL 8.0<strong>主键方案：有序UUID</strong></h3><p><strong>改造为有序：</strong>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。<strong>MySQL 8.0</strong>可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p><p><strong>优化空间占用：</strong>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p><p>可以通过MySQL8.0提供的<strong>uuid_to_bin函数</strong>实现上述功能，同样的，MySQL也提供了<code>bin_to_uuid</code>函数进行转化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@uuid</span> <span class="operator">=</span> UUID();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@uuid</span>,uuid_to_bin(<span class="variable">@uuid</span>),uuid_to_bin(<span class="variable">@uuid</span>,<span class="literal">TRUE</span>);</span><br></pre></td></tr></table></figure><p>通过函数uuid_to_bin(@uuid,true)<strong>将UUID转化为有序UUID</strong>了。<strong>全局唯一 + 单调递增</strong>，</p><p><strong>有序UUID性能测试：</strong></p><p>16字节的有序UUID，相比之前8字节的自增ID，性能和存储空间对比究竟如何呢？</p><p>插入1亿条数据，每条数据占用500字节，含有3个二级索引，最终的结果如下所示：</p><table><thead><tr><th></th><th>时间(秒)</th><th>表大小(G)</th></tr></thead><tbody><tr><td>自增ID</td><td>2712</td><td>240</td></tr><tr><td>UUID</td><td>3396</td><td>250</td></tr><tr><td>有序UUID</td><td>2624</td><td>243</td></tr></tbody></table><p>插入1亿条数据有序UUID是最快的，而且在实际业务使用中有序UUID在 <strong>业务端就可以生成</strong> 。还可以进一步减少SQL的交互次数。</p><p>另外，虽然有序UUID相比自增ID多了8个字节，但实际只增大了3G的存储空间，还可以接受。</p><blockquote><p>在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局 唯一的实现。</p><p>另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样 的主键设计就更为考验架构师的水平了。</p></blockquote><h3 id="MySQL8-0之前主键方案：手动赋值"><a href="#MySQL8-0之前主键方案：手动赋值" class="headerlink" title="MySQL8.0之前主键方案：手动赋值"></a>MySQL8.0之前主键方案：手动赋值</h3><p>设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p><p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p><p>门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当前会员编号的最大值。</p><p>这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进行操作，就解决了各门店添加会员时会员编号冲突的问题。</p><h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p>有序的id。Long数据类型的64bit大小的整数：由1bit的<strong>符号位</strong>、41bit的<strong>时间戳</strong>、10bit的<strong>工作机器id</strong>、12bit的<strong>序列号</strong>组成。</p><p><strong>优点：</strong></p><ul><li><strong>有序：</strong>所有生成的id按时间趋势递增</li><li><strong>分布式不重复：</strong>整个分布式系统内不会产重复id。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>依赖机器时钟：</strong>依赖机器时钟，如果机器时钟回拨，会导致有重复id生成。</li><li><strong>分布式时钟不同步导致递增失效：</strong>在单机上递增，但是如果在分布式环境下，每台机器时钟未必同步，可能出现不是全局递增情况。</li><li><strong>精度丢失：</strong>64位的二进制数，化为10进制存储一般为19位，但是前端js只能保证前16位的精度，前端拿到这条数据时，会对后三位进行四舍五入的处理，丢失了精度。</li></ul>]]></content>
    
    
    <summary type="html">‌数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库-存储引擎和索引</title>
    <link href="https://southernfish.github.io/2025/07/24/database/db-mysql-2-engine/"/>
    <id>https://southernfish.github.io/2025/07/24/database/db-mysql-2-engine/</id>
    <published>2025-07-24T04:30:36.000Z</published>
    <updated>2025-07-28T10:27:55.448Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据库中，数据库引擎(Storage Engine)是用于控制数据存储、检索和操作的底层软件组件。每种存储引擎都提供了不同的数据存储机制、索引策略、锁定级别等特性。MySQL从版本5.5起，默认存储引擎是InnoDB，但在更早的版本中，MVISAM是默认存储引擎。</p><blockquote><p>参考原文：</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130308116">MySQL高级篇——存储引擎和索引</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130462818">MySQL高级篇——MVCC多版本并发控制</a></p></blockquote><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="查看、设置存储引擎的命令"><a href="#查看、设置存储引擎的命令" class="headerlink" title="查看、设置存储引擎的命令"></a>查看、设置存储引擎的命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查看mysql提供什么存储引擎</span><br><span class="line"><span class="keyword">show</span> engines;</span><br><span class="line"># 查看默认的存储引擎，两种方式</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@default</span>_storage_engine;</span><br><span class="line"># 创建表时指定存储引擎</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    建表语句;</span><br><span class="line">) ENGINE <span class="operator">=</span> 存储引擎名称;</span><br><span class="line"># 例如，在创建表时指定使用InnoDB存储引擎</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"># 修改表的存储引擎</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><h2 id="MySQL-的常用引擎"><a href="#MySQL-的常用引擎" class="headerlink" title="MySQL 的常用引擎"></a>MySQL 的常用引擎</h2><p><code>InnoDB 引擎</code>：mysql 5.1 后默认的数据库引擎，提供了对数据库 <strong>acid 事务的支持</strong>，并且还提供了<strong>行级锁和外键的约束</strong>，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在<strong>内存中建立缓冲池，用于缓冲数据和索引</strong>。但该引擎<em>不支持全文搜索，同时启动也比较慢，它不会保存表的行数</em>，所以当进行 <code>select count(*) from table</code> 指令时，需要进行扫描全表。由于锁的粒度小，写操作不会锁定全表,所以<strong>在并发度较高的场景下使用会提升效率</strong>。<br><code>MyIASM 引擎</code>：<strong>不提供事务的支持，也不支持行级锁和外键</strong>。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是<strong>保存了表的行数</strong>，于是当进行 <code>select count(*) from table</code> 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><h3 id="InnoDB-介绍"><a href="#InnoDB-介绍" class="headerlink" title="InnoDB 介绍"></a>InnoDB 介绍</h3><p><strong>InnoDB：</strong>支持外键和事务，行锁适合高并发，缓存索引和数据，内存要求高（因为要缓存索引和记录），适合存大数据量，增删改性能更优（行级锁高并发），耗费磁盘（因为有多个非聚簇索引，索引可能比记录空间还大）。</p><p><strong>InnoDB</strong>索引文件在数据库中存放的对应表的磁盘文件有<code>*.frm，*.ibd</code>结尾的两个文件；</p><ul><li>frm文件是存放的表结构，表的定义信息；</li><li>*.ibd文件是存放着表中的数据、索引信息；</li></ul><h3 id="InnoDB-特点"><a href="#InnoDB-特点" class="headerlink" title="InnoDB 特点"></a>InnoDB 特点</h3><ol><li><strong>事务支持：</strong>InnoDB支持ACID事务属性。</li><li><strong>崩溃恢复</strong>：InnoDB会<strong>将数据写入到磁盘上的日志文件</strong>中，即使在系统崩溃的情况下，也能通过这些日志文件恢复数据。</li><li><strong>MVCC (多版本并发控制)：</strong>InnoDB使用多版本并发控制，这允许更高的并发性。</li><li><strong>外键约束：</strong>InnoDB支持外键约束，这对于维护数据库的引用完整性非常有用。</li><li><strong>行级锁定：</strong>与表级锁定相比，InnoDB<strong>支持行级锁定，提供了更高的并发性能</strong>。</li><li><strong>自适应哈希索引：</strong>InnoDB会<strong>自动为频繁访问的热点数据创建哈希索引，以提高查询速度</strong>。</li></ol><ul><li>MySQL从3.23.34a开始就包含InnoDB存储引擎。大于等于5.5之后，<strong>默认采用InnoDB引擎</strong>。</li><li>InnoDB是MySQL的默认事务型引擎，它被设计用来<strong>处理大量的短期(short-lived)事务</strong>。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li><li>除非有非常特别的原因需要使用其他的存储引擎，否则应该<strong>优先考虑InnoDB引擎</strong>。</li><li>InnoDB是<strong>为处理巨大数据量的最大性能设计</strong>。</li><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。</li><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）；表名.ibd 存储数据和索引</li><li>InnoDB增删改性能更优；MyISAM查询性能更优。</li><li>MyISAM只缓存索引不缓存真实数据；InnoDB<strong>不仅缓存索引还要缓存真实数据</strong>， 对内存要求高，且<strong>内存大小对性能有决定性影响</strong>。</li></ul><h3 id="InnoDB-优势"><a href="#InnoDB-优势" class="headerlink" title="InnoDB 优势"></a>InnoDB 优势</h3><p>InnoDB存储引擎在实际应用中拥有诸多优势，比如<strong>操作便利、提高了数据库的性能、维护成本低</strong>等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB<strong>崩溃恢复功能</strong>自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。</p><p>InnoDB存储引擎在主内存中维护<strong>缓冲池</strong>，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p><p>在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置<strong>外键</strong>加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。InnoDB不仅支持当前读写，也会缓冲改变的数据到数据流磁盘。</p><p>InnoDB的性能优势不只存在于长时运行查询的<strong>大型表</strong>。在同一列多次被查询时，自适应<strong>哈希索引</strong>会<strong>提高查询的速度</strong>。使用InnoDB可以压缩表和相关的索引，可以在不影响性能和可用性的情况下创建或删除索引。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。当处理<strong>大数据量</strong>时，InnoDB兼顾CPU，以达到<strong>最大性能</strong>。</p><h3 id="InnoDB-事务的ACID特性"><a href="#InnoDB-事务的ACID特性" class="headerlink" title="InnoDB 事务的ACID特性"></a>InnoDB 事务的ACID特性</h3><blockquote><p><strong>原子性</strong>（Atomicity， A）：事务中的所有操作，要么全部成功，要么全部失败<br><strong>一致性</strong>（Consistency， C）：要保证数据库内部完整性约束、声明性约束<br><strong>隔离性</strong>（Isolation， I）：对同一资源操作的事务不能同时发生，事务之间互相隔离。<br><strong>持久性</strong>（Durability， D）：对数据库做的一切修改将永久保存，不管是否出现故障。一旦事务成功，数据一定会落入数据库。</p></blockquote><p>ACID模型是一系列<strong>数据库设计规则</strong>，这些规则着重<strong>强调可靠性</strong>。MySQL包含类似InnoDB存储引擎的组件，与ACID模型紧密相连，这样出现意外时，数据不会崩溃，结果不会失真。如果依赖ACID模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将MySQL设置调整为只依赖部分ACID特性，以达到更高的性能。</p><p>InnoDB存储引擎与ACID模型相同作用的四个方面：</p><p><strong>1. 原子方面</strong> ACID的原子方面主要涉及InnoDB事务，与MySQL相关的特性主要包括：</p><ul><li>自动提交设置。</li><li>COMMIT语句。</li><li>ROLLBACK语句。</li><li>操作<code>INFORMATION_SCHEMA</code>库中的表数据。</li></ul><p><strong>2. 一致性方面</strong> ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程，与MySQL相关的特性主要包括：</p><ul><li>InnoDB双写缓存。</li><li>InnoDB崩溃恢复。</li></ul><p><strong>3. 隔离方面</strong> 隔离是应用于事务的级别，与MySQL相关的特性主要包括：</p><ul><li>自动提交设置。</li><li><code>SET ISOLATION LEVEL</code>语句。</li><li>InnoDB锁的低级别信息。</li></ul><p><strong>4. 持久性方面</strong> ACID模型的持久性主要涉及与硬件配置相互影响的MySQL软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循。与MySQL相关的特性有：</p><ul><li>InnoDB双写缓存，通过<code>innodb_doublewrite</code>配置项配置。</li><li>配置项<code>innodb_flush_log_at_trx_commit</code>。</li><li>配置项<code>sync_binlog</code>。</li><li>配置项<code>innodb_file_per_table</code>。</li><li>存储设备的写入缓存。</li><li>存储设备的备用电池缓存。</li><li>运行MySQL的操作系统。</li><li>持续的电力供应。</li><li>备份策略。</li><li>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。</li></ul><h3 id="InnoDB-架构"><a href="#InnoDB-架构" class="headerlink" title="InnoDB 架构"></a>InnoDB 架构</h3><ol><li><p><strong>缓冲池</strong> </p><p>缓冲池是主内存中的一部分空间，用来<strong>缓存已使用的表和索引数据</strong>。缓冲池使常被使用的数据能直接在内存中获得，从而提高速度。</p></li><li><p><strong>更改缓存</strong></p><p>更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由<code>innodb_change_buffering</code>配置项管理。</p></li><li><p><strong>自适应哈希索引</strong></p><p>自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过<code>innodb_adaptive_hash_index</code>选项配置，或者通过<code>--skip-innodb_adaptive_hash_index</code>命令行在服务启动时关闭。</p></li><li><p><strong>重做日志缓存</strong></p><p>重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过<code>innodb_log_buffer_size</code>配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存使得大型事务能够正常运行而不需要写入磁盘。</p></li><li><p><strong>系统表空间</strong></p><p>系统表空间包括<strong>InnoDB数据字典、双写缓存、更新缓存和撤销日志</strong>，同时也包括<strong>表和索引数据</strong>。多表共享，系统表空间被视为共享表空间。</p></li><li><p><strong>双写缓存</strong></p><p>位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB才会将数据页写入合适的位置。</p></li><li><p><strong>撤销日志</strong></p><p>撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这些片段包含于回滚片段中。</p></li><li><p><strong>每个表一个文件的表空间</strong></p><p>每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数据文件代表，该文件默认被创建在数据库目录中。</p></li><li><p><strong>通用表空间</strong></p><p>使用<code>CREATE TABLESPACE</code>语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数据目录之外能够管理多个表并支持所有行格式的表。</p></li><li><p><strong>撤销表空间</strong></p><p>撤销表空间<strong>由一个或多个包含撤销日志的文件</strong>组成。撤销表空间的数量由<code>innodb_undo_tablespaces</code>配置项配置。</p></li><li><p><strong>临时表空间</strong></p><p>用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。<code>innodb_temp_data_file_path</code>配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在<code>innodb_data_home_dir</code>变量指定的目录下创建一个自动扩展的数据文件。</p></li><li><p><strong>重做日志</strong></p><p>重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。</p></li></ol><h3 id="innoDB-数据存储结构"><a href="#innoDB-数据存储结构" class="headerlink" title="innoDB 数据存储结构"></a>innoDB 数据存储结构</h3><h4 id="页：数据库的基本存储单位"><a href="#页：数据库的基本存储单位" class="headerlink" title="页：数据库的基本存储单位"></a>页：数据库的基本存储单位</h4><p>页是<strong>磁盘与内存交互基本单位</strong>。</p><p>InnoDB 将数据划分为若千个页，InnoDB中页的大小<strong>默认为 16KB</strong>。</p><p>以页作为磁盘和内存之间交互的基本单位，也就是<strong>一次最少</strong>从磁盘中读取<strong>16KB的内容</strong>到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，在数据库中，不论读一行，还是读多行，都是将这些<strong>行所在的页进行加载</strong>。</p><p>也就是说，<strong>数据库</strong>管理存储空间的<strong>基本单位是页</strong> (Page) ，数据库I/0 操作的最小单位是页。一个页中可以存储多个行记录。</p><blockquote><p> 记录是按照行存储的，但数据库的读取并不以行为单位，否则一次读取(也就是一次 /0 操作)只能处理一行数据，效率会非常低。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725172941737.png" alt="image-20250725172941737"></p></blockquote><h4 id="数据页的大小"><a href="#数据页的大小" class="headerlink" title="数据页的大小"></a>数据页的大小</h4><p>MyISAM 的数据页大小是固定的，是 1KB，也就是说，MyISAM 存储引擎的数据都是以 1KB 的块进行管理的。</p><p>InnoDB 存储引擎的数据页大小是可调的，默认是 16KB。在 MySQL 5.7 版本之前，InnoDB 的数据页大小默认是 8KB。可以通过参数 innodb_page_size 来设置 InnoDB 的数据页大小，取值范围是 4KB、8KB、16KB 和 32KB。</p><h4 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h4><p>页a、页b、页c…页n 这些页可以 <strong>不在物理结构上相连</strong>，只要通过<strong>双向表</strong>相关联即可。每个数据页中的<strong>记录</strong>会按照主键值从小到大的顺序组成一个<strong>单向链表</strong> ，每个数据页都会为存储在它里边的记录生成一个<strong>页目录</strong>，在通过主键<strong>查找某条记录</strong>的时候可以在页目录中<strong>使用二分法</strong>（有序表可以用二分法）快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p><p>不同的数据库管理系统(简称DBMS )的页大小不同。比如在 MySQL 的 nnoDB 存储引擎中，默认页的大小是16KB。<strong>查看页大小:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_page_size%&#x27;</span> </span><br></pre></td></tr></table></figure><p><strong>页的内部结构：</strong></p><p>页如果按类型划分的话，常见的有 <strong>数据页</strong>(保存 B+ 树节点)、<strong>系统页</strong>、<strong>Undo 页</strong>和 <strong>事务数据页</strong> 等。数据页是我们最常使用的页。</p><p>数据页的 <code>16KB</code> 大小的<strong>存储空间</strong>被划分为七个部分，可以把这7个结构分成3个部分：</p><p><strong>第1部分</strong>: File Header (文件头部)、 File Trailer(文件尾部)</p><p><strong>第2部分</strong>: User Records (用户记录)、最大最小记录(Infimum+supremum) 、Free Space(空闲空间)</p><p><strong>第3部分</strong>: Page Directory (页目录)、Page Header(页面头部) </p><p>页结构的7个部分作用分别如下表所示：</p><table><thead><tr><th>名称</th><th>占用大小</th><th>说明</th></tr></thead><tbody><tr><td>File Header</td><td>38字节</td><td>文件头，描述页的信息</td></tr><tr><td>Page Header</td><td>56字节</td><td>页头，页的状态信息</td></tr><tr><td>Infimum+Supremum</td><td>26字节</td><td>最大和最小记录，这是两个虚拟的<strong>行记录</strong></td></tr><tr><td>User Records</td><td>不确定</td><td>用户记录，存储<strong>行记录</strong>内容</td></tr><tr><td>Free Space</td><td>不确定</td><td>空闲记录，页中还没有被使用的空间</td></tr><tr><td>Page Directory</td><td>不确定</td><td>页目录，存储用户记录的相对位置</td></tr><tr><td>File Trailer</td><td>8字节</td><td>文件尾，校验页是否完整</td></tr></tbody></table><h4 id="行、页、区、段、表空间的关系"><a href="#行、页、区、段、表空间的关系" class="headerlink" title="行、页、区、段、表空间的关系"></a>行、页、区、段、表空间的关系</h4><p>另外在数据库中，还存在着<strong>区</strong>(Extent)、<strong>段</strong> (Segment) 和<strong>表空间</strong> (Tablespace) 的概念。行、页、区、段、表空间的关系如下图所示:</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725173932924.png" alt="image-20250725173932924"></p><p><strong>区</strong>(Extent)是比页大一级的存储结构，在 innoDB 存储引擎中，<strong>一个区会分配 64 个连续的页</strong>。因为nnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB= <strong>1MB</strong>。</p><p><strong>段</strong>(Segment)<strong>由一个或多个区组成</strong>，区在文件系统是一个<strong>连续分配的空间</strong>(在innoDB 中是连续的 64 个页)不过在段中不要求区与区之间是相邻的。段是数据库中的<strong>分配单位</strong> ，不同类型的数据库对象以不同的段形式存在。创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p><p><strong>表空间</strong>(Tablespace)是一个<strong>逻辑容器</strong>，表空间<strong>存储的对象是段</strong>，在一个表空间中可以有一个或多个段，但是一个段只能属干一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为 <strong>系统表空间、用户表空间、撤销表空间、 临时表空间</strong> 等。 </p><h4 id="innoDB-四种行格式"><a href="#innoDB-四种行格式" class="headerlink" title="innoDB 四种行格式"></a>innoDB 四种行格式</h4><p>我们平时的数据以行为单位来向表中插入数据，这些<strong>记录</strong>在磁盘上的<strong>存放方式</strong>也被称为<strong>行格式</strong>（也叫记录格式）。</p><p>InnoDB存储引擎设计了4种不同类型的行格式，分别是<strong>Compact、Redundant、Dynamic、Compressed</strong>行格式。</p><p><strong>Compact</strong> </p><p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725174129726.png" alt="image-20250725174129726"></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725174144140.png" alt="image-20250725174144140"></p><p><strong>Dynamic</strong></p><p>在MySQL 8.0中，默认行格式就是Dynamic。</p><p>Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧：</p><ul><li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li><li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li></ul><p><strong>Compressed</strong> </p><p>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725174235355.png" alt="image-20250725174235355"></p><p><strong>Redundant</strong> </p><p>Redundant是MySQL 5.0版本之前InnoDB的行记录存储方式，MySQL 5.0支持Redundant是为了兼容之前版本的页格式。 </p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725174303618.png" alt="image-20250725174303618"></p><p>从上图可以看到，不同于Compact行记录格式，Redundant行格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的。</p><h4 id="指定行格式的命令"><a href="#指定行格式的命令" class="headerlink" title="指定行格式的命令"></a>指定行格式的命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看MySQL8的默认行格式</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@innodb</span>_default_row_format;</span><br><span class="line"># 查看具体表使用的行格式</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">like</span> <span class="string">&#x27;表名&#x27;</span>\G</span><br><span class="line"># 在创建或修改表的语句中指定行格式</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="operator">=</span>行格式名称</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> record_test_table (</span><br><span class="line">    col1 <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    col2 <span class="type">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    col3 <span class="type">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">    col4 <span class="type">VARCHAR</span>(<span class="number">8</span>)</span><br><span class="line">) CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure><h2 id="MyISAM-引擎"><a href="#MyISAM-引擎" class="headerlink" title="MyISAM 引擎"></a>MyISAM 引擎</h2><h3 id="MyISAM-引擎介绍"><a href="#MyISAM-引擎介绍" class="headerlink" title="MyISAM 引擎介绍"></a>MyISAM 引擎介绍</h3><p><strong>MyISAM：</strong>不支持外键和事务，表锁不适合高并发，缓存索引和数据地址，内存要求低（因为不用缓存记录），查询性能更优（因为查询时InnoDB要维护MVCC一致，而且多缓存了记录），节省磁盘（因为磁盘不存完整记录）。</p><p>MyISAM索引文件在数据库中存放的对应表的磁盘文件有<code>*.frm，*.MYD，*.MYI</code>结尾的三个文件；</p><ul><li>frm文件是存放的表结构，表的定义信息；</li><li>MYD文件是存放着表中的数据；</li><li>MYI文件存放着表的索引信息；</li></ul><h3 id="MyISAM-特点"><a href="#MyISAM-特点" class="headerlink" title="MyISAM 特点"></a>MyISAM 特点</h3><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM <strong>不支持事务、行级锁、外键</strong>，有一个毫无疑问的缺陷就是<strong>崩溃后无法安全恢复</strong>。</li><li>5.5之前默认的存储引擎</li><li>优势是<strong>访问的速度快</strong>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>针对<strong>数据统计有额外的常数存储</strong>。故而 count(*) 的查询效率很高</li><li>表名.frm 存储表结构；表名.MYD 存储数据 (MYData)；表名.MYI 存储索引 (MYIndex)</li><li>应用场景：<strong>只读应用或者以读为主的业务</strong></li></ul><h3 id="InnoDB-对比-MyISAM"><a href="#InnoDB-对比-MyISAM" class="headerlink" title="InnoDB 对比 MyISAM"></a>InnoDB 对比 MyISAM</h3><p>**<code>InnoDB</code>**：支持外键和事务，行锁适合高并发，缓存索引和数据，内存要求高（因为要缓存索引和记录），适合存大数据量，增删改性能更优（行级锁高并发），耗费磁盘（因为有多个非聚簇索引，索引可能比记录空间还大）。</p><p>**<code>MyISAM</code>**：不支持外键和事务，表锁不适合高并发，缓存索引和数据地址，内存要求低（因为不用缓存记录），查询性能更优（因为查询时InnoDB要维护MVCC一致，而且多缓存了记录），节省磁盘（因为磁盘不存完整记录）。</p><table><thead><tr><th>对比</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>特点</td><td>支持外键和事务</td><td>不支持外键和事务</td></tr><tr><td>行表锁</td><td>行锁，操作时只锁某一行，不对其它行有影响， 适合高并发的操作</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td></tr><tr><td>缓存</td><td>缓存索引和数据，对内存要求较高，而且内存大小对性能有决定性的影响</td><td>只缓存索引，不缓存真实数据</td></tr><tr><td>关注点</td><td>事务：并发写、事务、更大资源</td><td>性能：节省资源、消耗少、简单业务、查询快</td></tr><tr><td>默认使用</td><td>5.5及其之后</td><td>5.5之前</td></tr></tbody></table><h2 id="其他引擎"><a href="#其他引擎" class="headerlink" title="其他引擎"></a>其他引擎</h2><ul><li><strong><code>Archive</code> 引擎</strong>：用于数据存档。非常适合存储大量的独立的，作为历史记录的数据，因为它们不经常被读取。它 拥有高效的插入速度，但其对查询的支持相对较差。</li><li><strong><code>Blackhole</code> 引擎</strong>：丢弃写操作，读操作会返回空内容</li><li><strong><code>CSV</code> 引擎</strong>：存储数据时，以逗号分隔各个数据项</li><li><strong><code>Memory</code> 引擎</strong>：置于内存的表。将所有数据存储在 RAM 中，以便在需要快速查找非关键数据的环境中进行快速访问，以前被称为 HEAP 引擎。</li><li><strong><code>Federated</code> 引擎</strong>：访问远程表。提供连接单独的 MySQL 服务器，从多个物理服务器创建一个逻辑数据库的能力，非常适合分布式或数据集市环境。</li><li><strong><code>Merge</code> 引擎</strong>：管理多个MyISAM表构成的表集合</li><li><strong><code>NDB</code> 引擎</strong>：MySQL集群专用存储引擎。高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用。</li></ul><hr><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL<strong>高效获取数据</strong>的数据结构。</p><p>索引是一种<strong>用于快速查询的排好序的数据结构</strong>。</p><p><strong>索引的本质</strong>：索引是<strong>数据结构</strong>。可简单理解为“<strong>排好序</strong>的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法。</p><p>索引是在<strong>存储引擎中实现</strong>的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。<strong>innoDB</strong>存储引擎的索引是<strong>B+树</strong>。同时，存储引擎可以定义每个表的<em>最大索引数和最大索引长度</em>。所有存储引擎<em>支持每个表至少16个索引</em>，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点：</strong> </p><ol><li>类似图书馆建书目索引，<strong>提高数据检索的效率</strong>，降低数据库的IO成本，<strong>减少磁盘I/O次数</strong>，这也是创建索引最主要的原因。</li><li>通过创建<strong>唯一索引</strong>，可以保证数据库表中每一行数据的唯一性。</li><li>在实现数据的参考完整性方面，可以<strong>加速表和表之间的连接</strong>。即，对于有依赖关系的子表和父表<strong>联合查询</strong>时，可以提高查询速度。</li><li>使用<strong>分组和排序</strong>子句查询数据时，可<strong>显著提高查询速度</strong>，因为索引是“排好序的”，减少查询中分组和排序的时间，降低了CPU消耗。</li></ol><p><strong>缺点</strong></p><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p><ol><li>创建索引和维护索引要耗费时间，并且随着数据量的增加，所<strong>耗费的时间</strong>也会增加。</li><li>索引需要<strong>占磁盘空间</strong>，除了<strong>数据表</strong>占数据空间之外，<strong>每一个索引</strong>还要占一定的物理空间， 存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li><li>虽然索引大大提高了查询速度，同时却会<strong>降低更新表的速度</strong>。当对表中的数据进行<strong>增加、删除和修改的时候</strong>，<strong>索引</strong>也要动态地<strong>维护</strong>，这样就降低了数据的维护速度。</li></ol><h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><p><strong>空间上的代价</strong></p><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB 的存储空间，一棵很大的B+树由<strong>许多数据页</strong>组成，那就是很大的一片<strong>存储空间</strong>。</p><p><strong>时间上的代价</strong></p><p>每次对表中的数据进行<strong>增、删、改</strong>操作时，都需要去<strong>修改各个B+树索引</strong>。B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（即不论是用户记录还是目录项记录）都按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，故存储引擎需要额外的时间进行一些记录移位， 页面分裂、页面回收等操作来维护好节点和记录的排序。若建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p><blockquote><p><strong>索引底层数据结构</strong>存在很多种类型，常见的索引结构有： <strong>B+ 树、B 树和Hash结构、红黑树</strong>。</p></blockquote><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="B-树介绍"><a href="#B-树介绍" class="headerlink" title="B+树介绍"></a>B+树介绍</h3><p>B+树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素<strong>自底向上插入</strong>，最底层是0层，这与二叉树恰好相反。 </p><p><strong>m阶 B+树有如下特征:</strong> </p><ol><li>每个非叶节点关键字个数和孩子个数相等；</li><li>根结点关键字个数2到m，非根结点关键字个数⌈m/2⌉到m；</li><li>所有叶子在同一层；</li></ol><p> <strong>B+树结构：</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725125901766.png" alt="image-20250725125901766"></p><p>数的层数越低，IO次数越少，查询越快。 </p><p><strong>InnoDB的B+树索引的注意事项</strong>：</p><ol><li>根页面位置万年不动</li><li>内节点中目录项记录的唯一性</li><li>一个页面最少存储2条记录 </li></ol><p>真实一个数据页可以存100条记录， 一个目录页能存1000条数据；4层B+树能存一千万条数据，我们用到的B+树都不会超过4层，每个页内部可以用二分查找更快查找。</p><blockquote><p><strong>InnoDB非聚簇索引情况</strong>：</p><p>InnoDB <strong>页的大小为 16KB</strong>，一般表的<strong>主键</strong>类型为 INT(占用4个字节)或 <strong>BIGINT</strong> (占用<strong>8个字节</strong>)，<strong>指针类型</strong>也一般为4或<strong>8个字节</strong>，也就是说一个页 (B+Tree 中的一个节点)中大概存储<strong>16KB/(8B+8B)=1K个键值</strong> (因为是估值，为方便计算，这里的K取值为 10^3。也就是说一个<strong>深度为3</strong>的B+Tree 索引可以维护 10^3*10^3*10^3= <strong>1 亿条记录</strong>(假定一个数据页也存储10^3条行记录数据了)</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<strong>B+Tree 的高度一般都在</strong> <strong>2~4 层</strong>。MySQL的lnnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 <strong>1~3 次磁盘IO操作</strong>（根节点被缓存，不算IO次数）。</p><p><strong>数据页大小：</strong></p><p>MyISAM 的数据页大小是固定的，是 1KB，也就是说，MyISAM 存储引擎的数据都是以 1KB 的块进行管理的。</p><p>InnoDB 存储引擎的数据页大小是可调的，默认是 16KB。在 MySQL 5.7 版本之前，InnoDB 的数据页大小默认是 8KB。可以通过参数 <code>innodb_page_size</code> 来设置 InnoDB 的数据页大小，取值范围是 4KB、8KB、16KB 和 32KB。</p></blockquote><h3 id="innoDB的B-树聚簇索引，存储数据和目录"><a href="#innoDB的B-树聚簇索引，存储数据和目录" class="headerlink" title="innoDB的B+树聚簇索引，存储数据和目录"></a>innoDB的B+树聚簇索引，存储数据和目录</h3><blockquote><p>每条记录是Compact 行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line"> c1 <span class="type">INT</span>,</span><br><span class="line"> c2 <span class="type">INT</span>,</span><br><span class="line"> c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line"> ) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725130550720.png" alt="image-20250725130550720"></p></blockquote><p><strong>演示：</strong>假设一个数据页只能存三条数据，一个目录页只能存四条数据，下面是存储状态： </p><p><strong>单个目录（两层B+树）：</strong> </p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725130705253.png" alt="image-20250725130705253"></p><p><strong>大目录嵌套多个小目录（3层B+树）：</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725130742930.png" alt="image-20250725130742930"></p><h2 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h2><h3 id="Hash结构介绍"><a href="#Hash结构介绍" class="headerlink" title="Hash结构介绍"></a>Hash结构介绍</h3><p>哈希表+链地址法处理冲突+链表长度大于8时转为红黑树；</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725133628534.png" alt="image-20250725133628534"></p><p>Hash 本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。Hash 算法是通过某种确定性的算法(比如 MD5、SHA1、SHA2、SHA3) 将输入转变为输出。相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，输出通常会有不同结果。</p><p><strong>优点：</strong>增删改查时间复杂度O（1），从效率上来看，比B+树快；</p><p><strong>缺点：</strong>范围查找效率差，退化成O（n）；排序效率极慢，数据存储没有顺序；每个节点是联合所有字段计算哈希值，无法对单独一个字段索引；不建议重复值多的情况使用，冲突时要不断比较整理链地址或红黑树耗费时间；</p><h3 id="innoDB自适应的哈希索引"><a href="#innoDB自适应的哈希索引" class="headerlink" title="innoDB自适应的哈希索引"></a>innoDB自适应的哈希索引</h3><p><strong>innoDB</strong>不支持哈希索引，但支持<strong>自适应的哈希索引</strong>。如果某个数据<strong>经常被访问</strong>，当满足一定条件的时候，就会将这个<strong>数据页的地址存放到Hash 表</strong>中。这样下次查询的时候，就可以<strong>直接找到</strong>这个页面的所在位置。这样让 B+ 树也具备了 Hash 索引的优点。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725133656757.png" alt="image-20250725133656757"></p><h3 id="Hash-索引与-B-树索引的区别"><a href="#Hash-索引与-B-树索引的区别" class="headerlink" title="Hash 索引与 B+ 树索引的区别"></a>Hash 索引与 B+ 树索引的区别</h3><ol><li>Hash 索引<strong>不能进行范围查询</strong>，而 B+ 树可以。这是因为 Hash 索引指向的数据是<strong>无序的</strong>，而 B+ 的叶子节点是个有序的链表。</li><li>Hash 索引 <strong>不支持联合索引的最左侧原则</strong> (即联合索引的部分索引无法使用)，而 B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将<strong>索引键合并</strong>后再一起<strong>计算 Hash 值</strong>，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</li><li>Hash 索<strong>不支持 ORDER BY 排序</strong>，因为 Hash 索引指向的数据是<strong>无序的</strong>，因此无法起到排序优化的作用，而 B+ 树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，我们也无法用 Hash索引进行 模糊查询，而 B+ 使用LKE 进行模糊查询的时候，LIKE 后面后模糊查询(比如 % 结尾)的话就可</li></ol><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>B树的英文是 Balance Tree，也就是 <strong>多路平衡查找树</strong>。简写为B-Tree (注意横杠表示这两个单词连起来的意思，不是减号)。它的高度远小于平衡二叉树的高度，毕竟是多叉不是二叉。</p><p>B树作为多路平衡查找树，它的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶。每个磁盘块中包括了<strong>关键字和子节点的指针</strong>。如果一个磁盘块中包括了<strong>x 个关键字</strong>，那么<strong>指针数就是x+1</strong>（例如节点有17和35两个关键字，它的三个子节点主键值范围分别是小于17、17~35之间、大于35）。对于一个 100 阶的B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725133919656.png" alt="image-20250725133919656"></p><p>一个M 阶的B树(M&gt;2)有以下的特性：</p><p><strong>小结：</strong></p><p>1.B树在插入和删除节点的时候如果导致树不平衡，就通过<strong>自动调整节点</strong>的位置来保持树的<strong>自平衡.</strong></p><p>2.关键字集合分布在整棵树中,即<strong>叶子节点和非叶子节点都存放数据</strong>。搜索有可能在非叶子节点结束</p><p>3.其搜索性能等价于在关键字全集内做一次二分查找。 </p><h3 id="B-树和-B-树的差异"><a href="#B-树和-B-树的差异" class="headerlink" title="B+ 树和 B 树的差异"></a>B+ 树和 B 树的差异</h3><ol><li>非叶节点的关键字数量：k阶树，B+树非叶节点有k个值、k个孩子，B树非叶节点有k-1个值、k个孩子；</li><li>记录存储位置：B+树记录全存在叶节点，B树记录存在所有节点；</li><li>非叶节点功能：B+树非叶节点存索引，B树非叶节点存记录；</li><li>叶子结点之间关系：B+树所有叶子节点构成一个有序双向链表；B树叶节点之间没指针，只是有序；</li></ol><blockquote><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。但B树和B+树各有应用场景，不能说谁完全比谁好。</p></blockquote><p><strong>B+树中间结点不直接存储数据，好处：</strong></p><p>查询效率更高（比B树矮胖），IO次数也少，更稳定，查询范围也更大。</p><p><strong>为了减少IO，索引树会一次性加载吗？</strong></p><p>不会，会逐一加载数据页，先加载大目录页、再加载小目录页、再加载记录页。 </p><ol><li>数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，<strong>超过几个G</strong>。</li><li>当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是: <strong>逐一加载每一个磁盘页</strong>，因为磁盘页对应着索引树的节点。</li></ol><p><strong>B+树的存储能力如何? 为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><p><strong>lnnoDB</strong> 存储引擎中<strong>页</strong>的大小为 <strong>16KB</strong>，一般表的主键类型为 INT(占用4个字节)或 <strong>BIGINT (占用8个字节)<strong>，指针类型也一般为4或8个字节，也就是说一个页 (B+Tree 中的一个节点)中大概存储16KB/(8B+8B)=1K个键值 (因为是估值，为方便计算，这里的K取值为 10^3。也就是说一个</strong>深度为3</strong>的B+Tree 索引可以维护 10^3<em>10^3</em>10^3= <strong>1 亿条记录</strong>(这里假定一个数据页也存储10A3条行记录数据了)</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2<del>4 层。MySQL的lnnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多**只需要 1</del>3 次磁盘IO操作**（根节点被缓存，不算IO次数）</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><blockquote><p><strong>数据库为什么不用红黑树而用B+树？</strong> </p><p>因为B+树是多叉，红黑树是二叉，B+树更矮胖，查询性能更高，IO次数更少。</p></blockquote><p><strong>红黑树：</strong> 近似平衡二叉树<strong>，</strong>左右子树高差有可能大于 1，查找效率略低于平衡二叉树，但增删效率高于平衡二叉树，适合频繁插入删除。</p><ul><li>结点非黑即红；</li><li>根结点是黑色，叶节点是黑色空节点（常省略）；</li><li>任何相邻节点不能同时为红色；</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；</li><li>查询性能稳定O(logN)，高度最高2log(n+1)；</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725134328736.png" alt="image-20250725134328736"></p><hr><h1 id="存储引擎索引方案"><a href="#存储引擎索引方案" class="headerlink" title="存储引擎索引方案"></a>存储引擎索引方案</h1><h2 id="innoDB的索引方案"><a href="#innoDB的索引方案" class="headerlink" title="innoDB的索引方案"></a>innoDB的索引方案</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚族索引并不是一种单独的索引类型，而是一种<strong>数据存储方式</strong>(基于主键映射目录和排序的B+树，所有的<strong>用户记录</strong>都存储在了<strong>叶子节点</strong>)，也就是所谓的<strong>索引即数据</strong>（因为<strong>记录</strong>就<strong>存</strong>在B+树<strong>叶节点</strong>），数据即索引。 图像参考前文<code>大目录嵌套多个小目录（3层B+树）</code></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725130742930.png" alt="image-20250725130742930"></p><p><strong>特点：</strong></p><ol><li><p>使用记录<strong>主键值的大小</strong>进行各层之间的映射、层内的排序，这包括三个方面的含义：</p><ul><li><p><strong>页内的记录</strong>是按照主键的大小顺序排成一个<strong>单向链表</strong>。</p></li><li><p>各个存放用户<strong>记录</strong>的<strong>页</strong>也是<strong>根据</strong>页中用户记录的<strong>主键大小</strong>顺序排成一个<strong>双向链表</strong>。</p></li><li><p>存放<strong>目录</strong>项记录的页分为不同的层次，在同一层次中的<strong>页</strong>也是根据页中目录项记录的<strong>主键大小</strong>顺序排成一个<strong>双向链表</strong>。</p></li></ul></li><li><p>B+树的<strong>叶子节点</strong>存储的是<strong>完整的用户记录</strong>。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p><p><strong>优点：</strong></p><ul><li><p><strong>数据访问更</strong>快，因为聚簇索引将索引和数据保存在<strong>同一个B+树</strong>中，</p></li><li><p>因此从聚簇索引中获取数据比非聚簇索引更快</p></li><li><p>聚簇索引对于<strong>主键的排序查找和范围查找</strong>速度非常<strong>快</strong></p></li><li><p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<strong>节省</strong>了大量的<strong>io</strong>操作。</p></li></ul><p><strong>缺点：</strong></p><ul><li><strong>插入速度严重依赖于插入顺序</strong>，按照主键的<strong>顺序插入是最快</strong>的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增</strong>的ID列为<strong>主键</strong></li><li><strong>更新主键的代价很高</strong>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</li></ul></li></ol><h3 id="非聚簇索引（又称辅助索引、二级索引）"><a href="#非聚簇索引（又称辅助索引、二级索引）" class="headerlink" title="非聚簇索引（又称辅助索引、二级索引）"></a>非聚簇索引（又称辅助索引、二级索引）</h3><p>聚簇索引基于主键映射目录和页内页间排序，查询条件为主键时才有用。想<strong>查第二列</strong>时，就得新创建一个B+树，也就是<strong>非聚簇索引B+树</strong>，它基于非主键列映射目录和排序，叶节点存非主键字段的值和主键字段的值。通过第二列查到了主键值，再<strong>回表</strong>（回到聚簇索引的表）根据主键值查完整记录。</p><p>非聚簇索引是一种<strong>数据存储方式</strong>(基于<strong>非主键字段</strong>映射目录和排序的B+树，<strong>叶节点存非主键字段的值和主键字段的值</strong>)。</p><blockquote><p><strong>注意：innoDB主键建议使用自增策略，从0开始。因为：</strong></p><ul><li>innoDB的主键不建议过长，因为每个二级索引都要存主键，主键过长会耗费磁盘空间和性能（每个数据页只能16KB，主键空间占多会导致每页存记录个数变少，导致B+树层级变深）；</li><li>B+树插入速度严重依赖于插入顺序，非单调主键会使B+树频繁分裂调整为自增顺序，性能变差。</li></ul></blockquote><p>实际中，一个MySQL表会有一个聚簇索引用于查主键或者回表，有多个非聚簇索引（辅助索引、二级索引）用于查非主键字段。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725131610248.png" alt="image-20250725131610248"></p><p><strong>为什么非聚簇索引B+树的叶节点不存完整记录，还要回表多此一举呢？</strong></p><p>如果表中有100列，那就需要99个非聚簇索引，要是都存完整记录，那就太浪费磁盘空间了。</p><h3 id="聚簇索引和非聚簇索引区别"><a href="#聚簇索引和非聚簇索引区别" class="headerlink" title="聚簇索引和非聚簇索引区别"></a>聚簇索引和非聚簇索引区别</h3><ol><li><strong>叶节点：聚簇索引</strong>的 <strong>叶子节点</strong> 存储的就是我们的 <strong>数据记录</strong>，<strong>非聚簇索引</strong>的<strong>叶子节点</strong>存储的是 <strong>数据位置</strong> 。非聚簇索引不会影响数据表的物理存储顺序。</li><li><strong>数量：一个表</strong>只能有<strong>一个聚簇索引</strong>，因为只能有一种排序存储方式，但可有<strong>多个非聚簇索引</strong>，也就是多个索引目录提供数据检索。</li><li><strong>效率：</strong>使用<strong>聚簇索引</strong>的时候，数据的<strong>查询效率高</strong> ，但如果对数据进行<strong>插入，删除，更新</strong>等操作，效率会比非聚簇索引<strong>低</strong>。因为聚簇索引存的完整记录，移动起来慢；</li></ol><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为<strong>多个列建立非聚簇索引</strong>。</p><p>比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：</p><ul><li>每个目录记录包括c2字段、c3字段、页码，每个用户记录包括c2字段、c3字段、主键；</li><li>先把各个记录和页按照<strong>c2列进行排序；</strong></li><li>在记录的<strong>c2列相同</strong>的情况下，采用<strong>c3列进行排序</strong></li></ul><blockquote><p><strong>注意：</strong></p><p>以c2和c3列的大小为排序规则建立的B+树称为联合索引，<strong>本质上</strong>也是一个<strong>非聚簇索引</strong>。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li>建立<strong>联合索引</strong>只会建立如上图一样的<strong>1棵B+树</strong>。</li><li>为c2和c3列<strong>分别建立索引</strong>会分别以c2和c3列的大小为排序规则建立<strong>2棵B+树</strong>。</li></ul></blockquote><h2 id="MyISAM的索引方案"><a href="#MyISAM的索引方案" class="headerlink" title="MyISAM的索引方案"></a>MyISAM的索引方案</h2><p>MyISAM引擎使用B+Tree 作为索引结构，<strong>叶子节点</strong>的data域<strong>存</strong>放的是待查询字段和数据记录的<strong>地址</strong>。</p><p>MyISAM引擎没有二级索引，只有聚簇索引。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725132544092.png" alt="image-20250725132544092"></p><h2 id="MyISAM-与-InnoDB对比"><a href="#MyISAM-与-InnoDB对比" class="headerlink" title="MyISAM 与 InnoDB对比"></a>MyISAM 与 InnoDB对比</h2><p>MyISAM的索引方式都是非聚簇的，与InnoDB包含1个聚簇索引是不同的。</p><ol><li><strong>查找次数：</strong>在<strong>InnoDB</strong>存储引擎中，我们只需要根据主键值对聚簇索引进行<strong>一次查找</strong>就能找到对应的记录，其主键索引的叶子节点存储着行数据，而在<strong>MyISAM</strong> 中却需要进行一次<strong>回表</strong>操作，意味着MyISAM中建立的索引相当于全部都是二级索引，其索引的叶子节点存储的是行数据地址。</li><li><strong>是否索引即数据：</strong>InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录地址。</li><li><strong>叶节点data域存储内容：</strong>InnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是待查询字段和地址。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</li><li><strong>查询速度：MyISAM</strong>的<strong>回表</strong>操作是十分<strong>快速</strong>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，获取主键之后再回表去聚簇索引里找记录，虽说也不慢，但比不上直接用地址去访问。</li><li><strong>是否必须有主键：</strong>InnoDB要求表必须有主键（ MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。 </li></ol><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250725132452862.png" alt="image-20250725132452862"></p>]]></content>
    
    
    <summary type="html">‌数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库-概述</title>
    <link href="https://southernfish.github.io/2025/07/24/database/db-mysql-1-conception/"/>
    <id>https://southernfish.github.io/2025/07/24/database/db-mysql-1-conception/</id>
    <published>2025-07-24T04:30:36.000Z</published>
    <updated>2025-07-28T10:27:55.448Z</updated>
    
    <content type="html"><![CDATA[<p>数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/125676205">JavaWeb基础1——MySQL</a></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>数据库（DataBase，DB）</strong>：存储数据的仓库，数据是有组织的进行存储。<br><strong>数据库管理系统（DataBase Management System, DBMS）</strong>：管理数据库的大型软件。<br><strong>SQL（Structured Query Language）</strong>：结构化查询语言。操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。</p><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的<strong>二维表</strong>组成的数据库。<strong>优点：</strong></p><ol><li>都是使用表结构，格式一致，易于维护</li><li>使用通用的 SQL语言操作，使用方便，可用于复杂查询</li><li>数据存储在磁盘中，安全</li></ol><p>MySQL的数据库在<code>mysql</code>的data目录下</p><h2 id="常用关系型数据库管理系统"><a href="#常用关系型数据库管理系统" class="headerlink" title="常用关系型数据库管理系统"></a>常用关系型数据库管理系统</h2><p><code>Oracle</code>：收费的大型数据库，Oracle 公司的产品<br>**<code>MySQL</code>**：开源免费的中小型数据库。后来 Sun公司收购了 MySQL，而 Sun 公司又被 Oracle 收购。SQL Server:MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用<br><code>PostgreSQL</code>：开源免费中小型的数据库<br><code>DB2</code>：IBM 公司的大型收费数据库产品<br><code>SQLite</code>：嵌入式的微型数据库。如:作为Android 内置数据库<br><code>MariaDB</code>：开源免费中小型的数据库。</p><hr><h1 id="MySQL下载安装配置"><a href="#MySQL下载安装配置" class="headerlink" title="MySQL下载安装配置"></a>MySQL下载安装配置</h1><ol><li><strong>官网下载安装</strong>：<a href="https://downloads.mysql.com/archives/community/">MySQL :: Download MySQL Community Server (Archived Versions)</a></li><li><strong>配置my.ini</strong>：解压后在<code>mysql</code>安装路径下创建一个<strong>my.ini</strong>文件，更改my.ini文件里面的前两行安装目录，第二行加上\data。注意my.ini文件不能多一个符号或者少一个符号，第二行第三行改成自己的MySQL路径</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line">port=3306</span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="comment"># basedir=D:\\mysql\\mysql-8.0.25-winx64</span></span><br><span class="line">basedir=D:\\DataBase\\mysql-8.0.25-winx64 <span class="comment"># 切记此处要么双斜杠\\，要么单斜杠/，单斜杠\会出错</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录，MySQL 8+ 可以不需要以下配置，系统自己生成即可，否则有可能报错</span></span><br><span class="line">datadir=D:\\DataBase\\mysql-8.0.25-winx64\\data <span class="comment"># 此处同上</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="comment"># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span></span><br><span class="line">max_connect_errors=10</span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为UTF8</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>系统环境变量配置</strong>：在path中新增mysql的bin路径（D:\DataBase\mysql-8.0.25-winx64\bin），即mysql安装路径\bin。</p></li><li><p><strong>初始化</strong>：进入命令指示符（在bin目录下运行cmd）</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.输入下面命令初始化数据库，并设置默认root为空，初始化完成后，在mysql根目录中会自动生成data文件</span></span><br><span class="line"><span class="comment"># 设置数据目录和创建系统数据库和表。</span></span><br><span class="line"><span class="comment"># initialize-insecure指示 MySQL 初始化数据目录，但不会设置 root 用户的密码。这意味着初始化后的数据库实例将没有 root 密码，用户可以直接连接到 MySQL 服务器并设置密码。</span></span><br><span class="line">mysqld --initialize-insecure --user=mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.再输入mysqld -install,为windows安装mysql服务，默认服务名为mysql</span></span><br><span class="line">mysqld -install</span><br><span class="line"><span class="comment"># 出现service successfully installed.表示配置完成</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>启动数据库</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><blockquote><p><strong>解决发生系统错误 2。系统找不到指定的文件</strong></p><p>如果报错“发生系统错误 2。系统找不到指定的文件。”，则以下方法解决：</p><ol><li><p>Win+R输入regedit打开注册表</p></li><li><p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL 在该路径下找到MySQL映像文件ImagePath。</p></li><li><p>查看ImagePath里面本地安装MySQL的路径是否有误，如果有误修改相应的路径即可。</p></li></ol></blockquote><ol start="6"><li><strong>初始化密码</strong>：输入<code>mysql -u root -p</code>进行登录 。</li></ol><blockquote><p><strong>命令解读：</strong></p><ul><li>mysql是安装目录bin下的mysql.exe与服务mysql间进行通信</li><li>-u后跟账户名root</li><li>-p后先不设置密码</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>不用输入密码直接回车 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user user() identified by <span class="string">&quot;你要设置的密码，例如1234&quot;</span>;</span><br></pre></td></tr></table></figure><p>mysql退出 mysql&gt;quit;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>其他命令（慎用）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭数据库</span></span><br><span class="line">net stop mysql</span><br><span class="line"><span class="comment"># 卸载服务</span></span><br><span class="line">mysqld -remove mysql</span><br></pre></td></tr></table></figure><p>最后删除目录和环境变量</p></blockquote><h2 id="获取当前数据库版本"><a href="#获取当前数据库版本" class="headerlink" title="获取当前数据库版本"></a>获取当前数据库版本</h2><p>使用 select version() 获取当前 MySQL 数据库版本。</p><hr><h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>英文：Structured Query Language，简称 SQL</li><li>结构化查询语言，一门操作关系型数据库的编程语言</li><li>定义操作所有关系型数据库的统一标准</li><li>对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”</li></ul><ol><li>SQL 语句可以单行或多行书写，以分号结尾。</li><li>MySQL 数据库的 SQL语句不区分大小写，关键字建议使用大写。</li><li><strong>注释</strong><ol><li><strong>单行注释</strong>：– 注释内容 或 #注释内容(MySQL 特有)</li><li><strong>多行注释</strong>：/*注释 */</li></ol></li></ol><h2 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h2><ul><li>数据定义语言DDL（<code>Data Definition Language</code>）CREATE，DROP，ALTER<ul><li>对<strong>逻辑结构</strong>等有操作的，其中包括表结构，视图和索引。</li></ul></li><li>数据查询语言DQL（<code>Data Query Language</code>）SELEC<ul><li>即<strong>查询</strong>操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</li></ul></li><li>数据操纵语言DML（<code>Data Manipulation Language</code>）INSERT，UPDATE，DELETE<ul><li>对<strong>数据</strong>进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。</li></ul></li><li>数据控制功能DCL（<code>Data Control Languag</code>e）GRANT，REVOKE，COMMIT，ROLLBACK<ul><li>对<strong>数据库安全性完整性</strong>等有操作的，可以简单的理解为<strong>权限控制</strong>等。</li></ul></li></ul><h2 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h2><h3 id="mysql自带数据库"><a href="#mysql自带数据库" class="headerlink" title="mysql自带数据库"></a>mysql自带数据库</h3><ol><li><strong><code>information_schema</code> 是信息数据库</strong>。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。</li><li><strong><code>mysql</code>核心数据库</strong>，存储MySQL数据库里最核心的信息，例如权限、安全。</li><li>**<code>sys</code>**：系统数据库。</li><li>**<code>performance_schema</code>**主要用于收集数据库服务器性能参数（研究性能调优要用到）</li></ol><h3 id="数据库的增删查、使用"><a href="#数据库的增删查、使用" class="headerlink" title="数据库的增删查、使用"></a>数据库的增删查、使用</h3><ol><li>查询</li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建</li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名称;</span><br><span class="line"><span class="comment">-- 创建数据库(判断，如果不存在则创建)</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名称;</span><br></pre></td></tr></table></figure><ol start="3"><li>删除</li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除数据库面</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名称;</span><br><span class="line"><span class="comment">-- 删除数据库(判断，如果存在则删除)</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名称;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用数据库</li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前使用的数据库</span></span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="comment">-- 使用数据库</span></span><br><span class="line">USE 数据库名称;</span><br></pre></td></tr></table></figure><h3 id="表的增删查"><a href="#表的增删查" class="headerlink" title="表的增删查"></a>表的增删查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询当前数据库下所有表名称</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="comment">-- 查询表结构</span></span><br><span class="line"><span class="keyword">DESC</span> 表名称;  # <span class="keyword">desc</span>是<span class="keyword">describe</span>缩写，译为描述</span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">    字段名<span class="number">1</span>  数据类型<span class="number">1</span>,</span><br><span class="line">    字段名<span class="number">2</span>  数据类型<span class="number">2</span>,</span><br><span class="line">    …</span><br><span class="line">    字段名n  数据类型n</span><br><span class="line">); # 注意：字段名是列名。最后一行末尾，不能加逗号</span><br><span class="line"># 删除表</span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"><span class="comment">-- 删除表时判断表是否存在</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> 表名;</span><br><span class="line"># 改表</span><br><span class="line"><span class="comment">-- 关键字rename，add，modify，change，drop</span></span><br><span class="line"><span class="comment">-- 修改表名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新的表名;</span><br><span class="line"><span class="comment">-- 将表名student修改为stu</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student rename <span class="keyword">to</span> stu;</span><br><span class="line"><span class="comment">-- 添加一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 列名 数据类型;</span><br><span class="line"><span class="comment">-- 给stu表添加一列address，该字段类型是varchar(50)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">add</span> address <span class="type">varchar</span>(<span class="number">50</span>);</span><br><span class="line"><span class="comment">-- 修改数据类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 列名 新数据类型;</span><br><span class="line"><span class="comment">-- 将stu表中的address字段的类型改为 char(50)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu modify address <span class="type">char</span>(<span class="number">50</span>);</span><br><span class="line"><span class="comment">-- 修改列名和数据类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 列名 新列名 新数据类型;</span><br><span class="line"><span class="comment">-- 将stu表中的address字段名改为 addr，类型改为varchar(50)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu change address addr <span class="type">varchar</span>(<span class="number">50</span>);</span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 列名;</span><br><span class="line"><span class="comment">-- 将stu表中的addr字段 删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">drop</span> addr;</span><br><span class="line"><span class="comment">-- 删除外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br></pre></td></tr></table></figure><h3 id="数据类型：数值、日期、字符串"><a href="#数据类型：数值、日期、字符串" class="headerlink" title="数据类型：数值、日期、字符串"></a>数据类型：数值、日期、字符串</h3><ol><li><p>数值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tinyint : 小整数型，占一个字节</span><br><span class="line">int ： 大整数类型，占四个字节</span><br><span class="line">    eg ： age int</span><br><span class="line">double ： 浮点类型</span><br><span class="line">    使用格式： 字段名 double(总长度,小数点后保留的位数)</span><br><span class="line">    eg ： score double(5,2)   </span><br></pre></td></tr></table></figure></li><li><p>日期</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> ： 日期值要带引号。只包含年月日</span><br><span class="line">    eg ：birthday <span class="built_in">date</span> </span><br><span class="line">time :  时间值或持续时间</span><br><span class="line">year :  年分值</span><br><span class="line">datetime ： 混合日期和时间值。包含年月日时分秒</span><br></pre></td></tr></table></figure></li><li><p>字符串，要带引号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char ： 定长字符串。</span><br><span class="line">    优点：存储性能高</span><br><span class="line">    缺点：浪费空间</span><br><span class="line">    eg ： name char(10)  如果存储的数据字符个数不足10个，也会占10个的空间，汉字占1个字符</span><br><span class="line">varchar ： 变长字符串。</span><br><span class="line">    优点：节约空间</span><br><span class="line">    缺点：存储性能底</span><br><span class="line">    eg ： name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间    </span><br></pre></td></tr></table></figure></li></ol><h4 id="char-和-varchar-的区别"><a href="#char-和-varchar-的区别" class="headerlink" title="char 和 varchar 的区别"></a>char 和 varchar 的区别</h4><p><strong>char(n) ：</strong>固定长度类型，如 char(10)，当输入”abc”三个字符时，它们占的空间还是 10 个字节，其他 7 个是空字节。</p><ul><li><strong>优点：</strong>效率高；</li><li><strong>缺点：</strong>占用空间；</li><li><strong>适用场景：</strong>存储密码的 md5 值，固定长度的，使用 char 非常合适。</li></ul><p><strong>varchar(n) ：</strong>可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p><ul><li>从<strong>空间</strong>上考虑 varcahr 比较合适；</li><li>从<strong>效率</strong>上考虑 char 比较合适，二者使用需要权衡。</li></ul><h4 id="float-和-double-的区别"><a href="#float-和-double-的区别" class="headerlink" title="float 和 double 的区别"></a>float 和 double 的区别</h4><p><strong><code>float</code></strong> 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br><strong><code>double</code></strong> 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p><h4 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h4><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；<br>不影响内部存储，只是<strong>影响带 zerofill 定义的 int 时，前面补多少个 0</strong>，易于报表展示</p><h2 id="数据操作语言DML"><a href="#数据操作语言DML" class="headerlink" title="数据操作语言DML"></a>数据操作语言DML</h2><ol><li><p>DML添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给指定列添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,…) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…);</span><br><span class="line"><span class="comment">-- 给全部列添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…);</span><br><span class="line"><span class="comment">-- 批量添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,…) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…)…;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…)…;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给指定列添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu (id, NAME) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="comment">-- 给所有列添加数据，列名的列表可以省略的</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu (id,NAME,sex,birthday,score,email,tel,STATUS) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 批量添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">    (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">    (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>DML修改数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,列名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,… [<span class="keyword">WHERE</span> 条件] ;</span><br><span class="line"># 注意：修改语句中如果不加条件，则将所有记录都修改！中括号，表示在写<span class="keyword">sql</span>语句中可以省略这部分</span><br><span class="line"># 示例</span><br><span class="line"><span class="keyword">update</span> stu <span class="keyword">set</span> sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>DML删除数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] ;</span><br><span class="line"># 注意：删除语句中如果不加条件，所有记录都将被删除，慎重！中括号，表示在写<span class="keyword">sql</span>语句中可以省略的部分</span><br><span class="line"># 示例</span><br><span class="line"><span class="comment">-- 删除张三记录</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">-- 删除stu表中所有的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li></ol><h3 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h3><p>在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p><table><thead><tr><th></th><th><strong>delete</strong></th><th><strong>truncate</strong></th><th><strong>drop</strong></th></tr></thead><tbody><tr><td>类型</td><td>DML</td><td>DDL</td><td>DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行，不释放空间，不重置自增列</td><td>表结构还在，删除表方全部数据，重置自增列，释放空间</td><td>删除表结构、数据、索引、约束等全部内容，释放空间，表不复存在</td></tr></tbody></table><hr><h2 id="数据查询语言DQL"><a href="#数据查询语言DQL" class="headerlink" title="数据查询语言DQL"></a>数据查询语言DQL</h2><h3 id="查询的完整语法"><a href="#查询的完整语法" class="headerlink" title="查询的完整语法"></a>查询的完整语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> 表名列表 </span><br><span class="line"><span class="keyword">WHERE</span> 条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段</span><br><span class="line"><span class="keyword">HAVING</span> 分组后条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序字段</span><br><span class="line">LIMIT 分页限定</span><br></pre></td></tr></table></figure><p>ORDER BY </p><ul><li><strong>ASC ：</strong> 升序排列 <strong>（默认值）</strong><em>ascending</em> /əˈsendɪŋ/ </li><li><strong>DESC ：</strong> 降序排列，descending /dɪˈsendɪŋ/ </li></ul><blockquote><p><strong>注意：</strong></p><ol><li> null不能和等号运算，要 IS NULL或 IS NOT NULL，而不是=null</li><li>SQL语句没有==，相等是=，没有赋值的概念。</li></ol></blockquote><h3 id="查询字段并去除重复记录"><a href="#查询字段并去除重复记录" class="headerlink" title="查询字段并去除重复记录"></a>查询字段并去除重复记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="带条件的聚合函数：count-name-’abcd’-or-null"><a href="#带条件的聚合函数：count-name-’abcd’-or-null" class="headerlink" title="带条件的聚合函数：count(name=’abcd’ or null)"></a>带条件的聚合函数：count(name=’abcd’ or null)</h3><p>聚合函数列表详见<a href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">聚合函数</a></p><p>统计所有名字为‘abcd’的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(name<span class="operator">=</span><span class="string">&#x27;abcd&#x27;</span> <span class="keyword">or</span> <span class="keyword">null</span>) <span class="keyword">FROM</span> student;                        # 使用count带条件统计数量必须<span class="keyword">or</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="type">date</span>  <span class="keyword">between</span> <span class="string">&#x27;2019-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">or</span> <span class="keyword">null</span>)     # 使用count带条件统计数量必须<span class="keyword">or</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> name) <span class="keyword">FROM</span> student;                            # 注意<span class="keyword">distinct</span>不能<span class="keyword">or</span> <span class="keyword">null</span></span><br><span class="line"> </span><br><span class="line"># 使用sum带条件统计数量不用<span class="keyword">or</span> <span class="keyword">null</span>。尽量别用sum，因为sum主要用来取和，如果这个name字段是数字型，则会是取和。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(name<span class="operator">=</span><span class="string">&#x27;abcd&#x27;</span>) <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li>使用count带条件统计数量必须or null，否则是统计总数量（条件是distinct除外）</li><li>使用sum带条件统计数量不用or null</li></ul></blockquote><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 分组前条件限定] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后条件过滤];</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</p><p>在分组的情况下，查询字段为聚合函数时，这个聚合函数统计的将是<strong>每组的信息</strong></p><p><strong>where 和 having 区别</strong>：</p><p><strong>执行时机不一样</strong>：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。</p><p><strong>可判断的条件不一样</strong>：where 不能对聚合函数进行判断，having 可以。执行顺序<strong>where&gt;聚合函数&gt;having</strong>，不可能判断后面执行的条件。</p></blockquote><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT  起始索引 , 查询条目数;</span><br></pre></td></tr></table></figure><hr><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>约束是作用于表中<strong>列上的规则</strong>，<strong>用于限制加入表的数据</strong>。例如：可以给id列加约束，让其值不能重复，不能为null值。</li><li>添加约束可以在添加数据的时候就限制不正确的数据。例如把年龄是3000，数学成绩是-5分这样无效的数据限制掉，继而保障数据的完整性。</li></ul><h2 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h2><table><thead><tr><th align="left">约束名</th><th align="left">约束关键字</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">主键</td><td align="left">primary key</td><td align="left">唯一，非空。控件<strong>字段内容不能重复</strong>，但它在一个表只允许出现一个。</td></tr><tr><td align="left">唯一</td><td align="left">unique</td><td align="left">不能重复，最多只有一个非空记录。控件<strong>字段内容不能重复</strong>，一个表<strong>允许有多个 Unique 约束</strong>。</td></tr><tr><td align="left">默认</td><td align="left">default</td><td align="left">没有输入值，使用默认值</td></tr><tr><td align="left">非空</td><td align="left">not null</td><td align="left">必须输入</td></tr><tr><td align="left">外键</td><td align="left">foreign key … references</td><td align="left">外键在从表 主表：1方 从表：多方。用于<strong>预防破坏表之间连接的动作，也能防止非法数据插入外键列</strong>，因为它必须是它指向表中的值之一</td></tr><tr><td align="left">自增</td><td align="left">auto_increment</td><td align="left">从1开始自增，只有唯一和主键约束能用</td></tr><tr><td align="left">检查(mysql不支持)</td><td align="left">check</td><td align="left">保证列中的值满足某一条件。用于<strong>控制字段的值范围</strong>。</td></tr></tbody></table><p><strong>常用命令</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查询表中所有约束</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    TABLE_NAME,</span><br><span class="line">    COLUMN_NAME,</span><br><span class="line">    CONSTRAINT_NAME,</span><br><span class="line">    REFERENCED_TABLE_NAME,</span><br><span class="line">    REFERENCED_COLUMN_NAME</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    INFORMATION_SCHEMA.KEY_COLUMN_USAGE</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    TABLE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 删除约束（<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span>）:</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY; </span><br><span class="line"><span class="comment">-- 或 DROP FOREIGN KEY, DROP UNIQUE, 等等 </span></span><br></pre></td></tr></table></figure><h2 id="增删约束"><a href="#增删约束" class="headerlink" title="增删约束"></a>增删约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>添加约束</span><br><span class="line"><span class="comment">-- 创建表时添加非空约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    列名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 建完表后添加非空约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"># <span class="number">2.</span>删除约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 数据类型</span><br></pre></td></tr></table></figure><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加外键约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   …</span><br><span class="line">   [<span class="keyword">CONSTRAINT</span>] [外键取名名称] <span class="keyword">FOREIGN</span> KEY(外键列名) <span class="keyword">REFERENCES</span> 主表(主表列名) </span><br><span class="line">); </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 创建表时添加外键约束，constraint译作限制，束缚；references译作关联，参考，提及</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   …</span><br><span class="line">   [<span class="keyword">constraint</span>] [外键取名名称] <span class="keyword">foreign</span> key(外键列名) <span class="keyword">references</span> 主表(主表列名) </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建完表后添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 建完表后添加外键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键字段名称) <span class="keyword">references</span> 主表名称(主表列名称);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br></pre></td></tr></table></figure><hr><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li><p><strong>软件研发步骤</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250724230821439.png" alt="image-20250724230821439"></p></li><li><p><strong>数据库设计概念</strong></p><ul><li>设计方向：有哪些表？表里有哪些字段？表和表之间有什么关系？</li><li><strong>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型。</strong></li><li>建立数据库中的<strong>表结构</strong>以及<strong>表与表之间的关联关系</strong>的过程。</li></ul></li><li><p><strong>数据库设计的步骤</strong></p><ul><li><p>需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么）</p></li><li><p>逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）</p><p>如下图就是ER(Entity/Relation)图：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/sql/image-20250724230925723.png" alt="image-20250724230925723"></p></li></ul></li><li><p>物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）</p></li><li><p>维护设计（1.对新的需求进行建表；2.表优化）</p></li></ul><h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><ol><li><p><strong>一对多</strong></p><p>如部门 和 员工。一个部门对应多个员工，一个员工对应一个部门。</p><p><strong>实现方式</strong>：<strong>在多的一方建立外键，指向一的一方的主键</strong></p></li><li><p><strong>多对多</strong></p><p>如：商品 和 订单。一个商品对应多个订单，一个订单包含多个商品。</p><p><strong>实现方式：</strong>建立第三张<strong>中间表</strong>，中间表至少包含<strong>两个外键</strong>，分别<strong>关联两方主键</strong>。</p></li><li><p><strong>一对一</strong></p><p>如：用户 和 用户详情。一对一关系多用于表拆分，将一个实体中常用字段放一张表，不常用字段放另一张表，用于提升查询性能。</p><p><strong>实现方式：</strong>在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)</p></li></ol><h2 id="数据库的三范式"><a href="#数据库的三范式" class="headerlink" title="数据库的三范式"></a>数据库的三范式</h2><ol><li><strong>第一范式：</strong>强调的是<strong>列的原子性</strong>，即数据库表的每一列都是不可分割的原子数据项。</li><li><strong>第二范式：</strong>要求实体的属性<strong>完全依赖于主关键字</strong>。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li><li><strong>第三范式：</strong>任何<strong>非主属性不依赖于其它非主属性</strong>。</li></ol><hr><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul><li>内连接查询 ：相当于查询AB交集数据</li><li>外连接查询<ul><li>左外连接查询 ：相当于查询A表所有数据和交集部门数据</li><li>右外连接查询 ： 相当于查询B表所有数据和交集部分数据</li></ul></li></ul><p><strong>关联查询结果行数：</strong>假设a表x行，b表y行；</p><ul><li><strong>a左连接b：</strong>x行~x*y行</li><li><strong>a右连接b：</strong>y行~y*x行</li><li><strong>内连接：</strong>0行~min(x,y)行</li></ul><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><blockquote><p>相当于查询AB交集数据。</p><p>隐式连接好理解好书写，语法简单，担心的点较少。</p><p>但是<strong>显式连接</strong>可以减少字段的扫描，有<strong>更快的执行速度</strong>。这种速度优势在3张或更多表连接时比较明显 </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接。没有JOIN关键字，条件使用WHERE指定。书写简单，多表时效率低</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span>… <span class="keyword">WHERE</span> 条件;</span><br><span class="line"><span class="comment">-- 显示内连接。使用INNER JOIN ... ON语句, 可以省略INNER。书写复杂，多表时效率高</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自连接是一种特殊的<a href="https://baike.baidu.com/item/%E5%86%85%E8%BF%9E%E6%8E%A5?fromModule=lemma_inlink">内连接</a>，它是指相互连接的表在物理上为同一张表，但可以在<strong>逻辑上</strong>分为两张表。</p><blockquote><p><strong>注意：自连接查询的列名必须是“表名.*”，而不是直接写“*”</strong></p></blockquote><p>案例：要求检索出学号为<strong>20210</strong>的学生的同班同学的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stu.<span class="operator">*</span>        #一定注意是stu.<span class="operator">*</span>，不是<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> stu <span class="keyword">JOIN</span> stu <span class="keyword">AS</span> stu1 <span class="keyword">ON</span> stu.grade <span class="operator">=</span> stu1.grade</span><br><span class="line"><span class="keyword">WHERE</span> stu1.id <span class="operator">=</span> <span class="string">&#x27;20210&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h3><blockquote><p>recurslve译为递归。</p><p><strong>with</strong>：在mysql中被称为公共表达式，可以作为一个临时表然后在其他结构中调用。如果是自身调用那么就是后面讲的递归。</p><p><strong>cte_name</strong>：公共表达式的名称，可以理解为表名，用来表示as后面跟着的子查询</p><p><strong>col_name</strong> ：公共表达式包含的列名，可以写也可以不写</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">with</span>语法</span><br><span class="line"><span class="keyword">WITH</span> [<span class="keyword">RECURSIVE</span>]</span><br><span class="line">    cte_name [(col_name [, col_name] ...)] <span class="keyword">AS</span> (subquery)</span><br><span class="line">    [, cte_name [(col_name [, col_name] ...)] <span class="keyword">AS</span> (subquery)] ...</span><br></pre></td></tr></table></figure><p><strong>例子：使用MySQL临时表遍历1~5</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">RECURSIVE</span> t1  <span class="keyword">AS</span>                    # 这里t1函数名，也是临时表的表名</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">as</span> n                            # n是列的别名，<span class="number">1</span>是初始记录</span><br><span class="line">  <span class="keyword">UNION</span> <span class="keyword">ALL</span>                # 把递归结果（<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>）合并到t1表中</span><br><span class="line">  <span class="keyword">SELECT</span> n <span class="operator">+</span> <span class="number">1</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> n <span class="operator">&lt;</span> <span class="number">5</span>        # n<span class="operator">+</span><span class="number">1</span>是参数，t1是函数名，n<span class="operator">&lt;</span><span class="number">5</span>是遍历终止条件</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1;                        # 正常查询t1这个临时表，相当于调用这个函数。</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong></p><p>t1 相当于一个表名</p><p>select 1 相当于这个表的初始值，这里使用UNION ALL 不断将每次递归得到的数据加入到表中。</p><p>n&lt;5为递归执行的条件，当n&gt;=5时结束递归调用。</p></blockquote><p><strong>案例，递归查询课程多级分类：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> t1 <span class="keyword">as</span> (                                # t1是函数名、临时表名</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  course_category <span class="keyword">where</span>  id<span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>   # 初始记录，也就是根节点</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span>                                         # 把递归结果合并到t1表中</span><br><span class="line">    <span class="keyword">select</span> t2.<span class="operator">*</span> <span class="keyword">from</span> course_category <span class="keyword">as</span> t2 <span class="keyword">inner</span> <span class="keyword">join</span> t1 <span class="keyword">on</span> t1.id <span class="operator">=</span> t2.parentid    </span><br><span class="line">                                                    # 递归，用分类表t和临时表t1内连接查询</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> t1.id, t1.orderby        # 查t1表，相当于调用这个函数。</span><br></pre></td></tr></table></figure><p><strong>mysql递归特点，对比Java递归的优势</strong></p><p><strong>mysql递归次数限制：</strong></p><p>mysql为了避免无限递归默认递归次数为1000，可以通过设置cte_max_recursion_depth参数增加递归深度，还可以通过max_execution_time限制执行时间，超过此时间也会终止递归操作。</p><p><strong>对比Java递归的优势：</strong></p><p>mysql递归相当于在存储过程中执行若干次sql语句，java程序仅与数据库建立一次链接执行递归操作。相比之下，Java递归性能就很差，每次递归都会建立一次数据库连接。</p><h2 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure><blockquote><p>一般都用左外连接，因为右外连接可用左外连接实现，可读性更好。</p></blockquote><h2 id="MySQL-的内连接、左连接、右连接的区别"><a href="#MySQL-的内连接、左连接、右连接的区别" class="headerlink" title="MySQL 的内连接、左连接、右连接的区别"></a>MySQL 的内连接、左连接、右连接的区别</h2><p>内连接：<code>inner join</code>；左连接：<code>left join</code>；右连接：<code>right join</code>。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>查询中嵌套查询，称嵌套查询为子查询。</p><blockquote><p>注意：子语句没有分号。</p></blockquote><p><strong>子查询根据查询结果不同，作用不同，可分为：</strong></p><ul><li><p><strong>子查询语句结果是单行单列</strong>，子查询语句作为条件值，使用 = != &gt; &lt; 等进行条件判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表<span class="keyword">FROM</span> 表<span class="keyword">WHERE</span> 字段名 <span class="operator">=</span> (子查询);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询比猪八戒薪水高的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span>(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;猪八戒&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>子查询语句结果是多行单列</strong>，子查询语句作为条件值，使用 in 等关键字进行条件判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表 <span class="keyword">WHERE</span> 字段名 <span class="keyword">in</span> (子查询);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 &#x27;财务部&#x27; 和 &#x27;市场部&#x27; 所有的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dep_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> did <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> dname <span class="keyword">IN</span> (<span class="string">&#x27;财务部&#x27;</span>,<span class="string">&#x27;市场部&#x27;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>子查询语句结果是多行多列</strong>，子查询语句作为虚拟表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span>(子査询)<span class="keyword">WHERE</span> 条件:</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询入职日期是 &#x27;2011-11-11&#x27; 之后的员工信息和部门信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> join_date <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span> ) <span class="keyword">AS</span> t1, dept <span class="keyword">where</span> t1.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>数据库的事务（Transaction）是一种机制、一个操作序列，包含了<strong>一组数据库操作命令</strong>。</p><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令<strong>要么同时成功，要么同时失败</strong>。</p><p>事务是一个不可分割的工作逻辑单元。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启事务</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;        <span class="comment">--transaction译为事务，业务，交易</span></span><br><span class="line">或者  </span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 转账操作</span></span><br><span class="line"><span class="comment">-- 1. 查询李四账户金额是否大于500</span></span><br><span class="line"><span class="keyword">SELECT</span> ... </span><br><span class="line"><span class="comment">-- 2. 李四账户 -500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">出现异常了...  <span class="comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span></span><br><span class="line"><span class="comment">-- 3. 张三账户 +500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>上面sql中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句。以后我们肯定不可能这样操作，而是在java中进行操作，在java中可以抓取异常，没出现异常提交事务，出现异常回滚事务。  </p><h2 id="事务的四大特征-ACID"><a href="#事务的四大特征-ACID" class="headerlink" title="事务的四大特征 ACID"></a>事务的四大特征 ACID</h2><p><strong>原子性</strong>（<code>Atomicity</code>）：一个事务（<code>transaction</code>）中的所有操作，<strong>或全部完成，或全部不完成</strong>，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（<code>Rollback</code>）到事务开始前的状态，就像这个事务从来没有执行过一样。即<strong>事务不可分割、不可约简</strong>。</p><p><strong>一致性</strong>（<code>Consistency</code>）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示<strong>写入的资料必须完全符合所有的预设约束、触发器、级联回滚</strong>等。事务完成时，必须使所有的数据都保持一致状态。</p><p><strong>隔离性</strong>（<code>Isolation</code>）：多个事务之间，操作的可见性。数据库<strong>允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</strong>。事务隔离分为不同级别，包括读未提交（<code>Read uncommitted</code>）、读提交（<code>read committed</code>）、可重复读（<code>repeatable read</code>）和串行化（<code>Serializable</code>）。</p><p><strong>持久性</strong>（<code>Durability</code>）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><blockquote><p><strong>说明</strong>：</p><p>mysql中事务是自动提交的。</p><p>也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务。</p><p>可以通过下面语句查询默认提交方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br></pre></td></tr></table></figure><p>查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></blockquote><h2 id="ACID-原子性：MySQL通过使用日志文件来实现事务的原子性"><a href="#ACID-原子性：MySQL通过使用日志文件来实现事务的原子性" class="headerlink" title="ACID-原子性：MySQL通过使用日志文件来实现事务的原子性"></a>ACID-原子性：MySQL通过使用日志文件来实现事务的原子性</h2><p><strong>日志刷盘</strong><br>当一个事务开始时，InnoDB会为该事务分配一个<strong>唯一事务ID</strong>，并开始<strong>记录重做日志和回滚日志</strong>。随着事务的执行，所有的数据修改都会<strong>先写入到重做日志缓冲区</strong>中，然后在适当时机，<strong>这些修改会被刷新到磁盘上的重做日志文件中</strong>。如果系统崩溃，重做日志将被用来重做事务，确保事务的修改被应用到数据库中。<br><strong>Redo Log</strong><br>事务执行过程中发生错误或系统故障时，如果数据修改已经写入重做日志缓冲区中，在适当的时机（系统恢复时），这些修改会被刷新到磁盘上的重做日志文件中。<br><strong>Undo Log</strong><br>在事务执行过程中发生错误或系统故障，且无法通过**<code>Redo Log</code>** 保证数据一致性和完整性，MySQL将<strong>利用日志来回滚事务中的所有操作</strong>，保证数据库的原子性不被破坏。</p><h2 id="ACID-一致性：MySQL通过几种机制来保证数据的一致性"><a href="#ACID-一致性：MySQL通过几种机制来保证数据的一致性" class="headerlink" title="ACID-一致性：MySQL通过几种机制来保证数据的一致性"></a>ACID-一致性：MySQL通过几种机制来保证数据的一致性</h2><p><strong>约束（<code>Constraints</code>）：</strong>MySQL允许定义各种约束（如<strong>主键约束、外键约束、唯一约束</strong>等），这些约束直接作用于数据表上，确保数据的完整性和一致性。<br><strong>事务隔离级别（<code>Transaction Isolation Levels</code>）：</strong>通过合理选择事务隔离级别，可以在并发环境下有效地维护数据的一致性。读未提交（<code>Read Uncommitted</code>）、读提交（<code>Read Committed</code>）、可重复读（<code>Repeatable Read</code>）、串行化（<code>Serializable</code>）<br><strong>锁定机制（<code>Locking Mechanisms</code>）：</strong>MySQL使用锁定机制来<strong>控制对数据的并发访问</strong>，包括<em>行级锁（<code>Row-Level Locks</code>）、表级锁（<code>Table Locks</code>）</em>等，以确保在并发事务中数据的一致性和完整性。<br><strong>原子性操作（<code>Atomic Operations</code>）：</strong>MySQL通过原子性操作确保事务中的所有操作<strong>要么全部成功，要么全部失败</strong>，从而保持数据的一致性。</p><h2 id="ACID-持久性：MySQL中保证数据持久性的技术"><a href="#ACID-持久性：MySQL中保证数据持久性的技术" class="headerlink" title="ACID-持久性：MySQL中保证数据持久性的技术"></a>ACID-持久性：MySQL中保证数据持久性的技术</h2><ul><li>日志文件<ul><li><strong>重做日志（<code>Redo Log</code>）：</strong>InnoDB存储引擎使用重做日志来保证事务的持久性。事务提交时，事务所做的所有<strong>修改都会被记录到重做日志</strong>中。即使数据库发生崩溃，重做日志也可以在重启后被用来重放这些修改，确保数据的持久性。</li><li><strong>二进制日志（<code>Binary Log</code>）：</strong>MySQL服务器使用<strong>二进制日志记录所有修改数据库数据的操作</strong>，如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等。二进制日志不仅对数据恢复至关重要，也是复制和增量备份的基础。</li></ul></li><li>备份策略<ul><li><strong>全量备份：</strong>定期对整个数据库进行完整备份，以确保数据的持久性和可恢复性。</li><li><strong>增量备份：仅备份自上次备份以来发生变化的数据</strong>。与全量备份结合使用，可以有效减少数据恢复时间和存储需求。</li><li><strong>点对点恢复（<code>Point-in-Time Recovery, PITR</code>）：</strong>使用二进制日志实现，可以<strong>将数据库恢复到特定时间点的状态</strong>，非常适合处理操作错误或数据损坏的情况。</li></ul></li></ul><h2 id="数据库的事务隔离"><a href="#数据库的事务隔离" class="headerlink" title="数据库的事务隔离"></a>数据库的事务隔离</h2><p>MySQL 的事务隔离是在 <code>MySQL. ini</code> 配置文件里添加的，在文件的最后添加：<br>    transaction-isolation = REPEATABLE-READ<br><strong>可用的配置值：</strong><code>READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE</code>。</p><ul><li><code>READ-UNCOMMITTED</code>：<strong>读未提交</strong>，事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li><li><code>READ-COMMITTED</code>：<strong>读提交</strong>，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li><li><code>REPEATABLE-READ</code>：<strong>可重复读</strong>，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li><li><code>SERIALIZABLE</code>：<strong>序列化</strong>，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p><strong>脏读：</strong>表示一个事务能够读取另一个事务中还未提交的数据。<br><strong>不可重复读：</strong>是指在一个事务内，多次读同一数据。<br><strong>幻读：</strong>指同一个事务内多次查询返回的结果集不一样。发生<strong>幻读的原因</strong>是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所以数据行的记录就变多或者变少了。</p><ul><li><em>MySQL默认使用的是“可重复读”隔离级别，SQL标准的默认隔离级别是“读提交”</em>。</li><li>MySQL在“可重复读”级别下通过<strong>多版本并发控制（MVCC）机制避免幻读</strong>的问题。</li></ul><h2 id="MySQL的-binlog-的几种录入格式及区别"><a href="#MySQL的-binlog-的几种录入格式及区别" class="headerlink" title="MySQL的 binlog 的几种录入格式及区别"></a>MySQL的 binlog 的几种录入格式及区别</h2><p>有三种格式，statement，row和mixed。</p><ul><li><strong><code>statement</code>模式</strong>下，每一条会<strong>修改数据的sql都会记录在<code>binlog</code>中</strong>。不需要记录每一行的变化，<strong>减少了binlog日志量，节约了IO，提高性能</strong>。由于sql的执行是有上下文的，因此在<strong>保存的时候需要保存相关的信息</strong>，同时还有一些使用了函数之类的语句无法被记录复制。</li><li><strong><code>row</code>级别</strong>下，不记录sql语句上下文相关信息，仅<strong>保存哪条记录被修改。记录单元为每一行的改动</strong>，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件<strong>保存的信息太多，日志量太大</strong>。</li><li><strong><code>mixed</code><strong>，一种折中的方案，</strong>普通操作使用statement记录，当无法使用statement的时候使用row</strong>。</li></ul><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="数值型函数"><a href="#数值型函数" class="headerlink" title="数值型函数"></a>数值型函数</h2><table><thead><tr><th align="left">函数名称</th><th align="left">作 用</th></tr></thead><tbody><tr><td align="left"><a href="http://c.biancheng.net/mysql/abc.html">ABS</a></td><td align="left">求绝对值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/sqrt.html">SQRT</a></td><td align="left">求二次方根</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/mod.html">MOD</a></td><td align="left">求余数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/ceil_celing.html">CEIL 和 CEILING</a></td><td align="left">两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/floor.html">FLOOR</a></td><td align="left">向下取整，返回值转化为一个BIGINT</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/rand.html">RAND</a></td><td align="left">生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/round.html">ROUND</a></td><td align="left">对所传参数进行四舍五入。例如round(3.1415926,3)是四舍五入保留三位小数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/sign.html">SIGN</a></td><td align="left">返回参数的符号</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/pow_power.html">POW 和 POWER</a></td><td align="left">两个函数的功能相同，都是所传参数的次方的结果值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/sin.html">SIN</a></td><td align="left">求正弦值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/asin.html">ASIN</a></td><td align="left">求反正弦值，与函数 SIN 互为反函数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/cos.html">COS</a></td><td align="left">求余弦值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/acos.html">ACOS</a></td><td align="left">求反余弦值，与函数 COS 互为反函数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/tan.html">TAN</a></td><td align="left">求正切值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/atan.html">ATAN</a></td><td align="left">求反正切值，与函数 TAN 互为反函数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/cot.html">COT</a></td><td align="left">求余切值</td></tr></tbody></table><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table><thead><tr><th align="left">函数名称</th><th align="left">作 用</th></tr></thead><tbody><tr><td align="left"><a href="http://c.biancheng.net/mysql/length.html">LENGTH</a></td><td align="left">计算字符串长度函数，返回字符串的字节长度</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/concat.html">CONCAT</a></td><td align="left">合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/insert.html">INSERT</a></td><td align="left">替换字符串函数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/lower.html">LOWER</a></td><td align="left">将字符串中的字母转换为小写</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/upper.html">UPPER</a></td><td align="left">将字符串中的字母转换为大写</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/left.html">LEFT</a></td><td align="left">从左侧字截取符串，返回字符串左边的若干个字符</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/right.html">RIGHT</a></td><td align="left">从右侧字截取符串，返回字符串右边的若干个字符</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/trim.html">TRIM</a></td><td align="left">删除字符串左右两侧的空格</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/replace.html">REPLACE</a></td><td align="left">字符串替换函数，返回替换后的新字符串</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/substring.html">SUBSTRING</a></td><td align="left">截取字符串，返回从指定位置开始的指定长度的字符换</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/reverse.html">REVERSE</a></td><td align="left">字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td></tr></tbody></table><h2 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h2><table><thead><tr><th align="left">函数名称</th><th align="left">作 用</th></tr></thead><tbody><tr><td align="left"><a href="http://c.biancheng.net/mysql/curdate_current_date.html">CURDATE 和 CURRENT_DATE</a></td><td align="left">两个函数作用相同，返回当前系统的日期值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/curtime_current_time.html">CURTIME 和 CURRENT_TIME</a></td><td align="left">两个函数作用相同，返回当前系统的时间值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/now_sysdate.html">NOW 和 SYSDATE</a></td><td align="left">两个函数作用相同，返回当前系统的日期和时间值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/unix_timestamp.html">UNIX_TIMESTAMP</a></td><td align="left">获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/from_unixtime.html">FROM_UNIXTIME</a></td><td align="left">将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/month.html">MONTH</a></td><td align="left">获取指定日期中的月份</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/monthname.html">MONTHNAME</a></td><td align="left">获取指定日期中的月份英文名称</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/dayname.html">DAYNAME</a></td><td align="left">获取指定曰期对应的星期几的英文名称</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/dayofweek.html">DAYOFWEEK</a></td><td align="left">获取指定日期对应的一周的索引位置值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/week.html">WEEK</a></td><td align="left">获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/dayofyear.html">DAYOFYEAR</a></td><td align="left">获取指定曰期是一年中的第几天，返回值范围是1~366</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/dayofmonth.html">DAYOFMONTH</a></td><td align="left">获取指定日期是一个月中是第几天，返回值范围是1~31</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/year.html">YEAR</a></td><td align="left">获取年份，返回值范围是 1970〜2069</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/time_to_sec.html">TIME_TO_SEC</a></td><td align="left">将时间参数转换为秒数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/sec_to_time.html">SEC_TO_TIME</a></td><td align="left">将秒数转换为时间，与TIME_TO_SEC 互为反函数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/date_add_adddate.html">DATE_ADD 和 ADDDATE</a></td><td align="left">两个函数功能相同，都是向日期添加指定的时间间隔</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/date_sub_subdate.html">DATE_SUB 和 SUBDATE</a></td><td align="left">两个函数功能相同，都是向日期减去指定的时间间隔</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/addtime.html">ADDTIME</a></td><td align="left">时间加法运算，在原始时间上添加指定的时间</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/subtime.html">SUBTIME</a></td><td align="left">时间减法运算，在原始时间上减去指定的时间</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/datediff.html">DATEDIFF</a></td><td align="left">获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/date_format.html">DATE_FORMAT</a></td><td align="left">格式化指定的日期，根据参数返回指定格式的值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/weekday.html">WEEKDAY</a></td><td align="left">获取指定日期在一周内的对应的工作日索引</td></tr></tbody></table><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><table><thead><tr><th align="left">函数名称</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><a href="http://c.biancheng.net/mysql/max.html">MAX</a></td><td align="left">查询指定列的最大值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/min.html">MIN</a></td><td align="left">查询指定列的最小值</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/count.html">COUNT</a></td><td align="left">统计查询结果的行数</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/sum.html">SUM</a></td><td align="left">求和，返回指定列的总和</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/avg.html">AVG</a></td><td align="left">求平均值，返回指定列数据的平均值</td></tr></tbody></table><blockquote><p><strong>注意：null 值不参与所有聚合函数运算</strong></p></blockquote><h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><table><thead><tr><th align="left">函数名称</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><a href="http://c.biancheng.net/mysql/if.html">IF(expr1,expr2,expr3)</a></td><td align="left">判断，流程控制。expr1 的值为 TRUE，则返回值为 expr2 。否则返回 expr3</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/ifnull.html">IFNULL</a>（expr1,expr2）</td><td align="left">判断是否为空。例如select ifnull(age,0) from stu where id=0;如果这个学生年龄是null则返回0</td></tr><tr><td align="left"><a href="http://c.biancheng.net/mysql/case.html">CASE</a></td><td align="left">搜索语句</td></tr></tbody></table><hr><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><h2 id="一自增表共-7-条数据，删了最后-2-条，重启-MySQL后插入一条，此时-id-？"><a href="#一自增表共-7-条数据，删了最后-2-条，重启-MySQL后插入一条，此时-id-？" class="headerlink" title="一自增表共 7 条数据，删了最后 2 条，重启 MySQL后插入一条，此时 id ？"></a>一自增表共 7 条数据，删了最后 2 条，重启 MySQL后插入一条，此时 id ？</h2><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p><h2 id="MySQL-常用的引擎？"><a href="#MySQL-常用的引擎？" class="headerlink" title="MySQL 常用的引擎？"></a>MySQL 常用的引擎？</h2><p><code>InnoDB 引擎</code>：mysql 5.1 后默认的数据库引擎，提供了对数据库 <strong>acid 事务的支持</strong>，并且还提供了<strong>行级锁和外键的约束</strong>，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在<strong>内存中建立缓冲池，用于缓冲数据和索引</strong>。但该引擎<em>不支持全文搜索，同时启动也比较慢，它不会保存表的行数</em>，所以当进行 <code>select count(*) from table</code> 指令时，需要进行扫描全表。由于锁的粒度小，写操作不会锁定全表,所以<strong>在并发度较高的场景下使用会提升效率</strong>。<br><code>MyIASM 引擎</code>：<strong>不提供事务的支持，也不支持行级锁和外键</strong>。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是<strong>保存了表的行数</strong>，于是当进行 <code>select count(*) from table</code> 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><h2 id="MySQL-的行锁和表锁？"><a href="#MySQL-的行锁和表锁？" class="headerlink" title="MySQL 的行锁和表锁？"></a>MySQL 的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。<br><strong>表级锁：</strong>开销小，加锁快，不会出现死锁。锁粒度大，发生锁冲突的概率最高，并发量最低。<br><strong>行级锁：</strong>开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高。</p><h2 id="乐观锁和悲观锁？"><a href="#乐观锁和悲观锁？" class="headerlink" title="乐观锁和悲观锁？"></a>乐观锁和悲观锁？</h2><p><strong>乐观锁：</strong>每次拿数据时都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br><strong>悲观锁：</strong>每次拿数据时都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。采用数据库自身的<code>for update</code>能力，对数据库表或者行增加锁<br><em>数据库的乐观锁需要自己实现</em>，在表里面<strong>添加一个 <code>version</code> 字段，每次修改成功值加 1</strong>，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><h2 id="MySQL-问题排查都有哪些手段？"><a href="#MySQL-问题排查都有哪些手段？" class="headerlink" title="MySQL 问题排查都有哪些手段？"></a>MySQL 问题排查都有哪些手段？</h2><p>使用 <code>show processlist</code> 命令查看当前所有连接信息。<br>使用 <code>explain</code> 命令查询 SQL 语句执行计划。<br>开启<strong>慢查询日志</strong>，查看慢查询的 SQL。</p><h2 id="如何做-SQL-优化？"><a href="#如何做-SQL-优化？" class="headerlink" title="如何做 SQL 优化？"></a>如何做 SQL 优化？</h2><p><strong>一、避免不走索引的场景</strong></p><ul><li>尽量<strong>避免在字段开头模糊查询</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量**避免使用<code>not in</code>**，会导致引擎走全表扫描。</li><li>尽量<strong>避免使用 or</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量<strong>避免进行null值的判断</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量<strong>避免在where条件中等号的左侧进行表达式、函数操作</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>数据量大时，**避免使用<code>where 1 = 1</code>**。通常为方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引做全表扫描。</li><li>查询条件<strong>不能用 &lt;&gt; 或者 !=</strong></li><li>隐式类型转换造成不使用索引</li><li><strong><code>order by</code> 条件要与<code>where</code>中条件一致</strong>，否则order by不会利用索引进行排序</li><li><strong>正确使用<code>hint</code>优化语句</strong></li></ul><p><strong>二、SELECT语句其他优化</strong></p><ul><li><strong>避免出现select</strong></li><li><strong>避免出现不确定结果的函数</strong></li><li>多表关联查询时，<strong>小表在前，大表在后</strong>。</li><li>使用<strong>表的别名</strong></li><li>尽可能<strong>用<code>where</code>子句替换<code>HAVING</code>子句中的条件</strong></li></ul><h2 id="MySQL数据中有很多换行符和回车符怎么办？"><a href="#MySQL数据中有很多换行符和回车符怎么办？" class="headerlink" title="MySQL数据中有很多换行符和回车符怎么办？"></a>MySQL数据中有很多换行符和回车符怎么办？</h2><p><strong>换行符：</strong>CHAR(10) = “\n”<br><strong>回车符：</strong> CHAR(13) = “\r”<br>在MySQL中，回车符、换行符都属于char类型，放到varchar中时，在navcat等插件上是不显示的，需要在mysql终端和navcat对比才能看出来。</p><p><strong>如何去掉换行符、回车符</strong>。如果条件允许，建议<strong>直接通过语句清除掉换行符和回车符</strong>，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 去除<span class="string">&quot;hero title&quot;</span>列中所有换行符 (通过以下两种方式都可以)</span><br><span class="line">update <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">set</span> hero_title = REPLACE(hero_title, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">update <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">set</span> hero_title = REPLACE(hero_title, char(10), <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">// 去除<span class="string">&quot;hero title&quot;</span>列中所有回车符</span><br><span class="line">update <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">set</span> hero_title = REPLACE(hero_title, <span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">update <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">set</span> hero_title = REPLACE(hero_title, char(13),<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>如何忽略”换行符、回车符”进行SELECT查询</strong>。条件不允许，不能动库里的数据。可以通过修改SQL来<strong>过滤掉换行符、回车符，但一定程度上会影响查询效率</strong>，而且要改很多代码，你懂得。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 忽略掉换行符查询</span><br><span class="line">SELECT * from <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">where</span> REPLACE(hero_title, char(10), <span class="string">&#x27;&#x27;</span>) = <span class="string">&#x27;换行符换行符换行符’; </span></span><br><span class="line"><span class="string">// 忽略掉回车符查询</span></span><br><span class="line"><span class="string">SELECT * from &#x27;</span>LOL<span class="string">&#x27; where REPLACE(hero_title, char(13), &#x27;</span><span class="string">&#x27;) =&#x27;</span>回车符回车符回车符’;</span><br><span class="line">// 忽略掉换行符 &amp; 回车符查询</span><br><span class="line">SELECT * from <span class="string">&#x27;LOL&#x27;</span> <span class="built_in">where</span> REPLACE(REPLACE(hero_title, char(13), <span class="string">&#x27;&#x27;</span>), char(18),<span class="string">&#x27;&#x27;</span>) = <span class="string">&#x27;回车符回车符回车符’;</span></span><br></pre></td></tr></table></figure><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="MySQL-索引是怎么实现的？"><a href="#MySQL-索引是怎么实现的？" class="headerlink" title="MySQL 索引是怎么实现的？"></a>MySQL 索引是怎么实现的？</h2><p>索引是<strong>满足某种特定查找算法的数据结构</strong>，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 <strong><code>B+ 树</code><strong>实现的，</strong><code>B+ 树</code>的搜索效率，可到达二分法的性能</strong>，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h2 id="创建索引的原则有哪些？"><a href="#创建索引的原则有哪些？" class="headerlink" title="创建索引的原则有哪些？"></a>创建索引的原则有哪些？</h2><ul><li><strong>最左前缀匹配原则</strong>，组合索引非常重要的原则，mysql会一直**向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配**，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li><strong>较频繁作为查询条件的字段</strong>才去创建索引</li><li>更新频繁字段不适合创建索引</li><li><strong>不能有效区分数据的列不适合做索引列</strong>(如性别，男女未知，最多也就三种，区分度实在太低)</li><li>尽量的<strong>扩展索引，不要新建索引</strong>。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li><li><strong>定义有外键的数据列</strong>一定要建立索引。</li><li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li><li>对于定义为text、image和bit的数据类型的列不要建立索引。</li></ul><h2 id="怎么验证-MySQL-的索引是否满足需求"><a href="#怎么验证-MySQL-的索引是否满足需求" class="headerlink" title="怎么验证 MySQL 的索引是否满足需求"></a>怎么验证 MySQL 的索引是否满足需求</h2><p>使用 <code>explain</code> 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br><strong>explain 语法：</strong><code>explain select * from table where type=1</code>。</p><hr><h1 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h1><h2 id="导入数据后数据库数据重复原因及解决？"><a href="#导入数据后数据库数据重复原因及解决？" class="headerlink" title="导入数据后数据库数据重复原因及解决？"></a>导入数据后数据库数据重复原因及解决？</h2><p><strong>表象原因：</strong>如<em>网络延迟、用户连点、并发</em>等<br><strong>本质原因：</strong>在<em>数据库设计、及代码逻辑的严谨性</em>出了问题。</p><p><strong>前端解决方案（不可靠，推荐）</strong><br>    <em>用户点击按钮后，让按钮点击失效或者禁用</em>，待后端响应完成后，按钮可用<br><strong>数据库解决方案(可靠，推荐，适合高并发场景)</strong></p><ul><li>幂等主要手段就是通过表中的<strong>唯一约束</strong>实现。</li><li>添加表的<strong>唯一约束或唯一索引</strong>进行约束处理，是最有效的防治重复提交的方法</li><li>MySql 避免”重复插入记录”的方法：<code>INSERT ignore into，Replace into，ON DUPLICATE KEY UPDATE</code></li><li>使用 <code>ignore</code> 关键字，若用主键 <code>primary</code>或唯一索引 <code>unique</code> 区分了记录的唯一性，避免重复插入记录可以使用</li></ul><p><strong>悲观锁解决方案(可靠，推荐，适合高并发场景)</strong></p><ul><li><strong>悲观锁：</strong>以一种预防的姿态在<strong>修改数据之前把数据锁住</strong>，再对数据进行读写，<strong>释放锁之前任何人都不能对其数据进行操作</strong>，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，才可以对数据进行操作，一般数据库本身锁的机制都基于悲观锁;</li><li><strong>特点：</strong>可以完全<strong>保证数据的独占性和正确性</strong>，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</li></ul><p><strong>幂等：</strong>其任意多次执行所产生的影响均与一次执行的影响相同<br><strong>需要幂等的场景:</strong></p><ul><li><strong>核心业务数据新增</strong>，如订单系统中新增订单、用户信息系统中新增用户；</li><li><strong>审批流系统多人审批同一数据</strong>时，可能导致审批多次。</li><li><strong>定时任务触发</strong>数据生成时可能重复触发，导致数据生成多次。</li></ul>]]></content>
    
    
    <summary type="html">‌数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="https://southernfish.github.io/2025/07/24/java/java-base-10-reflection/"/>
    <id>https://southernfish.github.io/2025/07/24/java/java-base-10-reflection/</id>
    <published>2025-07-24T04:08:36.000Z</published>
    <updated>2025-07-23T14:14:12.453Z</updated>
    
    <content type="html"><![CDATA[<p>反射机制主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用，并在Lisp和<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089?fromModule=lemma_inlink">面向对象</a>方面取得了成绩。其中LEAD/LEAD++ 、OpenC++ 、<a href="https://baike.baidu.com/item/MetaXa/7854221?fromModule=lemma_inlink">MetaXa</a>和OpenJava等就是基于反射机制的语言。适用于计算机科学领域关于应用反射性的研究。本文简单整理了一些关于反射的相关问题。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/140324927">https://blog.csdn.net/qq_40991313/article/details/140324927</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><strong>反射：</strong>在程序运行期间<strong>动态地获取类的信息并对类进行操作</strong>的机制。在运行状态中，<em>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性</em>。</p><p><strong>通过反射机制可以实现：</strong></p><ul><li><p><strong>获取类或对象的Class对象：</strong>程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的所有方法和属性（包括私有，私有需要给该字段调用<code>setAccessible(true)</code>方法开启私有权限）。注意类的class对象是运行时生成的，类的class字节码文件是编译时生成的。</p></li><li><p><strong>创建实例：</strong>程序运行时，可以利用反射先创建类的Class对象再创建该类的实例，并访问该实例的成员；Xxx.class.newInstance() ;例如在Spring容器类源码里，Bean实例化就是通过Bean类的Class对象。Bean类的Class对象是从BeanDefinition对象的type成员变量取的。BeanDefinition对象存储一些Bean的类型、名称、作用域等声明信息。</p></li><li><p><strong>生成动态代理类或对象：</strong>程序运行时,可以通过反射机制生成一个类的动态代理类或动态代理对象。例如JDK中Proxy类的newProxyInstance静态方法，可以通过它创建基于接口的动态代理对象。</p></li></ul><blockquote><p><strong>类的字节码文件和Class对象的区别：</strong></p><ul><li>类的class字节码文件是编译时生成的，类的class对象是运行时生成的。</li><li>类的字节码文件是存储在电脑硬盘中的文件，如Test.class；类的Class对象是存放在内存中的数据，可快速获取其中的信息；</li><li>两者都存储类的各种信息；</li></ul></blockquote><p><strong>获取类Class对象的JVM底层：</strong>如果该类没有被加载过，会首先通过JVM实现类的加载过程，即加载、链接（验证、准备、解析）、初始化，加载阶段会生成类的Class对象。</p><p><strong>获取类Class对象的方法：</strong><code>dog.getClass();</code>，<code>Dog.class;</code>，<code>Class.forName(&quot;package1.Dog&quot;);</code></p><p><strong>特点：</strong></p><ul><li><strong>访问私有成员：</strong>构造方法、成员变量、方法对象取消访问检查可以访问私有成员；public void setAccessible(boolean flag):值为true，取消访问检查</li><li><strong>越过泛型检查：</strong>反射可以越过泛型检查，例如在ArrayList<Integer>中添加字符串</li></ul><p><strong>反射的优缺点：</strong></p><ul><li><strong>优点</strong>：<ul><li><strong>运行时获取属性：</strong>运行期间能够动态的获取类，提高代码的灵活性。</li><li><strong>访问私有成员：</strong>构造方法、成员变量、方法对象取消访问检查可以访问私有成员；public void setAccessible(boolean flag):值为true，取消访问检查</li><li><strong>越过泛型检查：</strong>反射可以越过泛型检查，例如在ArrayList<Integer>中添加字符串</li></ul></li><li><strong>缺点：性能差。</strong>性能比直接的Java代码要差很多。 </li></ul><p><strong>应用场景：</strong></p><ul><li><strong>JDBC加载数据库的驱动：</strong>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；</li><li><strong>Bean的生命周期：</strong><ul><li><strong>实例化xml解析出的类：</strong>多数框架都支持注解或XML配置来定义应用程序中的类，从xml配置中解析出来的类是字符串，需要利用反射机制实例化；如Spring通过<code>&lt;bean id=&quot;xx&quot; class=&quot;类全限定名&quot;&gt;</code>和<code>&lt;property name=&quot;按名称注入&quot; ref=&quot;被注入Bean的id&quot;&gt;</code>定义bean，然后通过<code>Class.forName(&quot;xxx.Xxx&quot;)</code>获取类的class对象，然后创建实例。</li><li><strong>注解容器类加载Bean、实例化Bean：</strong>Bean的生命周期中，注解容器类的构造方法会遍历<code>@ComponentScan(&quot;扫描路径&quot;)</code>下的.class文件，通过<code>类加载器.load(&quot;类名&quot;)</code>方式获得类的class对象，存入beanDefinitionMap。然后遍历beanDefinitionMap，通过class对象实例化等。</li></ul></li><li><strong>AOP创建动态代理对象：</strong>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理对象，这必须由反射机制来实现。</li></ul><p><strong>验证反射可以绕过泛型检查：</strong></p><p>基于反射，我们可以给<code>ArrayList&lt;Integer&gt;</code>对象中，加入字符串 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, </span><br><span class="line">                                                InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&gt; aClass = integers.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        add.invoke(integers, <span class="number">1</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">2</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">3</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">4</span>);</span><br><span class="line">        add.invoke(integers, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(integers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1,2,3,4,hello]</span></span><br></pre></td></tr></table></figure><hr><h1 id="反射获取Class对象"><a href="#反射获取Class对象" class="headerlink" title="反射获取Class对象"></a>反射获取Class对象</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>Class类的对象：</strong>程序运行时,可以通过反射获得任意一个类的Class对象,并通过这个对象查看这个类的所有方法和属性（包括私有，私有需要给该字段调用setAccessible(true)方法开启私有权限）。</p><p>注意类的class对象是运行时生成的，类的class字节码文件是编译时生成的。</p><p><strong>获取类Class对象：</strong></p><ul><li><strong>对象.getClass()：</strong>Object是一切类的根类，Object类有个getClass()方法可以获取类的Class对象。例如dog.getClass();</li><li><strong>类名.class（推荐）：</strong>例如Dog.class;</li><li><strong>Class.forName(“类名”)：</strong>例如Class.forName(“package1.Dog”);</li></ul><p><strong>Class对象的常用方法：</strong></p><ul><li><strong>获取类的信息</strong>：<ul><li><strong>String getName()：</strong>返回类的全限定名。<strong>全限定名</strong>包含包名和类名，用于唯一标识类或接口。例如package1.Dog、java.lang.String、java.util.Map$Entry</li><li><strong>String getSimpleName()：</strong>返回类的简单名。例如Dog</li><li><strong>tring getCanonicalName()：</strong>返回类的规范名。<strong>规范名</strong>是类的规范字符串形式，常用于打印和日志记录。例如package1.Dog、java.lang.String、java.util.Map.Entry</li><li><strong>Package getPackage()：</strong>返回此类所属的包。</li><li>ClassLoader getClassLoader()：返回该类的类加载器。</li><li>Class&lt;? super T&gt; getSuperclass()：返回表示类的超类的 Class 对象。</li><li>Class&lt;?&gt;[] getInterfaces()：返回类实现的所有接口。</li><li><strong>boolean isInterface()：</strong>判断是否是接口。</li><li>boolean isAnnotation()：判断是否是注解类型。</li><li>boolean isEnum()：判断是否是枚举类型。</li><li>Annotation[] getAnnotations()：返回此元素上存在的所有注解。</li><li>Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注解。</li><li>T getAnnotation(Class<T> annotationClass)：返回指定类型的注解，如果该注解存在于此元素上，否则返回 null。例如Spring源码中，ApplicaitonContext构造器判断一个类是不是Bean，是通过这个方法判断类有没有@Comonent等注解，从而判断它是不是Bean。</li></ul></li><li><strong>获取成员：</strong><ul><li><strong>Field[] getFields()：</strong>返回类的所有公共字段，包括从父类继承的字段。</li><li><strong>Field[] getDeclaredFields()：</strong>返回类声明的所有字段，不包括继承的字段。</li><li><strong>Method[] getMethods()：</strong>返回类的所有公共方法，包括从父类继承的方法。</li><li><strong>Method[] getDeclaredMethods()：</strong>返回类声明的所有方法，不包括继承的方法。</li><li><strong>Constructor&lt;?&gt;[] getConstructors()：</strong>返回类的所有公共构造方法。</li><li><strong>Constructor&lt;?&gt;[] getDeclaredConstructors()：</strong>返回类声明的所有构造方法。</li></ul></li><li><strong>其他方法</strong>：<ul><li><strong>T newInstance()：</strong>创建此 Class 对象所表示的类的一个新实例（使用默认构造方法）。</li></ul></li></ul><blockquote><p><strong>Spring源码：</strong>Bean初始化时判断类是否Bean、判断属性是否需要填充都用到了反射</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/137231482">Spring框架中Bean是如何加载的？从底层源码入手，详细解读Bean的创建流程-CSDN博客</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="comment">// 其他定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取类的Class对象： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//方法1：类的class属性</span></span><br><span class="line">        Class&lt;Dog&gt; c1=Dog.class;</span><br><span class="line">        <span class="comment">//方法2：对象的getClass方法</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">wangCaiDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>, <span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; c2= wangCaiDog.getClass();</span><br><span class="line">        <span class="comment">//方法3：Class类的静态方法forName</span></span><br><span class="line">        Class&lt;?&gt; c3= Class.forName(<span class="string">&quot;package1.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法4：使用类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        Class&lt;?&gt; c5 = systemClassLoader.loadClass(<span class="string">&quot;package1.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出：class package1.Dog</span></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        <span class="comment">//三种方式获取到Class对象地址是完全一致的</span></span><br><span class="line">        <span class="comment">// 输出：true</span></span><br><span class="line">        System.out.println(c1==c2&amp;&amp;c1==c3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取类的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exceptionn &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; dogClass = Dog.class;</span><br><span class="line">        System.out.println(dogClass.getName());</span><br><span class="line">        System.out.println(dogClass.getSimpleName());</span><br><span class="line">        System.out.println(dogClass.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全限定名和规范名"><a href="#全限定名和规范名" class="headerlink" title="全限定名和规范名"></a>全限定名和规范名</h2><p><strong>全限定名和规范名：</strong></p><p>外部类的全限定名和规范名是一样的，都是“xxx.类名”。区别主要在内部类，内部类的全限定名是“xxx.外部类名$内部类名”，规范名是“xxx.外部类名.内部类名”。</p><ul><li><strong>简单名：</strong>只包含类名。例如Dog、String、Entry</li><li><strong>全限定名：</strong>包含包名和类名，用于唯一标识类或接口，通过全限定名能找到唯一一个类。例如package1.Dog、java.lang.String、java.util.Map$Entry</li><li><strong>规范名：</strong>类的规范字符串形式，常用于打印和日志记录。例如package1.Dog、java.lang.String、java.util.Map.Entry</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// java.util.Map</span></span><br><span class="line">    System.out.println(Map.class.getName());</span><br><span class="line">    <span class="comment">// java.util.Map</span></span><br><span class="line">    System.out.println(Map.class.getCanonicalName());</span><br><span class="line">    <span class="comment">// 输出 &quot;java.util.Map$Entry&quot;</span></span><br><span class="line">    System.out.println(Map.Entry.class.getName());</span><br><span class="line">    <span class="comment">// 输出 &quot;java.util.Map.Entry&quot;</span></span><br><span class="line">    System.out.println(Map.Entry.class.getCanonicalName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="反射获取成员"><a href="#反射获取成员" class="headerlink" title="反射获取成员"></a>反射获取成员</h1><h2 id="反射获取构造方法"><a href="#反射获取构造方法" class="headerlink" title="反射获取构造方法"></a>反射获取构造方法</h2><p><strong>Class对象获取构造器：</strong></p><ul><li><strong>getConstructor(Class&lt;?&gt;… parameterTypes)：</strong>获取指定参数类型的公共构造方法。返回值是<strong>Constructor类</strong>。</li><li><strong>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)：</strong>获取指定参数类型的构造方法（包括私有构造方法）。</li><li><strong>getConstructors()：</strong>获取所有公共构造方法。</li><li><strong>getDeclaredConstructors()：</strong>获取所有构造方法（包括私有构造方法）。</li><li>**newInstance()**：创建类的新实例。<ul><li><strong>Class类的newInstance()：</strong>只能够调用无参构造函数；</li><li><strong>Constructor类的newInstance()：</strong>可以根据传入的参数，调用任意构造函数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有构造器对象：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;Dog&gt; dogClass = Dog.class;</span><br><span class="line">    Constructor&lt;?&gt;[] cons = dogClass.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor&lt;?&gt; con:cons)&#123;</span><br><span class="line">        System.out.println(con);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取单个构造器并实例化： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dogClass=Dog.class;</span><br><span class="line">        <span class="comment">//获取单个构造方法对象</span></span><br><span class="line">        Constructor&lt;?&gt; con=dogClass.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//构造方法对象实例化，会调用无参构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">dogObject</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line">        <span class="comment">// 无参构造器实例化，也可以直接用Class对象的newInstance方法，带参就不行了</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> dogClass.newInstance();</span><br><span class="line">        <span class="comment">//重写了Dog类的to_String，所以输出：Dog&#123;weight=0, name=&#x27;null&#x27;&#125;</span></span><br><span class="line">        System.out.println(dogObject);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射获取字段"><a href="#反射获取字段" class="headerlink" title="反射获取字段"></a>反射获取字段</h2><p><strong>Class对象获取字段：</strong></p><ul><li>getField(String name)：返回指定名称的公共字段。返回类型是字段类Field。</li><li><strong>getDeclaredField(String name)：</strong>返回指定名称的字段<strong>（包括私有字段）</strong>。</li><li>getFields()：返回所有公共字段。</li><li><strong>getDeclaredFields()：</strong>返回所有字段<strong>（包括私有字段）</strong>。</li></ul><p><strong>字段类Field常用方法：</strong></p><p><strong>获取字段信息</strong>：</p><ul><li><strong>getName()：</strong>返回字段的名称。</li><li><strong>getType()：</strong>返回字段的类型。</li><li><strong>getModifiers()：</strong>返回字段的修饰符。</li><li><strong>getDeclaringClass()：</strong>返回声明该字段的类的 Class 对象。</li></ul><p><strong>获取和设置字段值</strong>：</p><ul><li><strong>get(Object obj)：</strong>返回指定对象上此字段的值。</li><li><strong>getBoolean(Object obj)：</strong>返回指定对象上此字段的值（如果字段类型是 boolean）。</li><li>getByte(Object obj)：返回指定对象上此字段的值（如果字段类型是 byte）。</li><li>getChar(Object obj)：返回指定对象上此字段的值（如果字段类型是 char）。</li><li>getDouble(Object obj)：返回指定对象上此字段的值（如果字段类型是 double）。</li><li>getFloat(Object obj)：返回指定对象上此字段的值（如果字段类型是 float）。</li><li>getInt(Object obj)：返回指定对象上此字段的值（如果字段类型是 int）。</li><li>getLong(Object obj)：返回指定对象上此字段的值（如果字段类型是 long）。</li><li>getShort(Object obj)：返回指定对象上此字段的值（如果字段类型是 short）。</li><li><strong>set(Object obj, Object value)：</strong>设置指定对象上此字段的值。注意私有字段默认不允许赋值，要赋值必须给私有字段setAccessible(true)。</li><li><strong>setBoolean(Object obj, boolean value)：</strong>设置指定对象上此字段的值（如果字段类型是 boolean）。</li><li>setByte(Object obj, byte value)：设置指定对象上此字段的值（如果字段类型是 byte）。</li><li>setChar(Object obj, char value)：设置指定对象上此字段的值（如果字段类型是 char）。</li><li>setDouble(Object obj, double value)：设置指定对象上此字段的值（如果字段类型是 double）。</li><li>setFloat(Object obj, float value)：设置指定对象上此字段的值（如果字段类型是 float）。</li><li>setInt(Object obj, int value)：设置指定对象上此字段的值（如果字段类型是 int）。</li><li>setLong(Object obj, long value)：设置指定对象上此字段的值（如果字段类型是 long）。</li><li>setShort(Object obj, short value)：设置指定对象上此字段的值（如果字段类型是 short）。</li></ul><p><strong>其他方法</strong>：</p><ul><li><strong>isAccessible()：</strong>返回字段是否可访问。</li><li><strong>setAccessible(boolean flag)：</strong>设置字段的可访问性。通过这个方法可以让私有字段也可以赋值。</li><li>oGenericString()：返回字段的描述，包括泛型信息。</li><li>getAnnotatedType()：返回此字段的带注释的类型。</li><li>getAnnotations()：返回字段的所有注解。</li><li><strong>getAnnotation(Class<T> annotationClass)：</strong>返回字段的指定类型的注解，如果该注解不存在，则返回 null。例如Spring源码中依赖注入这一块，就是基于反射获取类中字段有没有@Resource、@Component等注解，有的话就是要注入Bean.</li><li>getDeclaredAnnotations()：返回直接存在于此字段上的所有注解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量对象并赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 1.获取Class对象，并实例化</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; dogClass = Dog.class;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> dogClass.newInstance();</span><br><span class="line">        <span class="comment">// 2.获取字段对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">weightField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;weight&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.给字段对象赋值</span></span><br><span class="line">        nameField.set(dog, <span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">        <span class="comment">// 注意私有字段默认不允许赋值，要赋值必须给私有字段设置可访问</span></span><br><span class="line">        weightField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        weightField.set(dog, <span class="number">10</span>);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Field获取的Class类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dogClass=Dog.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">weightField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; dogClassByField = weightField.getDeclaringClass();</span><br><span class="line">        <span class="comment">// 通过字段获取到的class对象和源class对象是地址是一样的，事实上一个类的所有Class对象都是一个实例</span></span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">        System.out.println(dogClassByField==dogClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射获取普通方法"><a href="#反射获取普通方法" class="headerlink" title="反射获取普通方法"></a>反射获取普通方法</h2><p>Class对象获取成员方法的方法： </p><ul><li><p><strong>getMethod(String name, Class&lt;?&gt;… parameterTypes)：</strong>返回指定名称和参数类型的公共方法。返回值是<strong>方法类Method。</strong></p></li><li><p><strong>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)：</strong>返回指定名称和参数类型的方法（包括私有方法）。</p></li><li><p><strong>getMethods()：</strong>返回所有公共方法（包括从父类<strong>继承的方法</strong>）。</p></li><li><p><strong>getDeclaredMethods()：</strong>返回所有方法（包括<strong>私有方法</strong>）。</p></li><li><p><strong>Method类的方法：</strong></p><ul><li><strong>获取方法信息</strong>：<ul><li>getName()：返回方法的名称。</li><li>getReturnType()：返回方法的返回类型。</li><li>getParameterTypes()：返回方法参数类型的数组。</li><li>getModifiers()：返回方法的修饰符。</li><li>getDeclaringClass()：返回声明此方法的类的 Class 对象。</li></ul></li></ul></li><li><p><strong>调用方法</strong>：</p><ul><li><strong>Object invoke(Object obj, Object… args)：</strong>调用指定对象上此 Method 对象表示的基础方法。</li></ul></li><li><p><strong>其他方法</strong>：</p><ul><li><strong>isAccessible()：</strong>返回方法是否可访问。</li><li><strong>setAccessible(boolean flag)：</strong>设置方法的可访问性。</li><li><strong>getAnnotations()：</strong>返回此方法的所有注解。例如Spring源码中通过此方法判断一个类中</li><li>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)：判断此方法是否被指定的注解类型注释。</li><li>getAnnotation(Class<T> annotationClass)：返回该方法的指定类型的注解。</li><li>getExceptionTypes()：返回此方法抛出的异常类型的数组。</li><li>toGenericString()：返回方法的描述，包括泛型信息。</li></ul></li></ul><p><strong>获取成员变量对象并调用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取构造方法对象并实例化</span></span><br><span class="line">Class&lt;?&gt; c= Class.forName(<span class="string">&quot;train.Dog&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con=c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="comment">// 2.获取成员方法对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line"><span class="comment">// 3.通过成员方法对象的invoke方法，调用构造方法对象的成员方法</span></span><br><span class="line"><span class="comment">// 无参无返回值方法</span></span><br><span class="line">eat.invoke(obj);</span><br><span class="line"><span class="comment">// 带参有返回值方法</span></span><br><span class="line">Object sucess= eat.invoke(obj,<span class="string">&quot;food&quot;</span>);</span><br><span class="line">System.out.println((<span class="type">boolean</span>)sucess);</span><br></pre></td></tr></table></figure><hr><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><h2 id="什么是-Java-序列化？什么情况下需要序列化？"><a href="#什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="什么是 Java 序列化？什么情况下需要序列化？"></a>什么是 Java 序列化？什么情况下需要序列化？</h2><p>Java 序列化是<strong>为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来</strong>。<br>以下情况需要使用 Java 序列化：</p><ul><li>想把内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过RMI（远程方法调用）传输对象的时候。</li></ul><h2 id="动态代理是什么？有哪些应用？实现原理？"><a href="#动态代理是什么？有哪些应用？实现原理？" class="headerlink" title="动态代理是什么？有哪些应用？实现原理？"></a><strong>动态代理是什么？有哪些应用？实现原理？</strong></h2><p><strong>动态代理：</strong>运行时动态创建代理对象的技术，通过反射机制生成代理类，无需手动编写代理代码即可实现对目标对象的间接访问和控制。</p><p><strong>动态代理应用：</strong>实现<em>AOP、日志记录、权限校验、hibernate 数据查询、测试框架的后端 mock、rpc</em>等功能</p><p><strong>实现原理：</strong>包括<strong>JDK动态代理（基于接口）和CGLIB动态代理（基于类继承）</strong>。</p>]]></content>
    
    
    <summary type="html">Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>锁</title>
    <link href="https://southernfish.github.io/2025/07/24/java/java-base-9-lock/"/>
    <id>https://southernfish.github.io/2025/07/24/java/java-base-9-lock/</id>
    <published>2025-07-24T02:28:36.000Z</published>
    <updated>2025-07-23T14:14:03.966Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 多线程环境中，锁是<strong>确保共享资源线程安全</strong>的重要手段。</p><p>参考文章：<a href="https://blog.csdn.net/qq_45675973/article/details/147740830">Java锁详解</a>、参考链接：<a href="https://blog.csdn.net/qq_40991313/article/details/140324927">https://blog.csdn.net/qq_40991313/article/details/140324927</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><p>在 Java 多线程环境中，锁是<strong>确保共享资源线程安全</strong>的重要手段。 当线程要操作共享资源时，需先获取对应的锁，以此保证在操作过程中，该资源不会被其他线程访问。待操作结束后，线程释放锁，使其他线程有机会获取并操作该资源。 </p><h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>锁可以确保多个线程之间对共享资源的访问是互斥的，也就是同一时刻只有一个线程能够访问被保护的共享资源，从而避免并发访问带来的数据不一致性和竞态条件等问题，是解决线程安全问题常用手段之一。</p><h2 id="什么是死锁及如何防止死锁"><a href="#什么是死锁及如何防止死锁" class="headerlink" title="什么是死锁及如何防止死锁"></a>什么是死锁及如何防止死锁</h2><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。防止死锁有如下方式：</p><ul><li>尽量使用 <code>tryLock(long timeout, TimeUnit unit)</code> 的方法 (ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量<strong>使用 Java. util. concurrent 并发类</strong>代替自己手写锁。</li><li>尽量<strong>降低锁的使用粒度</strong>，尽量不要几个功能用同一把锁。</li><li>尽量<strong>减少同步的代码块</strong>。</li></ul><h1 id="Synchronized锁"><a href="#Synchronized锁" class="headerlink" title="Synchronized锁"></a>Synchronized锁</h1><p>synchronized 由<strong>一对 monitorenter/monitorexit 指令实现，monitor 对象是同步的基本实现单元</strong>。<br>在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的<strong>互斥锁</strong>，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。可以作用于实例方法、静态方法、代码块，能够保证同一个时刻只有一个线程执行该段代码，保证线程安全。 在执行完或者出现异常时自动释放锁。synchronized锁基于对象头、CAS、Monitor对象，<br>在 Java 6 的时候，Java 虚拟机提供了三种 monitor 实现：<strong>偏向锁（Biased Locking）、轻量级锁和重量级锁</strong>，改进了性能。</p><p><strong>作用于三个位置：</strong></p><ol><li><p>作用在静态方法上,则锁是当前类的Class对象。</p></li><li><p>作用在普通方法上,则锁是当前的实例（this）。</p></li><li><p>作用在代码块上,则需要在关键字后面的小括号里,显式指定锁对象，例如this、Xxx.class。</p></li></ol><p><strong>对象头存储锁信息：</strong> synchronized的底层是采用对象头的Mark Word来存储锁信息的。Hotspot 虚拟机（JVM默认虚拟机）中每个对象都有一个对象头(Object Header)，包含Mark Word（标记字段） 和 Class Pointer（类型指针）。</p><ul><li><p><strong>Mark Word（标记字段）：</strong>存储哈希码、GC分代年龄、锁信息、GC标记（标志位，标记可达对象或垃圾对象）等。<strong>锁信息包括：</strong></p><ul><li><p><strong>锁标志位：</strong>64位的二进制数，通过末尾能判断锁状态。01未锁定、01可偏向、00轻量级锁、10重量级锁、11垃圾回收标记</p></li><li><p><strong>偏向锁线程ID、时间戳等；</strong></p></li><li><p><strong>轻量级锁的指针：</strong>指向锁记录的指针</p></li><li><p><strong>重量级锁的指针：</strong>指向Monitor锁的指针</p></li></ul></li><li><p><strong>类型指针：</strong>指向它的类元数据的指针，用于找到对象所在的类</p></li></ul><p>不考虑共享资源是类变量等特殊情况的话，有共享资源的多个线程通常都属于同一个对象。</p><p><strong>Monitor对象：</strong>每个 Java 对象都可以关联一个 Monitor 对象，也称为监视器锁或Monitor锁。Monitor锁用于控制线程对共享资源的访问，开发人员不能直接访问Monitor对象。当一个线程获取了Monitor的锁后，其他试图获取该锁的线程就会被阻塞，直到当前线程释放锁为止。</p><p>当一个线程执行synchronized方法或代码块并升级成<strong>重量级锁</strong>时，当前对象会关联一个Monitor对象，线程须获得该对象的Monitor锁才能执行。Monitor有<code>Owner、EntryList、WaitSet</code>三个字段，分别表示Monitor的<strong>持有者线程(获得锁的线程)、阻塞队列、和等待队列</strong>。</p><p><strong>线程通信：</strong>synchronized通过Monitor对象，利用Object的wait，notify，notifyAll等方法来实现线程通信。</p><p><strong>锁升级：</strong>JDK6之前synchronized只有无锁和重量级锁两个状态，JDK6引入偏向锁、轻量级锁两个状态，锁可以根据竞争程度从无锁状态慢慢升级到重量级锁。当竞争小的时候，只需以较小的代价加锁，直到竞争加剧，才使用重量级锁，从而减小了加锁带来的开销。</p><ul><li><strong>锁升级顺序：</strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</li><li><strong>无锁：</strong>没有线程访问同步代码块时。没有对资源进行锁定，所有的线程都能访问并不断修改同一个资源，但同时只有一个线程能修改成功，失败线程会不断重试。</li><li><strong>偏向锁：</strong>当有一个线程访问同步代码块时升级为偏向锁。一段同步代码块一直被一个线程所访问，那么该线程id会CAS写入对象头，下次再访问同步代码块时对象头检查到该线程id，就不用加锁解锁了，降低获取锁的代价。</li><li><strong>轻量级锁（自旋锁）：</strong>有锁竞争时升级为轻量级锁。其他线程会通过自旋的形式尝试通过CAS将对象头中Mark Word替换为指向线程栈帧里锁记录的指针，从而获得锁；同时线程锁记录里存放Mark Word信息。竞争的线程不会阻塞但会一直自旋，消耗CPU性能，但速度快。</li><li><strong>重量级锁：</strong>锁膨胀（自旋失败10次）时升级为重量级锁。Mark Word中存储的是指向Monitor锁的指针，对象Mark Word信息也会保存在Monitor锁里，当一个线程获取了Monitor锁后，竞争线程会被阻塞，不再自旋，不消耗CPU，速度慢。</li></ul><h2 id="多线程中-synchronized-锁升级的原理"><a href="#多线程中-synchronized-锁升级的原理" class="headerlink" title="多线程中 synchronized 锁升级的原理"></a>多线程中 synchronized 锁升级的原理</h2><p><strong>synchronized 锁升级原理：</strong>在锁对象的对象头里面有一个 <strong>threadid</strong> 字段，在第一次访问的时候 <strong>threadid 为空，jvm 让其持有偏向锁</strong>，并将 threadid 设置为其线程 id，再次进入的时候会先<strong>判断 threadid 是否与其线程 id 一致</strong>，如果一致则可以直接使用此对象，如果<strong>不一致，则升级偏向锁为轻量级锁</strong>，通过<strong>自旋循环</strong>一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁<strong>从轻量级升级为重量级锁</strong>，此过程就构成了 synchronized 锁的升级。<br><strong>锁的升级的目的：</strong>锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h2 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h2><p>volatile 是<strong>变量修饰符</strong>；synchronized 是<strong>修饰类、方法、代码段</strong>。<br>volatile 仅能实现<strong>变量的修改可见性但不能保证原子性</strong>；而 synchronized 则可以<strong>保证变量的修改可见性和原子性</strong>。<br>volatile 不会造成线程的阻塞；synchronized 可能<strong>会造成线程的阻塞</strong>。</p><h2 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h2><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但在 Java 6 中对 synchronized 进行了非常多的改进。主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰类、方法、代码块等。</li></ul><h2 id="atomic-的原理"><a href="#atomic-的原理" class="headerlink" title="atomic 的原理"></a>atomic 的原理</h2><p>atomic 主要利用 CAS (Compare And Wap) 、 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><hr><h1 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h1><p>Lock提供比同步方法和代码块更广泛的锁定操作。</p><ul><li><strong>lock()：</strong>获取锁。如果锁不可用，则当前线程将被禁用，直到获取锁为止。</li><li><strong>tryLock()：</strong>尝试获取锁，如果锁可用，则获取并立即返回 true；如果锁不可用，则立即返回 false，不会等待。</li><li><strong>tryLock(long time, TimeUnit unit)：</strong>尝试在指定的时间内获取锁。如果锁可用，则获取并立即返回 true；如果在指定时间内锁不可用，则等待直到超时，然后返回 false。</li><li><strong>unlock()：</strong>释放锁。</li><li><strong>newCondition()：</strong>返回一个绑定到此 Lock 实例的新 Condition 实例，可以用于线程之间的协调等待。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">sellTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized-和-Lock-的区别"><a href="#synchronized-和-Lock-的区别" class="headerlink" title="synchronized 和 Lock 的区别"></a>synchronized 和 Lock 的区别</h2><p>Lock和synchronized有以下几点不同：</p><ul><li><strong>作用范围</strong>。synchronized 可以给类、方法、代码块加锁；而 <strong>lock 只能给代码块加锁</strong>。</li><li><strong>接口和关键字。</strong>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现。</li><li><strong>死锁问题。</strong>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁。</li><li><strong>让等待锁的线程响应中断。</strong>Lock可以可以通过lockInterruptibly()获取锁的方法让等待锁的线程响应中断。而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。</li><li><strong>得知是否成功获取锁。</strong>通过Lock可以通过tryLock()知道有没有成功获取锁，而synchronized却无法办到。</li><li><strong>性能对比。</strong>两者性能差不多。JDK6之前synchronized没有锁升级，线程竞争非常激烈时Lock的性能要远远优于synchronized；而JDK6引入锁升级后，线程竞争激烈时候两者性能也相差无几。</li></ul><p><strong>lock锁中断线程：</strong>若有线程已拿到锁，其他线程使用lock()获取锁时会阻塞，使用<code>lockInterruptibly()</code>获取锁时会直接中断抛出<code>InterruptedException</code>异常。</p><p><strong>lock锁编码习惯：</strong>加锁代码要放到try外面。如果放在try里面的话，加锁失败抛异常或者加锁前的代码抛异常后，执行finally里的解锁代码，而其实加锁都没成功，最终解锁就也不合适了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();         <span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>/<span class="number">0</span>;            <span class="comment">// 这里抛异常会直接进入finally</span></span><br><span class="line">lock.lock();         <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分布式锁：</strong>SETNX、Redisson。Redisson基于Redis协议，可以实现可重入锁、公平锁、读写锁、信号量、闭锁（计数器），支持看门狗自动续期。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>反射：</strong>在程序运行期间<strong>动态地获取类的信息并对类进行操作</strong>的机制。</p><p><strong>通过反射机制可以实现：</strong></p><ul><li><p><strong>获取类或对象的Class对象：</strong>程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的所有方法和属性（包括私有，私有需要给该字段调用<code>setAccessible(true)</code>方法开启私有权限）。注意类的class对象是运行时生成的，类的class字节码文件是编译时生成的。</p></li><li><p><strong>创建实例：</strong>程序运行时，可以利用反射先创建类的Class对象再创建该类的实例，并访问该实例的成员；Xxx.class.newInstance() ;例如在Spring容器类源码里，Bean实例化就是通过Bean类的Class对象。Bean类的Class对象是从BeanDefinition对象的type成员变量取的。BeanDefinition对象存储一些Bean的类型、名称、作用域等声明信息。</p></li><li><p><strong>生成动态代理类或对象：</strong>程序运行时,可以通过反射机制生成一个类的动态代理类或动态代理对象。例如JDK中Proxy类的newProxyInstance静态方法，可以通过它创建基于接口的动态代理对象。</p></li></ul><blockquote><p><strong>类的字节码文件和Class对象的区别：</strong></p><ul><li>类的class字节码文件是编译时生成的，类的class对象是运行时生成的。</li><li>类的字节码文件是存储在电脑硬盘中的文件，如Test.class；类的Class对象是存放在内存中的数据，可快速获取其中的信息；</li><li>两者都存储类的各种信息；</li></ul></blockquote><p><strong>获取类Class对象的JVM底层：</strong>如果该类没有被加载过，会首先通过JVM实现类的加载过程，即加载、链接（验证、准备、解析）、初始化，加载阶段会生成类的Class对象。</p><p><strong>获取类Class对象的方法：</strong><code>dog.getClass();</code>，<code>Dog.class;</code>，<code>Class.forName(&quot;package1.Dog&quot;);</code></p><p><strong>特点：</strong></p><ul><li><strong>访问私有成员：</strong>构造方法、成员变量、方法对象取消访问检查可以访问私有成员；public void setAccessible(boolean flag):值为true，取消访问检查</li><li><strong>越过泛型检查：</strong>反射可以越过泛型检查，例如在ArrayList<Integer>中添加字符串</li></ul><p><strong>反射的优缺点：</strong></p><ul><li><strong>优点</strong>：<ul><li><strong>运行时获取属性：</strong>运行期间能够动态的获取类，提高代码的灵活性。</li><li><strong>访问私有成员：</strong>构造方法、成员变量、方法对象取消访问检查可以访问私有成员；public void setAccessible(boolean flag):值为true，取消访问检查</li><li><strong>越过泛型检查：</strong>反射可以越过泛型检查，例如在ArrayList<Integer>中添加字符串</li></ul></li><li><strong>缺点：性能差。</strong>性能比直接的Java代码要差很多。 </li></ul><p><strong>应用场景：</strong></p><ul><li><strong>JDBC加载数据库的驱动：</strong>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；</li><li><strong>Bean的生命周期：</strong><ul><li><strong>实例化xml解析出的类：</strong>多数框架都支持注解或XML配置来定义应用程序中的类，从xml配置中解析出来的类是字符串，需要利用反射机制实例化；如Spring通过<code>&lt;bean id=&quot;xx&quot; class=&quot;类全限定名&quot;&gt;</code>和<code>&lt;property name=&quot;按名称注入&quot; ref=&quot;被注入Bean的id&quot;&gt;</code>定义bean，然后通过<code>Class.forName(&quot;xxx.Xxx&quot;)</code>获取类的class对象，然后创建实例。</li><li><strong>注解容器类加载Bean、实例化Bean：</strong>Bean的生命周期中，注解容器类的构造方法会遍历<code>@ComponentScan(&quot;扫描路径&quot;)</code>下的.class文件，通过<code>类加载器.load(&quot;类名&quot;)</code>方式获得类的class对象，存入beanDefinitionMap。然后遍历beanDefinitionMap，通过class对象实例化等。</li></ul></li><li><strong>AOP创建动态代理对象：</strong>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理对象，这必须由反射机制来实现。</li></ul><p><strong>验证反射可以绕过泛型检查：</strong></p><p>基于反射，我们可以给<code>ArrayList&lt;Integer&gt;</code>对象中，加入字符串 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, </span><br><span class="line">                                                InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&gt; aClass = integers.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        add.invoke(integers, <span class="number">1</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">2</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">3</span>);</span><br><span class="line">        add.invoke(integers, <span class="number">4</span>);</span><br><span class="line">        add.invoke(integers, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(integers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1,2,3,4,hello]</span></span><br></pre></td></tr></table></figure><h2 id="反射获取Class对象"><a href="#反射获取Class对象" class="headerlink" title="反射获取Class对象"></a>反射获取Class对象</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>Class类的对象：</strong>程序运行时,可以通过反射获得任意一个类的Class对象,并通过这个对象查看这个类的所有方法和属性（包括私有，私有需要给该字段调用setAccessible(true)方法开启私有权限）。</p><p>注意类的class对象是运行时生成的，类的class字节码文件是编译时生成的。</p><p><strong>获取类Class对象：</strong></p><ul><li><strong>对象.getClass()：</strong>Object是一切类的根类，Object类有个getClass()方法可以获取类的Class对象。例如dog.getClass();</li><li><strong>类名.class（推荐）：</strong>例如Dog.class;</li><li><strong>Class.forName(“类名”)：</strong>例如Class.forName(“package1.Dog”);</li></ul><p><strong>Class对象的常用方法：</strong></p><ul><li><strong>获取类的信息</strong>：<ul><li><strong>String getName()：</strong>返回类的全限定名。<strong>全限定名</strong>包含包名和类名，用于唯一标识类或接口。例如package1.Dog、java.lang.String、java.util.Map$Entry</li><li><strong>String getSimpleName()：</strong>返回类的简单名。例如Dog</li><li><strong>tring getCanonicalName()：</strong>返回类的规范名。<strong>规范名</strong>是类的规范字符串形式，常用于打印和日志记录。例如package1.Dog、java.lang.String、java.util.Map.Entry</li><li><strong>Package getPackage()：</strong>返回此类所属的包。</li><li>ClassLoader getClassLoader()：返回该类的类加载器。</li><li>Class&lt;? super T&gt; getSuperclass()：返回表示类的超类的 Class 对象。</li><li>Class&lt;?&gt;[] getInterfaces()：返回类实现的所有接口。</li><li><strong>boolean isInterface()：</strong>判断是否是接口。</li><li>boolean isAnnotation()：判断是否是注解类型。</li><li>boolean isEnum()：判断是否是枚举类型。</li><li>Annotation[] getAnnotations()：返回此元素上存在的所有注解。</li><li>Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注解。</li><li>T getAnnotation(Class<T> annotationClass)：返回指定类型的注解，如果该注解存在于此元素上，否则返回 null。例如Spring源码中，ApplicaitonContext构造器判断一个类是不是Bean，是通过这个方法判断类有没有@Comonent等注解，从而判断它是不是Bean。</li></ul></li><li><strong>获取成员：</strong><ul><li><strong>Field[] getFields()：</strong>返回类的所有公共字段，包括从父类继承的字段。</li><li><strong>Field[] getDeclaredFields()：</strong>返回类声明的所有字段，不包括继承的字段。</li><li><strong>Method[] getMethods()：</strong>返回类的所有公共方法，包括从父类继承的方法。</li><li><strong>Method[] getDeclaredMethods()：</strong>返回类声明的所有方法，不包括继承的方法。</li><li><strong>Constructor&lt;?&gt;[] getConstructors()：</strong>返回类的所有公共构造方法。</li><li><strong>Constructor&lt;?&gt;[] getDeclaredConstructors()：</strong>返回类声明的所有构造方法。</li></ul></li><li><strong>其他方法</strong>：<ul><li><strong>T newInstance()：</strong>创建此 Class 对象所表示的类的一个新实例（使用默认构造方法）。</li></ul></li></ul><blockquote><p><strong>Spring源码：</strong>Bean初始化时判断类是否Bean、判断属性是否需要填充都用到了反射</p><p><a href="https://blog.csdn.net/qq_40991313/article/details/137231482">Spring框架中Bean是如何加载的？从底层源码入手，详细解读Bean的创建流程-CSDN博客</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="comment">// 其他定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取类的Class对象： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//方法1：类的class属性</span></span><br><span class="line">        Class&lt;Dog&gt; c1=Dog.class;</span><br><span class="line">        <span class="comment">//方法2：对象的getClass方法</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">wangCaiDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>, <span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; c2= wangCaiDog.getClass();</span><br><span class="line">        <span class="comment">//方法3：Class类的静态方法forName</span></span><br><span class="line">        Class&lt;?&gt; c3= Class.forName(<span class="string">&quot;package1.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法4：使用类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        Class&lt;?&gt; c5 = systemClassLoader.loadClass(<span class="string">&quot;package1.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出：class package1.Dog</span></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        <span class="comment">//三种方式获取到Class对象地址是完全一致的</span></span><br><span class="line">        <span class="comment">// 输出：true</span></span><br><span class="line">        System.out.println(c1==c2&amp;&amp;c1==c3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取类的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exceptionn &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; dogClass = Dog.class;</span><br><span class="line">        System.out.println(dogClass.getName());</span><br><span class="line">        System.out.println(dogClass.getSimpleName());</span><br><span class="line">        System.out.println(dogClass.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全限定名和规范名"><a href="#全限定名和规范名" class="headerlink" title="全限定名和规范名"></a>全限定名和规范名</h3><p><strong>全限定名和规范名：</strong></p><p>外部类的全限定名和规范名是一样的，都是“xxx.类名”。区别主要在内部类，内部类的全限定名是“xxx.外部类名$内部类名”，规范名是“xxx.外部类名.内部类名”。</p><ul><li><strong>简单名：</strong>只包含类名。例如Dog、String、Entry</li><li><strong>全限定名：</strong>包含包名和类名，用于唯一标识类或接口，通过全限定名能找到唯一一个类。例如package1.Dog、java.lang.String、java.util.Map$Entry</li><li><strong>规范名：</strong>类的规范字符串形式，常用于打印和日志记录。例如package1.Dog、java.lang.String、java.util.Map.Entry</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// java.util.Map</span></span><br><span class="line">    System.out.println(Map.class.getName());</span><br><span class="line">    <span class="comment">// java.util.Map</span></span><br><span class="line">    System.out.println(Map.class.getCanonicalName());</span><br><span class="line">    <span class="comment">// 输出 &quot;java.util.Map$Entry&quot;</span></span><br><span class="line">    System.out.println(Map.Entry.class.getName());</span><br><span class="line">    <span class="comment">// 输出 &quot;java.util.Map.Entry&quot;</span></span><br><span class="line">    System.out.println(Map.Entry.class.getCanonicalName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射获取成员"><a href="#反射获取成员" class="headerlink" title="反射获取成员"></a>反射获取成员</h2><h3 id="反射获取构造方法"><a href="#反射获取构造方法" class="headerlink" title="反射获取构造方法"></a>反射获取构造方法</h3><p><strong>Class对象获取构造器：</strong></p><ul><li><strong>getConstructor(Class&lt;?&gt;… parameterTypes)：</strong>获取指定参数类型的公共构造方法。返回值是<strong>Constructor类</strong>。</li><li><strong>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)：</strong>获取指定参数类型的构造方法（包括私有构造方法）。</li><li><strong>getConstructors()：</strong>获取所有公共构造方法。</li><li><strong>getDeclaredConstructors()：</strong>获取所有构造方法（包括私有构造方法）。</li><li>**newInstance()**：创建类的新实例。<ul><li><strong>Class类的newInstance()：</strong>只能够调用无参构造函数；</li><li><strong>Constructor类的newInstance()：</strong>可以根据传入的参数，调用任意构造函数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有构造器对象：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;Dog&gt; dogClass = Dog.class;</span><br><span class="line">    Constructor&lt;?&gt;[] cons = dogClass.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor&lt;?&gt; con:cons)&#123;</span><br><span class="line">        System.out.println(con);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取单个构造器并实例化： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dogClass=Dog.class;</span><br><span class="line">        <span class="comment">//获取单个构造方法对象</span></span><br><span class="line">        Constructor&lt;?&gt; con=dogClass.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//构造方法对象实例化，会调用无参构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">dogObject</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line">        <span class="comment">// 无参构造器实例化，也可以直接用Class对象的newInstance方法，带参就不行了</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> dogClass.newInstance();</span><br><span class="line">        <span class="comment">//重写了Dog类的to_String，所以输出：Dog&#123;weight=0, name=&#x27;null&#x27;&#125;</span></span><br><span class="line">        System.out.println(dogObject);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取字段"><a href="#反射获取字段" class="headerlink" title="反射获取字段"></a>反射获取字段</h3><p><strong>Class对象获取字段：</strong></p><ul><li>getField(String name)：返回指定名称的公共字段。返回类型是字段类Field。</li><li><strong>getDeclaredField(String name)：</strong>返回指定名称的字段<strong>（包括私有字段）</strong>。</li><li>getFields()：返回所有公共字段。</li><li><strong>getDeclaredFields()：</strong>返回所有字段<strong>（包括私有字段）</strong>。</li></ul><p><strong>字段类Field常用方法：</strong></p><p><strong>获取字段信息</strong>：</p><ul><li><strong>getName()：</strong>返回字段的名称。</li><li><strong>getType()：</strong>返回字段的类型。</li><li><strong>getModifiers()：</strong>返回字段的修饰符。</li><li><strong>getDeclaringClass()：</strong>返回声明该字段的类的 Class 对象。</li></ul><p><strong>获取和设置字段值</strong>：</p><ul><li><strong>get(Object obj)：</strong>返回指定对象上此字段的值。</li><li><strong>getBoolean(Object obj)：</strong>返回指定对象上此字段的值（如果字段类型是 boolean）。</li><li>getByte(Object obj)：返回指定对象上此字段的值（如果字段类型是 byte）。</li><li>getChar(Object obj)：返回指定对象上此字段的值（如果字段类型是 char）。</li><li>getDouble(Object obj)：返回指定对象上此字段的值（如果字段类型是 double）。</li><li>getFloat(Object obj)：返回指定对象上此字段的值（如果字段类型是 float）。</li><li>getInt(Object obj)：返回指定对象上此字段的值（如果字段类型是 int）。</li><li>getLong(Object obj)：返回指定对象上此字段的值（如果字段类型是 long）。</li><li>getShort(Object obj)：返回指定对象上此字段的值（如果字段类型是 short）。</li><li><strong>set(Object obj, Object value)：</strong>设置指定对象上此字段的值。注意私有字段默认不允许赋值，要赋值必须给私有字段setAccessible(true)。</li><li><strong>setBoolean(Object obj, boolean value)：</strong>设置指定对象上此字段的值（如果字段类型是 boolean）。</li><li>setByte(Object obj, byte value)：设置指定对象上此字段的值（如果字段类型是 byte）。</li><li>setChar(Object obj, char value)：设置指定对象上此字段的值（如果字段类型是 char）。</li><li>setDouble(Object obj, double value)：设置指定对象上此字段的值（如果字段类型是 double）。</li><li>setFloat(Object obj, float value)：设置指定对象上此字段的值（如果字段类型是 float）。</li><li>setInt(Object obj, int value)：设置指定对象上此字段的值（如果字段类型是 int）。</li><li>setLong(Object obj, long value)：设置指定对象上此字段的值（如果字段类型是 long）。</li><li>setShort(Object obj, short value)：设置指定对象上此字段的值（如果字段类型是 short）。</li></ul><p><strong>其他方法</strong>：</p><ul><li><strong>isAccessible()：</strong>返回字段是否可访问。</li><li><strong>setAccessible(boolean flag)：</strong>设置字段的可访问性。通过这个方法可以让私有字段也可以赋值。</li><li>oGenericString()：返回字段的描述，包括泛型信息。</li><li>getAnnotatedType()：返回此字段的带注释的类型。</li><li>getAnnotations()：返回字段的所有注解。</li><li><strong>getAnnotation(Class<T> annotationClass)：</strong>返回字段的指定类型的注解，如果该注解不存在，则返回 null。例如Spring源码中依赖注入这一块，就是基于反射获取类中字段有没有@Resource、@Component等注解，有的话就是要注入Bean.</li><li>getDeclaredAnnotations()：返回直接存在于此字段上的所有注解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量对象并赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 1.获取Class对象，并实例化</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; dogClass = Dog.class;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> dogClass.newInstance();</span><br><span class="line">        <span class="comment">// 2.获取字段对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">weightField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;weight&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.给字段对象赋值</span></span><br><span class="line">        nameField.set(dog, <span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">        <span class="comment">// 注意私有字段默认不允许赋值，要赋值必须给私有字段设置可访问</span></span><br><span class="line">        weightField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        weightField.set(dog, <span class="number">10</span>);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Field获取的Class类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dogClass=Dog.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">weightField</span> <span class="operator">=</span> dogClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; dogClassByField = weightField.getDeclaringClass();</span><br><span class="line">        <span class="comment">// 通过字段获取到的class对象和源class对象是地址是一样的，事实上一个类的所有Class对象都是一个实例</span></span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">        System.out.println(dogClassByField==dogClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取普通方法"><a href="#反射获取普通方法" class="headerlink" title="反射获取普通方法"></a>反射获取普通方法</h3><p>Class对象获取成员方法的方法： </p><ul><li><p><strong>getMethod(String name, Class&lt;?&gt;… parameterTypes)：</strong>返回指定名称和参数类型的公共方法。返回值是<strong>方法类Method。</strong></p></li><li><p><strong>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)：</strong>返回指定名称和参数类型的方法（包括私有方法）。</p></li><li><p><strong>getMethods()：</strong>返回所有公共方法（包括从父类<strong>继承的方法</strong>）。</p></li><li><p><strong>getDeclaredMethods()：</strong>返回所有方法（包括<strong>私有方法</strong>）。</p></li><li><p><strong>Method类的方法：</strong></p><ul><li><strong>获取方法信息</strong>：<ul><li>getName()：返回方法的名称。</li><li>getReturnType()：返回方法的返回类型。</li><li>getParameterTypes()：返回方法参数类型的数组。</li><li>getModifiers()：返回方法的修饰符。</li><li>getDeclaringClass()：返回声明此方法的类的 Class 对象。</li></ul></li></ul></li><li><p><strong>调用方法</strong>：</p><ul><li><strong>Object invoke(Object obj, Object… args)：</strong>调用指定对象上此 Method 对象表示的基础方法。</li></ul></li><li><p><strong>其他方法</strong>：</p><ul><li><strong>isAccessible()：</strong>返回方法是否可访问。</li><li><strong>setAccessible(boolean flag)：</strong>设置方法的可访问性。</li><li><strong>getAnnotations()：</strong>返回此方法的所有注解。例如Spring源码中通过此方法判断一个类中</li><li>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)：判断此方法是否被指定的注解类型注释。</li><li>getAnnotation(Class<T> annotationClass)：返回该方法的指定类型的注解。</li><li>getExceptionTypes()：返回此方法抛出的异常类型的数组。</li><li>toGenericString()：返回方法的描述，包括泛型信息。</li></ul></li></ul><p><strong>获取成员变量对象并调用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取构造方法对象并实例化</span></span><br><span class="line">Class&lt;?&gt; c= Class.forName(<span class="string">&quot;train.Dog&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con=c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="comment">// 2.获取成员方法对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line"><span class="comment">// 3.通过成员方法对象的invoke方法，调用构造方法对象的成员方法</span></span><br><span class="line"><span class="comment">// 无参无返回值方法</span></span><br><span class="line">eat.invoke(obj);</span><br><span class="line"><span class="comment">// 带参有返回值方法</span></span><br><span class="line">Object sucess= eat.invoke(obj,<span class="string">&quot;food&quot;</span>);</span><br><span class="line">System.out.println((<span class="type">boolean</span>)sucess);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Java 多线程环境中，锁是&lt;strong&gt;确保共享资源线程安全&lt;/strong&gt;的重要手段。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://blog.csdn.net/qq_45675973/article/details/147740830&quot;&gt;Java锁</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用多线程解决问题</title>
    <link href="https://southernfish.github.io/2025/07/24/java/java-base-8-thread-impl/"/>
    <id>https://southernfish.github.io/2025/07/24/java/java-base-8-thread-impl/</id>
    <published>2025-07-24T01:25:36.000Z</published>
    <updated>2025-07-23T14:13:51.314Z</updated>
    
    <content type="html"><![CDATA[<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同<a href="https://baike.baidu.com/item/%E4%B8%80%E6%97%B6%E9%97%B4/3618565?fromModule=lemma_inlink">一时间</a>执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括<a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/10375153?fromModule=lemma_inlink">对称多处理机</a>、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A0%B8%E5%BF%83/1013410?fromModule=lemma_inlink">多核心</a>处理器以及<a href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87%E7%BA%A7%E5%A4%9A%E5%A4%84%E7%90%86/924724?fromModule=lemma_inlink">芯片级多处理</a>或<a href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B/22689341?fromModule=lemma_inlink">同时多线程</a>处理器。在一个程序中，这些独立运行的程序片段叫作“<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fromModule=lemma_inlink">线程</a>”（Thread），利用它编程的概念就叫作“多线程处理” 。本文简单记录一些关于线程、多线程的问题。本文记录了关于一些常见多线程业务问题处理。</p><h2 id="多线程问题-1"><a href="#多线程问题-1" class="headerlink" title="多线程问题 1"></a>多线程问题 1</h2><p><strong>问题：</strong>100个线程并发向1个银行账户中存入1元钱,并在全部完成后，打印银行账户的金额。</p><p><strong>思路：</strong>创建100个线程（<code>线程池</code>）；保证线程安全，同一时刻只有一个线程对账户进行操作（<code>Lock</code> 或者 <code>synchronized</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种加锁 synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance + money;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种锁 lock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        reentrantLock.lock;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newBalance = balance + money;</span><br><span class="line">            balance = newBalance;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">          reentrantLock.unlock();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存钱的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSaveAccount</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TheadSaveAccount</span><span class="params">(Account account, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁 整个账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            account.deposit(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSave</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.execute( <span class="keyword">new</span> <span class="title class_">TheadSaveAccount</span>(account, <span class="number">1</span>) );</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (service.isTerminated()) &#123;</span><br><span class="line">            System.out.println(account.getBalance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多线程是并行化的一种形式，或者是拆分工作以便同时进行处理。线程化的程序将工作拆分到多个软件线程，而不是将大量工作交给单个内核。这些线程由不同的 CPU 内核并行处理，以节省时间。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://southernfish.github.io/2025/07/24/java/java-base-8-thread/"/>
    <id>https://southernfish.github.io/2025/07/24/java/java-base-8-thread/</id>
    <published>2025-07-24T00:28:36.000Z</published>
    <updated>2025-07-23T14:13:38.082Z</updated>
    
    <content type="html"><![CDATA[<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同<a href="https://baike.baidu.com/item/%E4%B8%80%E6%97%B6%E9%97%B4/3618565?fromModule=lemma_inlink">一时间</a>执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括<a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/10375153?fromModule=lemma_inlink">对称多处理机</a>、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A0%B8%E5%BF%83/1013410?fromModule=lemma_inlink">多核心</a>处理器以及<a href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87%E7%BA%A7%E5%A4%9A%E5%A4%84%E7%90%86/924724?fromModule=lemma_inlink">芯片级多处理</a>或<a href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B/22689341?fromModule=lemma_inlink">同时多线程</a>处理器。在一个程序中，这些独立运行的程序片段叫作“<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fromModule=lemma_inlink">线程</a>”（Thread），利用它编程的概念就叫作“多线程处理” 。本文简单记录一些关于线程、多线程的问题。参考文章：<a href="https://blog.csdn.net/qq_46154326/article/details/148100902">多线程下如何保证事务的一致性</a>、<a href="https://blog.csdn.net/m0_53157173/article/details/127423286">Spring在多线程环境下如何确保事务一致性</a>、<a href="https://www.51cto.com/article/768896.html">详解Spring多线程下如何保证事务的一致性</a>、参考链接：<a href="https://blog.csdn.net/qq_40991313/article/details/140324927">https://blog.csdn.net/qq_40991313/article/details/140324927</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><p>并行：多个处理器或多核处理器同时处理多个任务。<br>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</p><h2 id="线程和进程的关系"><a href="#线程和进程的关系" class="headerlink" title="线程和进程的关系"></a>线程和进程的关系</h2><p><strong>进程</strong>：是操作系统分配资源的基本单位，有独立的地址空间（内存空间的一部分，用于存储进程中的代码、数据和堆栈等信息）和内存空间，进程之间不能共享资源，上下文切换慢，并发低，能独立执行（有程序入口、执行序列、出口），更健壮（因为进程崩溃后不会影响其他进程）。</p><p><strong>线程</strong>：是操作系统调度的基本单位，没有独立的地址空间和内存空间（只有自己的堆栈和局部变量，只能共享所在进程的内存空间），线程之间可以共享进程内的资源，上下文切换快，并发高，不能独立执行（应用程序控制多线程执行，进程通过管理线程优先级间接控制线程执行），不健壮（因为一个线程崩溃会导致整个进程崩溃）。</p><p><strong>关系</strong>：一个程序运行后至少包括一个进程，一个进程至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><blockquote><p>运行时数据区包括本地方法栈、虚拟机栈、方法区、堆、程序计数器。每个线程都有独自的本地方法栈、虚拟机栈、程序计数器。各线程共享进程的方法区和堆。</p><p><strong>JVM运行时数据区参考：</strong><a href="https://blog.csdn.net/qq_40991313/article/details/134742377?spm=1001.2014.3001.5501">什么是JVM的内存模型？详细阐述Java中局部变量、常量、类名等信息在JVM中的存储位置_jvm中主要用于存储类的元数据(类型信息(类的描述信息 类的元数据))、静态变量、常-CSDN博客</a></p></blockquote><h2 id="线程状态（state）"><a href="#线程状态（state）" class="headerlink" title="线程状态（state）"></a>线程状态（state）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW 线程创建但尚未启动</span><br><span class="line">RUNNABLE 就绪或者正在执行中</span><br><span class="line">BLOCKED 阻塞的（被同步锁或者IO锁阻塞），等待获取锁</span><br><span class="line">WAITING 永久等待状态，等待其他线程唤醒（如wait()）</span><br><span class="line">TIMED_WAITING 等待指定的时间重新被唤醒的状态，定时等待（如sleep(long)）</span><br><span class="line">TERMINATED 线程执行完成</span><br></pre></td></tr></table></figure><h2 id="守护线程（Daemon-Thread）"><a href="#守护线程（Daemon-Thread）" class="headerlink" title="守护线程（Daemon Thread）"></a>守护线程（Daemon Thread）</h2><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><ul><li><strong>作用</strong>：为其他线程提供服务（如垃圾回收线程）</li><li><strong>特性</strong>：当所有非守护线程结束时，守护线程自动终止。</li><li><strong>设置</strong>：thread.setDaemon(true)必须在start()前调用</li></ul><h2 id="中断（Interruption）"><a href="#中断（Interruption）" class="headerlink" title="中断（Interruption）"></a>中断（Interruption）</h2><ul><li><p><strong>作用</strong>：通知线程应该终止，但线程可选择忽略。</p></li><li><p><strong>方法</strong>：</p><ul><li><p><code>thread.interrupt()</code>：中断线程。</p></li><li><p><code>Thread.interrupted()</code>：检查并清除中断状态。 </p></li><li><p><code>thread.isInterrupted()</code>：检查中断状态。</p></li></ul></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一个程序运行后至少包括一个进程，一个进程至少有一个线程，一个进程下有多个线程并发地处理任务，称为多线程。</p><p><strong>多线程的好处：</strong>当一个线程进入阻塞或者等待状态时，其他的线程可以获取CPU的执行权，提高了CPU的利用率。</p><p><strong>多线程的缺点：</strong></p><ul><li><strong>死锁</strong>：多个进程或线程相互等待对方释放所持有的资源，从而无法继续执行的情况。若无外力作用，它们都将无法推进下去。死锁用占用CPU、内存等系统资源，导致资源浪费，死锁会导致程序无法正常退出，导致系统性能差。</li><li><strong>上下文频繁切换</strong>：频繁的上下文切换可能会造成资源的浪费；</li><li><strong>串行</strong>：如果因为资源的限制，多线程串行执行，可能速度会比单线程更慢。</li></ul><p> <strong>线程的优先级</strong>：java是抢占式调度模型，每一个 Java 线程都有一个优先级，优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><blockquote><p><strong>注意</strong>：优先级高的线程只是获取CPU时间片的几率高，但并不能保证先执行。</p></blockquote><h2 id="ThreadLocal-及使用场景"><a href="#ThreadLocal-及使用场景" class="headerlink" title="ThreadLocal 及使用场景"></a>ThreadLocal 及使用场景</h2><p><code>ThreadLocal</code> 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><p><code>TransactionSynchronizationManager</code>类内部默认提供了下面六个ThreadLocal属性，分别保存当前线程对应的不同事务资源:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前事务关联的资源</span></span><br><span class="line"><span class="comment">// 默认只会在新建事务的时候保存当前获取到的DataSource和当前事务对应Connection的映射关系</span></span><br><span class="line"><span class="comment">// 这里Connection被包装为了ConnectionHolder</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"><span class="comment">// 事务监听者</span></span><br><span class="line"><span class="comment">// 在事务执行到某个阶段的过程中，会去回调监听者对应的回调接口(典型观察者模式的应用)</span></span><br><span class="line"><span class="comment">// 默认为空集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Transaction synchronizations&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务名字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Current transaction name&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务是否是只读事务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Current transaction read-only status&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务的隔离级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Current transaction isolation level&quot;</span>);</span><br><span class="line"><span class="comment">// 存放当前事务是否处于激活状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Actual transaction active&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="需要多线程的业务场景"><a href="#需要多线程的业务场景" class="headerlink" title="需要多线程的业务场景"></a>需要多线程的业务场景</h2><table><thead><tr><th align="center"></th><th>场景</th><th>实现</th><th>优势或示例</th></tr></thead><tbody><tr><td align="center">高并发Web服务器</td><td>处理大量HTTP请求，每个请求独立处理</td><td>使用线程池处理请求，避免频繁创建线程</td><td>示例：Tomcat、Netty等服务器的线程模型。</td></tr><tr><td align="center">批处理任务</td><td>批量处理大量数据（如ETL作业）</td><td>将数据分片，每个线程处理一部分数据</td><td><strong>优势</strong>：显著提高处理速度</td></tr><tr><td align="center">异步IO操作</td><td>文件读写、网络通信等IO密集型操作</td><td>使用异步线程执行IO操作，主线程继续处理其他任务</td><td>示例：数据库查询、HTTP请求调用</td></tr><tr><td align="center">定时任务调度</td><td>定期执行任务（如数据备份、统计报表生成）</td><td>使用<code>ScheduledExecutorService</code>或Spring的<code>@Scheduled</code>注解</td><td>示例：每天凌晨执行数据同步任务</td></tr><tr><td align="center">实时数据处理</td><td>实时分析数据流（如日志分析、监控数据处理）</td><td>使用多线程并行处理数据流</td><td>示例：电商平台实时计算商品销量排行</td></tr><tr><td align="center">图形界面应用</td><td>保持UI响应性的同时执行耗时操作</td><td>将耗时操作放在后台线程执行</td><td>示例：文件下载进度显示、复杂计算</td></tr><tr><td align="center">分布式缓存更新</td><td>缓存失效时，异步更新缓存数据</td><td>使用后台线程重新加载数据到缓存</td><td><strong>优势</strong>：避免用户请求等待缓存更新</td></tr><tr><td align="center">消息队列消费者</td><td>从消息队列（如Kafka、RabbitMQ）消费消息</td><td>多线程并行消费，提高吞吐量</td><td>示例：订单处理、日志收集</td></tr><tr><td align="center">搜索引擎索引构建</td><td>构建大规模索引（如Elasticsearch索引）</td><td>多线程并行处理文档，加速索引构建</td><td><strong>优势</strong>：缩短索引构建时间，提高搜索服务可用性</td></tr><tr><td align="center">游戏服务器</td><td>处理多个玩家的并发操作</td><td>每个玩家会话由独立线程处理</td><td>示例：多人在线游戏的服务器端逻辑</td></tr></tbody></table><hr><h1 id="创建线程方法"><a href="#创建线程方法" class="headerlink" title="创建线程方法"></a>创建线程方法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>创建线程有4种方式：</p><ul><li> <strong>继承Thread类：</strong>继承Thread类，重写run()方法；然后创建线程对象调用start()方法开启线程。start()方法里包括了run()方法，用于开启线程。注意如果直接调用run()方法的话，将是普通方法调用，无法起到开启线程的效果</li><li><strong>实现Runnable接口：</strong>实现Runnable接口并重写run()方法，将实现类作为构造参数创建Thread对象。推荐，因为Java是单继承，线程类实现接口的同时，还可以继承其他类实现其他接口。</li><li><strong>实现Callable：</strong>实现Callable<T>接口，重写带返回值的call()方法；将实现类对象作为构造参数创建FutureTask<T>对象；将FutureTask对象作为构造参数创建Thread对象。所以此方法可以获取线程执行完后的返回值，而前两种方式不能。</li><li><strong>ExecutorService的submit或execute方法：</strong>execute和submit都是ExecutorService接口的方法，用于线程池提交任务。所有线程池都直接或间接实现ExecutorService接口。<ul><li><strong>execute：</strong>参数只能是Runnable，没有返回值</li><li><strong>submit：</strong>参数可以是Runnable、Callable，返回值是FutureTask</li></ul></li></ul><h2 id="方法1：继承Thread类"><a href="#方法1：继承Thread类" class="headerlink" title="方法1：继承Thread类"></a>方法1：继承Thread类</h2><p><strong>创建并启动线程的步骤：</strong> </p><ol><li>创建一个继承了 Thread类的线程类，重写的run()方法是线程执行体。</li><li>创建这个类的对象。</li><li>调用线程对象的start()方法来启动该线程（之后Java虚拟机会调用该线程run方法）。</li></ol><p><strong>run()和start()区别：</strong></p><ul><li><strong>run()：</strong>封装线程执行的代码，直接调用相当于普通方法的调用。</li><li><strong>start()：</strong>启动线程，虚拟机<strong>调用</strong>该线程的**run()**方法。</li></ul><p><strong>构造方法：</strong></p><ul><li><strong>Thread():</strong> 创建一个新的线程对象。</li><li><strong>Thread(String name):</strong> 创建一个新的线程对象并将其名称设置为指定的名称。</li><li><strong>Thread(Runnable target):</strong> 创建一个新的线程对象并将其目标设置为指定的 Runnable 对象。主要用于后面通过Runable接口创建线程。</li><li><strong>Thread(Runnable target, String name):</strong> 创建一个新的线程对象，将其目标设置为指定的 Runnable 对象，并将其名称设置为指定的名称。</li></ul><p><strong>常用方法：</strong></p><ul><li><strong>void start():</strong> 使线程开始执行；Java 虚拟机调用此线程的 run 方法。</li><li><strong>void run():</strong> 如果此线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，此方法不执行任何操作并返回。</li><li>**void join():**等待该线程执行完成。A线程调用B线程的join()方法，A线程将被阻塞，直到B线程执行完。可以用于线程之间的通信。</li><li>void join(long millis): 等待该线程终止的时间最长为 millis 毫秒。</li><li>void join(long millis, int nanos): 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。</li><li><strong>void interrupt():</strong> 中断该线程。</li><li>boolean isInterrupted(): 测试当前线程是否已中断。</li><li><strong>boolean isAlive():</strong> 测试线程是否处于活动状态。</li><li><strong>static void sleep(long millis):</strong> 使当前正在执行的线程休眠（暂停执行）指定的毫秒数。</li><li>static void sleep(long millis, int nanos): 使当前正在执行的线程休眠（暂停执行）指定的毫秒数加指定的纳秒数。</li></ul><p><strong>属性方法：</strong></p><ul><li><strong>void setName(String name):</strong> 改变线程名称，使之与参数 name 相同。</li><li><strong>String getName():</strong> 返回该线程的名称。</li><li><strong>void setPriority(int newPriority):</strong> 更改该线程的优先级。</li><li><strong>int getPriority():</strong> 返回该线程的优先级。</li><li><strong>Thread.State getState():</strong> 返回该线程的状态。</li><li><strong>void setDaemon(boolean on):</strong> 将该线程标记为守护线程或用户线程。</li><li><strong>boolean isDaemon():</strong> 测试该线程是否为守护线程。用户线程是普通的线程，它们通常是应用程序执行任务的主要线程。守护线程为其他线程提供后台支持。当所有用户线程结束时，JVM 会自动退出，无论守护线程是否仍在运行。</li></ul><p><strong>代码示例</strong>：<strong>继承 Thread 重写 run 方法：</strong>代码简单，但该类无法集成别的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.主线程设置名字并查看</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建并启动线程</span></span><br><span class="line"><span class="comment">// 线程类：打印数字线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumberThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 打印1-100</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造方法 @param name 线程名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintNumberThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建并启动线程 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumberThread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumberThread</span> (<span class="string">&quot;a&quot;</span>), b = <span class="keyword">new</span> <span class="title class_">PrintNumberThread</span> (<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 两个线程是随机交替打印的，因为它们获取CPU的调度是随机的</span></span><br></pre></td></tr></table></figure><h2 id="方法2：实现-Runnable-接口"><a href="#方法2：实现-Runnable-接口" class="headerlink" title="方法2：实现 Runnable 接口"></a>方法2：实现 Runnable 接口</h2><p><strong>步骤：</strong> </p><ol><li>定义Runnable接口的实现类，并实现该接口的run()方法，该方法将作为线程执行体。</li><li>创建Runnable实现类的实例，并将其作为参数来创建Thread对象，Thread对象为线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ol><p><strong>这种办法更好，优点：</strong></p><ul><li><strong>避免Java 单继承局限性：</strong>Java是单继承，使用这种方法，线程类实现接口的同时，还可以继承其他类、实现其他接口。</li><li><strong>逻辑和数据更好分离：</strong>通过实现 Runnable 接口的方法创建多线程更加适合<strong>同一个资源被多段业务逻辑并行处理</strong>的场景。在同一个资源被多个线程逻辑异步、并行处理的场景中，通过实现 Runnable 接口的方式设计多个 target 执行目标类可以更加方便、清晰地将执行逻辑和数据存储分离，更好地体现了面向对象的设计思想。</li></ul><p><strong>代码示例</strong>：<strong>实现 Runnable 接口：</strong>继承其他类；同一实现该接口的实例可以共享资源。但代码复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码实践</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印数字Runnable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumberRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法1：使用普通方式实现Runnable接口</span></span><br><span class="line">        <span class="type">PrintNumberRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumberRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;a&quot;</span>), b = <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法2：使用Lambda表达式实现Runnable接口，无需再创建PrintNumberRunnable类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        d.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法3：实现-Callable接口"><a href="#方法3：实现-Callable接口" class="headerlink" title="方法3：实现 Callable接口"></a>方法3：实现 Callable接口</h2><p>通过<strong>实现Callable接口</strong>来创建线程的步骤如下</p><ul><li>实现Callable<T>接口，重写带返回值的call()方法；</li><li>将实现类对象作为构造参数创建FutureTask<T>对象；</li><li>将FutureTask对象作为构造参数创建Thread对象。</li></ul><p>相比于前两种方法，此方法可以<strong>获取线程执行完后的返回值</strong>，而前两种方式不能，因为call()方法是有返回值的。 </p><p><strong>代码示例</strong>：<strong>实现 Callable 接口：</strong>可以获得异步任务的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br></pre></td></tr></table></figure><p><strong>代码实践</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;执行结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法4：线程池"><a href="#方法4：线程池" class="headerlink" title="方法4：线程池"></a>方法4：线程池</h2><p>线程池（Thread Pool）是一种多线程处理方式，用于减少创建和销毁线程的开销，提高系统资源利用率和处理效率。</p><p><strong>线程池作用：</strong> </p><ul><li><strong>管理线程数量：</strong>它可以管理线程的数量，可以避免无节制的创建线程，导致超出系统负荷直至崩溃。</li><li><strong>让线程复用：</strong>它还可以让线程复用，可以大大地减少创建和销毁线程所带来的开销。</li></ul><p><strong>线程池的两种创建方法：</strong></p><ul><li>执行器工具类Executors；</li><li>自定义线程池ThreadPoolExecutor </li></ul><p><strong>线程池两种提交任务的方法</strong>：</p><p>execute和submit都是ExecutorService接口的方法，用于线程池提交任务。所有线程池都直接或间接实现ExecutorService接口。</p><ul><li><strong>execute</strong>：参数只能是Runnable，没有返回值</li><li><strong>submit</strong>：参数可以是Runnable、Callable，返回值是FutureTask </li></ul><p><strong>代码示例</strong>：<strong>两种创建线程池的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池工具类，创建固定大小的线程池：</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程&quot;</span>+Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 自定义线程池:实现自动化装配，易于管理，循环利用资源。</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>( </span><br><span class="line">    <span class="number">5</span>,                                        <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="number">200</span>,                                    <span class="comment">// 最大线程数量，控制资源并发</span></span><br><span class="line">    <span class="number">10</span>,                                        <span class="comment">// 存活时间</span></span><br><span class="line">    TimeUnit.SECONDS,                        <span class="comment">// 时间单位</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(  <span class="number">100000</span>),    <span class="comment">// 任务队列，大小100000个</span></span><br><span class="line">Executors.defaultThreadFactory(),            <span class="comment">// 线程的创建工厂</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        <span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="comment">// 任务1</span></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--helloWorld_001--&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参数作用 ：</p><ul><li><code>corePoolSize</code>：线程池的基本大小，当<strong>提交的任务数小于此值时，直接创建新线程</strong>执行任务。 </li><li><code>maximumPoolSize</code>：线程池允许的最大线程数，当<strong>任务队列满且线程数小于此值时，会创建新线程</strong>。 </li><li><code>keepAliveTime</code>：当<strong>线程数大于核心线程数</strong>时，多余的<strong>空闲线程在终止前等待新任务的最长时间</strong>。 </li><li><code>workQueue</code>：用于<strong>保存等待执行的任务的阻塞队列</strong>，常见类型有： <ul><li><code>ArrayBlockingQueue</code>：有界队列</li><li><code>LinkedBlockingQueue</code>：无界队列（需注意<code>OOM</code>风险） </li><li><code>SynchronousQueue</code>：直接提交队列   </li></ul></li><li><code>threadFactory</code>：创建线程的工厂，可自定义线程名称、优先级等。 </li><li><code>handler</code>：当<strong>任务队列和线程池都满时的拒绝策略</strong>，默认有四种： <ul><li><code>AbortPolicy</code>：直接抛出异常（默认）</li><li><code>CallerRunsPolicy</code>：由调用线程处理任务</li><li><code>DiscardPolicy</code>：丢弃最新的任务</li><li><code>DiscardOldestPolicy</code>：丢弃最老的任务</li></ul></li></ul><hr><h1 id="知识加油站"><a href="#知识加油站" class="headerlink" title="知识加油站"></a>知识加油站</h1><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>Java线程在运行的生命周期中,在任意给定的时刻,只能处于下列6种状态之一：</p><ul><li><strong>NEW ：初始状态</strong>，线程被创建，但是还没有调用start方法。</li><li><strong>RUNNABLE：可运行状态</strong>，等待调度或运行。线程正在JVM中执行，但是有可能在等待操作系统的调度。</li><li><strong>BLOCKED ：阻塞状态</strong>，线程正在等待获取监视器锁。</li><li><strong>WAITING ：等待状态</strong>，线程正在等待其他线程的通知或中断。线程等待状态不占用 CPU 资源，被唤醒后进入可运行状态（等待调度或运行）。</li><li><strong>TIMED_WAITING：超时等待状态</strong>，在WAITING的基础上增加了超时时间，即超出时间自动返回。<code>Thread.sleep(1000);</code>让线程超时等待1s。</li><li><strong>TERMINATED：终止状态</strong>，线程已经执行完毕。</li></ul><p><strong>线程的运行过程：</strong></p><p>线程在创建之后默认为NEW（初始状态），在调用start方法之后进入RUNNABLE（可运行状态）。</p><blockquote><p><strong>注意：</strong>可运行状态不代表线程正在运行，它有可能正在等待操作系统的调度。</p></blockquote><p>WAITING （等待状态）的线程需要其他线程的通知才能返回到可运行状态，而TIMED_WAITING（超时等待状态）相当于在等待状态的基础上增加了超时限制，除了他线程的唤醒，在超时时间到达时也会返回运行状态。</p><p>此外，线程在执行同步方法时，在没有获取到锁的情况下，会进入到BLOCKED（阻塞状态）。线程在执行完run方法之后，会进入到TERMINATED（终止状态）。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250723122520457.png" alt="image-20250723122520457"></p><blockquote><p> <strong>等待状态如何被唤醒</strong></p><p> Object类：</p><ul><li>wait()方法让线程进入等待状态</li><li>notify()唤醒该对象上的随机一个线程</li><li>notifyAll()唤醒该对象上的所有线程。</li></ul><p> 这3个方法必须处于<strong>synchronized</strong>代码块或方法中，否则会抛出<code>IllegalMonitorStateException</code>异常。因为调用这三个方法之前必须拿要到当前锁对象的监视器（Monitor对象），synchronized基于对象头和Monitor对象。</p><p> 另外，也可以通过<strong>Condition类的 await/signal/signalAll</strong>方法实现线程的等待和唤醒，从而实现线程的通信，令线程之间协作处理任务。这两个方法依赖于Lock对象。</p><p> <strong>notify() 和 notifyAll() 的区别</strong></p><p> <code>notifyAll()</code>会唤醒所有的线程，<code>notify()</code>之后唤醒一个线程。<br> notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 <code>notify()</code>只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><p> <strong>sleep() 和 wait() 的区别</strong></p><ul><li><strong>类的不同：</strong>sleep() 来自 Thread，wait() 来自 Object。</li><li><strong>释放锁：</strong>sleep() 不释放锁；wait() 释放锁。</li><li><strong>用法不同：</strong>sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll() 直接唤醒。</li></ul></blockquote><h2 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a>线程的通信方式</h2><p><strong>线程通信：</strong>用于多个线程之间协作工作，共同完成某个任务<strong>。</strong>多个线程在并发执行的时候，他们在CPU中是随机切换执行的，想多个线程一起来完成一件任务，就需要线程之间的通信。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250723122705785.png" alt="image-20250723122705785"></p><p><strong>线程通信方式：</strong> </p><ul><li><strong>通过 volatile 关键字：</strong>多个线程同时监听一个volatile变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。利用了volatile可见性，即一旦修改变量则立即刷新到共享内存中。</li><li><strong>通过Object类的 wait/notify/notifyAll 方法：</strong>当我们使用synchronized同步时就会使用Monitor来实现线程通信，这里的Monitor其实就是锁对象，其利用Object类的wait，notify，notifyAll等方法来实现线程通信。Monitor是Java虚拟机实现锁的一种底层机制，用于控制线程对共享资源的访问。</li><li><strong>通过Condition类的 await/signal 方法：</strong>而使用Lock进行同步时就是使用Condition对象来实现线程通信，Condition对象通过Lock的lock.newCondition()方法创建，使用其await，sign或signAll方法实现线程通信。Condition 是一个与锁 Lock 相关联的条件对象，可以让等待线程在某个条件被满足时被唤醒，从而达到线程协作的目的。</li><li><strong>通过Semaphore的acquire/release方法：</strong> Semaphore是一个计数信号量，用于控制同时访问某个资源的线程数量。线程可以通过acquire()方法获取许可，release()方法释放许可。</li><li><strong>通过Thread类的join()方法：</strong>join() 方法等待该线程执行完成。A线程调用B线程的join()方法，A线程将被阻塞，直到B线程执行完。</li></ul><p><strong>应用场景：</strong></p><ul><li><p><strong>线程交替打印：</strong>在多线程交替打印A/B、或者交替打印1到100时，需要在锁中使用线程通信。如果不使用lock.notify()和lock.wait()，可能导致当前线程释放锁后立刻又拿回锁（因为多线程是CPU随机切换的），从而达不到交替打印的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个线程，例如打印A</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 1.临界值校验：到临界值唤醒其他线程，防止其他线程永远等待；</span></span><br><span class="line">                    <span class="comment">// 2.打印判断：如果需要打印，则打印、操作原子类。 </span></span><br><span class="line">                        <span class="comment">// 如果用的当前行值原子类，则加1；如果用的总行数原子类，则减1</span></span><br><span class="line">                    <span class="comment">// 4.线程通信：唤醒、等待。</span></span><br><span class="line">                    <span class="comment">// 如果删除下面两行代码，可能导致当前线程释放锁后立刻又拿到锁了，从而达不到交替打印的效果</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span>-<span class="keyword">catch</span>&#123; lock.wait(); &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).start();</span><br><span class="line"><span class="comment">//另一个线程，例如打印B...</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>为了对多线程进行统一的管理，Java引入了线程池，它通过限制并发线程的数量、将待执行的线程放入队列、销毁空闲线程，来控制资源消耗，使线程更合理地运行，避免系统因为创建过多线程而崩溃。</p><p><strong>线程池作用：</strong> </p><ul><li><strong>管理线程数量：</strong>它可管理线程的数量，可避免无节制的销毁、创建线程，导致额外的性能损耗、或线程数超出系统负荷直至崩溃。</li><li><strong>提高性能：</strong>当有新任务到来时，可直接从线程池中取出一个空闲线程来执行任务，而不需要等待创建新线程，从而减少了响应时间。</li><li><strong>让线程复用：</strong>它还可以让线程复用，可以大大地减少创建和销毁线程所带来的开销。</li><li><strong>合理的拒绝策略</strong>：线程池提供了多种拒绝策略，当线程池队列满了时，可采用不同的策略进行处理，如抛出异常、丢弃任务或调用者运行等。</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>通常线程池的生命周期包含5个状态，对应状态值分别是：-1、0、1、2、3，这些状态只能由小到大迁移，不可逆。</p><ol><li><strong>RUNNING：运行。</strong>线程池处于正常状态，可以接受新的任务，同时会按照预设的策略来处理已有任务的执行。</li><li><strong>SHUTDOWN：关闭。</strong>线程池处于关闭状态，不再接受新的任务，但是会<strong>继续执行</strong>已有任务直到执行完成。执行线程池对象的shutdown()时进入该状态。</li><li><strong>STOP：停止。</strong>线程池处于关闭状态，不再接受新的任务，同时会<strong>中断</strong>正在执行的任务，<strong>清空</strong>线程队列。执行shutdownNow()时进入该状态。</li><li><strong>TIDYING：整理。</strong>所有任务已经执行完毕，线程池进入该状态会开始进行一些结尾工作，比如及时清理线程池的一些资源。</li><li><strong>TERMINATED：终止。</strong>线程池已经完全停止，所有的状态都已经结束了，线程池处于最终的状态。</li></ol><h3 id="创建线程池的方式1：线程池工具类"><a href="#创建线程池的方式1：线程池工具类" class="headerlink" title="创建线程池的方式1：线程池工具类"></a>创建线程池的方式1：线程池工具类</h3><p><strong>执行器工具类Executors创建线程池：</strong> 底层都是return new ThreadPoolExecutor(…)。一般不使用这种方式，参数配置死了不可控。</p><ul><li>**newCachedThreadPool()**：缓存线程池（无限大）。一种用来处理大量短时间工作任务的线程池。<ul><li><strong>核心线程数是0，最大线程数无限大：</strong>最大线程数<code>Integer.MAX_VALUE</code>。线程数量可以无限扩大，所有线程都是非核心线程。</li><li><strong>空闲线程存活时间60s：</strong>keepAliveTime为60S，空闲线程超过60s会被杀死。</li><li><strong>同步队列：</strong>因为最大线程数无限大，所以也用不到阻塞队列，所以设为没有存储空间的SynchronousQueue同步队列。它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程。这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</li></ul></li><li><strong>newFixedThreadPool(int nThreads)：固定大小的线程池。</strong>重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。<ul><li><strong>核心线程数：</strong>所有线程都是核心线程（通过构造参数指定），最大线程数=核心线程数。</li><li><strong>存活时间0s：</strong>因为所有线程都是核心线程，所以用不到存活时间，线程都会一直存活。<code>keepAliveTime</code>为0S。</li><li><strong>链表阻塞队列：</strong>超出的线程会在<code>LinkedBlockingQueue</code>队列中等待空闲线程出现。即若有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads</li></ul></li><li><strong>newScheduledThreadPool(int corePoolSize)：定时任务线程池。</strong>创建定长线程池， 支持定时及周期性任务执行。可指定核心线程数，最大线程数。和 <code>newSingleThreadScheduledExecutor()</code> 类似，创建的是个 <code>ScheduledExecutorService</code>，区别在于单一工作线程还是多个工作线程。</li><li><strong>newSingleThreadExecutor()：单线程化的线程池。</strong>核心线程数与最大线程数都只有一个，操作一个无界的工作队列，不回收。后台从<code>LinkedBlockingQueue</code>队列中获取任务。创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务， 保证所有任务按照指定顺序（<code>FIFO, LIFO, 优先级</code>）执行。 </li><li><strong>newWorkStealingPool(int parallelism)：</strong>这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li><li><strong>ThreadPoolExecutor()：</strong>是最原始的线程池创建，上面的创建方式几乎都是对 ThreadPoolExecutor 的封装。（最核心）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line">FixedThredPool: <span class="keyword">new</span> <span class="title class_">ThreadExcutor</span>(n, n, <span class="number">0L</span>, ms, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runable&gt;()</span><br><span class="line">SingleThreadExecutor: <span class="keyword">new</span> <span class="title class_">ThreadExcutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, ms, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runable&gt;())</span><br><span class="line">CachedTheadPool: <span class="keyword">new</span> <span class="title class_">ThreadExcutor</span>(<span class="number">0</span>, max_valuem, <span class="number">60L</span>, s, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">ScheduledThreadPoolExcutor: ScheduledThreadPool, SingleThreadScheduledExecutor.</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>： 一般要搭配计数器<code>CountDownLatch，await(时间)</code>让主线程等待，直到任务线程都执行完（计数器减为零），或者到达超时时间，防止无线等待。</p></blockquote><h3 id="创建线程池的方式2：自定义线程池（推荐）"><a href="#创建线程池的方式2：自定义线程池（推荐）" class="headerlink" title="创建线程池的方式2：自定义线程池（推荐）"></a>创建线程池的方式2：<strong>自定义线程池（推荐）</strong></h3><p><strong>线程池执行器ThreadPoolExecutor创建自定义线程池：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>( </span><br><span class="line">         <span class="number">5</span>,                                        <span class="comment">// 核心线程数</span></span><br><span class="line">         <span class="number">200</span>,                                    <span class="comment">// 最大线程数量，控制资源并发</span></span><br><span class="line">         <span class="number">10</span>,                                    <span class="comment">// 存活时间</span></span><br><span class="line">        TimeUnit.SECONDS,                       <span class="comment">// 时间单位</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(  <span class="number">100000</span>),    <span class="comment">// 任务队列，大小100000个</span></span><br><span class="line">Executors.defaultThreadFactory(),                <span class="comment">// 线程的创建工厂</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());            <span class="comment">// 拒绝策略</span></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="comment">// 开启异步编排，有返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;, threadPoolExecutor).thenApplyAsync(res -&gt; &#123;    <span class="comment">// 串行化，接收参数并有返回值</span></span><br><span class="line">    <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;, threadPoolExecutor);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future.get();    <span class="comment">// 获取返回值</span></span><br></pre></td></tr></table></figure><p><strong>七个参数：</strong></p><ul><li><p><strong>corePoolSize：核心线程数</strong>。创建以后，会一直存活到线程池销毁，空闲时也不销毁。</p></li><li><p><strong>maximumPoolSize：最大线程数量</strong>。阻塞队列满了</p></li><li><p><strong>keepAliveTime： 存活时间</strong>。释放空闲时间超过“存活时间”的线程，仅留核心线程数量的线程。</p></li><li><p><strong>TimeUnitunit：时间单位</strong></p></li><li><p><strong>workQueue： 任务队列。</strong>如果线程数超过核心数量，就把剩余的任务放到队列里。只要有线程空闲，就会去队列取出新的任务执行。new LinkedBlockingDeque()队列大小默认是Integer的最大值，内存不够，所以建议指定队列大小。</p><ul><li><p>SynchronousQueue是一个同步队列，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</p></li><li><p><strong>LinkedBlockingQueue</strong>是一个无界队列，可以缓存无限多的任务。由于其无界特性，因此需要合理地处理好任务的生产速率和线程池中线程的数量，以避免内存溢出等异常问题。无限缓存，拒绝策略就能随意了。</p></li><li><p><strong>ArrayBlockingQueue</strong>是一个有界（容量固定）队列，只能缓存固定数量的任务。通过固定队列容量，可以避免任务过多导致线程阻塞，保证线程池资源的可控性和稳定性。<strong>推荐</strong>，有界队列能增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千，新任务丢弃后未来重新入队。</p></li><li><p>PriorityBlockingQueue是一个优先级队列，能够对任务按照优先级进行排序，当任务数量超过队列容量时，会根据元素的Comparable或Comparator排序规则进行丢弃或抛异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;&gt;((o1, o2) -&gt; o1.length() - o2.length());</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>threadFactory：线程的创建工厂</strong>。可以使用默认的线程工厂Executors.defaultThreadFactory()，也可以自定义线程工厂（实现ThreadFactory接口）</p></li><li><p><strong>RejectedExecutionHandler handler：拒绝策略。</strong>如果任务队列和最大线程数量满了，按照指定的拒绝策略执行任务。</p><ul><li><strong>Abort（默认）：</strong>直接抛异常（拒绝执行异常RejectedExecutionException）</li><li><strong>CallerRuns：</strong>直接同步调用线程run()方法，不创建线程了</li><li><strong>DiscardOldest：</strong>丢弃最老任务</li><li><strong>Discard：</strong>直接丢弃新任务</li><li>实现拒绝执行处理器接口（RejectedExecutionHandler），自定义拒绝策略。</li></ul></li></ul><h3 id="如何为线程池设置合适的线程数"><a href="#如何为线程池设置合适的线程数" class="headerlink" title="如何为线程池设置合适的线程数"></a>如何为线程池设置合适的线程数</h3><p>下面的参数只是一个预估值，适合初步设置，具体的线程数需要经过压测确定，压榨（更好的利用）CPU的性能。</p><p><strong>CPU核心数为N；</strong></p><p><strong>核心线程数：</strong></p><ul><li>CPU密集型：N+1。数量与CPU核数相近是为了不浪费CPU，并防止频繁的上下文切换，加1是为了有线程被阻塞后还能不浪费CPU的算力。</li><li><strong>I/O密集型：</strong>2N，或N/(1-阻塞系数)。I/O密集型任务CPU使用率并不是很高，可以让CPU在等待I/O操作的时去处理别的任务，充分利用CPU，所以数量就比CPU核心数高一倍。</li><li>有些公司会考虑阻塞系数，阻塞系数是任务线程被阻塞的比例，一般是0.8~0.9。</li><li><strong>实际开发中更适合的公式：</strong>N*((线程等待时间+线程计算时间)/线程计算时间)</li></ul><p><strong>最大线程数：</strong>设成核心线程数的2-4倍。数量主要由CPU和IO的密集性、处理的数据量等因素决定。</p><p><strong>需要增加线程的情况：</strong>jstack打印线程快照，如果发现线程池中大部分线程都等待获取任务、则说明线程够用。如果大部分线程都处于运行状态，可以继续适当调高线程数量。</p><p><strong>jstack：</strong>打印指定进程此刻的线程快照。定位线程长时间停顿的原因，例如死锁、等待资源、阻塞。如果有死锁会打印线程的互相占用资源情况。线程快照：该进程内每条线程正在执行的方法堆栈的集合。</p><h3 id="多线程实现的四种方式"><a href="#多线程实现的四种方式" class="headerlink" title="多线程实现的四种方式"></a>多线程实现的四种方式</h3><ol><li><p>继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">ThreadDemo</span> <span class="variable">threadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">         threadDemo.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableDemo</span> <span class="variable">runnableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableDemo).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Callable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">CallableDemo</span> <span class="variable">callableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableDemo</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableDemo); </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        List&lt;Integer&gt; lists = (List&lt;Integer&gt;)futureTask.get(); <span class="comment">//获取返回值</span></span><br><span class="line">        <span class="keyword">for</span> (Integer integer : lists) &#123;</span><br><span class="line">            System.out.print(integer + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;List&lt;Integer&gt;&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        List&lt;Integer&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                lists.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxj.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        List&lt;Future&lt;List&lt;Integer&gt;&gt;&gt; ints = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            Future&lt;List&lt;Integer&gt;&gt; future = executorService.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                    List&lt;Integer&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">3</span> ; i &lt; <span class="number">100</span> ; i ++) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i) ; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                                flag = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                            lists.add(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> lists;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ints.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Future&lt;List&lt;Integer&gt;&gt; future : ints) &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="线程池中-submit-和-execute-方法的区别"><a href="#线程池中-submit-和-execute-方法的区别" class="headerlink" title="线程池中 submit() 和 execute() 方法的区别"></a>线程池中 submit() 和 execute() 方法的区别</h3><p><strong>execute()：</strong>只能执行 Runnable 类型的任务。<br><strong>submit()：</strong>可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><ol><li><p><strong>手动配置线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">createThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">5</span>,                               <span class="comment">// 核心线程数</span></span><br><span class="line">            <span class="number">10</span>,                              <span class="comment">// 最大线程数</span></span><br><span class="line">            <span class="number">60</span>,                              <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),  <span class="comment">// 任务队列大小</span></span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="comment">// 拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Spring Boot自动配置</strong>：在Spring Boot项目中，可通过配置文件设置线程池参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">    <span class="attr">execution:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">core-size:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">queue-capacity:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">keep-alive:</span> <span class="string">60s</span></span><br><span class="line">      <span class="attr">thread-name-prefix:</span> <span class="string">my-task-</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Spring Cloud中的线程池配置</strong>：在微服务架构中，<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%85%8D%E7%BD%AE&spm=1001.2101.3001.7020">线程池配置</a>需考虑服务间调用的特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AsyncConfig &#123;</span><br><span class="line">    @Bean(name = &quot;asyncExecutor&quot;)</span><br><span class="line">    public ThreadPoolTaskExecutor asyncExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(10);</span><br><span class="line">        executor.setMaxPoolSize(50);</span><br><span class="line">        executor.setQueueCapacity(200);</span><br><span class="line">        executor.setKeepAliveSeconds(300);</span><br><span class="line">        executor.setThreadNamePrefix(&quot;cloud-async-&quot;);</span><br><span class="line">        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@Async</code>注解启用异步方法：<br><code>@Async</code> 是 Spring 框架提供的注解，用于标记一个方法为异步方法。当调用该方法时，Spring 会将其提交到线程池执行，而不是由调用线程同步执行。这在处理耗时操作时非常有用，可以避免阻塞主线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.scheduling.annotation.Async;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class MyService &#123;</span><br><span class="line">    @Async(&quot;asyncExecutor&quot;)</span><br><span class="line">    public CompletableFuture&lt;String&gt; processAsync() &#123;</span><br><span class="line">        // 异步处理逻辑</span><br><span class="line">        return CompletableFuture.completedFuture(&quot;处理完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h3><p><strong>任务加入时判断的顺序：</strong>核心线程数 、阻塞队列、最大线程数、拒绝策略。</p><p><strong>线程池执原理：</strong> </p><ol><li><p>新加入任务，判断corePoolSize是否到最大值；如果没到最大值就创建核心线程执行新任务，如果到最大值就判断是否有空闲的核心线程；</p></li><li><p>如果有空闲的核心线程，则空闲核心线程执行新任务，如果没空闲的核心线程，则尝试加入FIFO阻塞队列；</p></li><li><p>若加入成功，则等待空闲核心线程将队头任务取出并执行，若加入失败（如队列满了），则判断maximumPoolSize是否到最大值；</p></li><li><p>如果没到最大值就创建非核心线程执行新任务，如果到了最大值就执行丢弃策略，默认丢弃新任务；</p></li><li><p>线程数大于corePoolSize时，空闲线程将在keepAliveTime后回收，直到线程数等于核心线程数。这些核心线程也不会被回收。</p></li></ol><p>实际上线程本身没有核心和非核心的概念，都是靠比较corePoolSize和当前线程数判断一个线程是不是能看作核心线程。</p><p>可能某个线程之前被看作是核心线程，等它空闲了，线程池又有corePoolSize个线程在执行任务，这个线程到keepAliveTime后还是会被回收。</p><h3 id="练习：多线程交替打印A-B-C，每个打印3次"><a href="#练习：多线程交替打印A-B-C，每个打印3次" class="headerlink" title="练习：多线程交替打印A/B/C，每个打印3次"></a>练习：多线程交替打印A/B/C，每个打印3次</h3><p> <strong>核心逻辑：</strong>创建线程，循环加锁，执行以下逻辑：</p><ol><li><strong>临界值判断：</strong>到达临界值后唤醒其他线程并结束锁；</li><li><strong>打印判断：</strong>如果需要打印，则打印、操作原子类（只有打印后才操作原子类，否则就是不满足条件，需要下一步的唤醒等待后，进入下一轮的循环）；</li><li><strong>线程通信：</strong>唤醒、等待。</li></ol><blockquote><p><strong>坑点：</strong></p><ul><li><strong>临界值判断不能放到while里：</strong>防止最后一个线程无法唤醒其他线程，从而导致死锁（其他线程没人唤醒了）。</li><li><strong>必须用线程通信：</strong>防止当前线程释放锁后立刻又拿回锁（因为多线程是CPU随机切换的），从而达不到交替打印的效果</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线交替打印A/B/C</span></span><br><span class="line"><span class="comment">// Object类的wait()和notifyAll()方案、不抽取方法： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); <span class="comment">// 当前行值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">9</span>; <span class="comment">// 总打印行数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// 下面创建三个线程可以抽取成一个方法，这里方便理解所以拆开</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// tip：这里条件没必要index.get()&lt;count，因为where不在锁里。</span></span><br><span class="line">            <span class="comment">// 如果临界值判断加到这里，会导致最后一个线程无法唤醒其他线程，从而导致死锁（其他线程没人唤醒了）。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 1.临界值判断：到达临界值后唤醒其他线程并结束锁；</span></span><br><span class="line">                    <span class="keyword">if</span>(index.get()&gt;=count)&#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 2.打印判断：如果需要打印，则打印、操作原子类</span></span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                        <span class="comment">// 只有打印后才操作原子类，否则就是不满足条件，需要下一步的唤醒等待后，进入下一轮的循环</span></span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 3.线程通信：唤醒、等待</span></span><br><span class="line">                    <span class="comment">// 3.1 唤醒其他线程：不管能不能整除，结束后都唤醒其他线程</span></span><br><span class="line">                    <span class="comment">// notifyAll()唤醒该对象上的所有线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="comment">// 3.2 当前线程等待：Object类的wait()让线程等待，直到其他线程调用notify()或notifyAll()方法唤醒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程1打印A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(index.get()&gt;=count)&#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程2打印B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(index.get()&gt;=count)&#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程3打印C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建和启动线程抽取方法</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); <span class="comment">// 当前行值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">9</span>; <span class="comment">// 总打印行数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        createAndStartThread(<span class="string">&quot;线程1打印A&quot;</span>, lock, <span class="number">0</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        createAndStartThread(<span class="string">&quot;线程2打印B&quot;</span>, lock, <span class="number">1</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        createAndStartThread(<span class="string">&quot;线程3打印C&quot;</span>, lock, <span class="number">2</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createAndStartThread</span><span class="params">(String threadName, Object lock, <span class="type">int</span> remainder, String output)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() &gt;= count) &#123;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (index.get() % <span class="number">3</span> == remainder) &#123;</span><br><span class="line">                        System.out.println(output);</span><br><span class="line">                        index.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, threadName).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>其他线程通信方式：</strong></p><ul><li>Object类的wait()和notifyAll()（采用）</li><li><strong>Conditon的await，sign或signAll方法：</strong>创建三个Conditon对象A/B/C，A.await()就是让A线程等待；</li><li><strong>Semaphore的acquire和release方法：</strong>使用三个Semaphore对象，分别初始化为1、0、0，表示A、B、C三个线程的初始许可数。每个线程在打印字母之前，需要调用对应的Semaphore对象的acquire方法，获取许可。每个线程在打印字母之后，需要调用下一个Semaphore对象的release方法，释放许可。</li></ul></blockquote><hr><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>当多个线程访问共享资源时，若不采取同步措施，可能导致数据不一致或其他异常。常见的线程安全问题包括： </p><ul><li><strong>竞态条件</strong>（<code>Race Condition</code>）：多个线程竞争同一资源导致结果不确定。 </li><li><strong>内存可见性</strong>：一个线程修改了共享变量，其他线程可能无法立即看到最新值。 </li><li><strong>指令重排序</strong>：编译器或处理器为优化性能而重新排序指令，可能影响多线程执行顺序。</li></ul><p><strong>线程安全：</strong>程序在多线程环境下可以持续进行正确的处理，不会产生数据竞争（例如死锁）和不一致的问题。<strong>解决方案</strong>：原子类、volatile、锁、线程安全的集合 </p><p><strong>线程安全的解决方案：</strong>按照资源占用情况由轻到重排列：</p><ul><li><strong>原子类：</strong>如<code>AtomicInteger</code>、<code>AtomicLong</code>等，具有原子操作特征（化学中原子是最小单位、不可分割）的类，只能保证单个共享变量的线程安全</li><li><strong>volatile：</strong>只能保证单个共享变量的线程安全</li><li><strong>锁：</strong>可以保证临界区内的多个共享变量线程安全。</li></ul><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>原子类是具有原子操作特征（化学中原子是最小单位、不可分割）的类，原子是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>在java.util.concurrent.atomic包下，有一系列“Atomic”开头的类，统称为原子类。例如AtomicInteger替代int ，底层采用CAS原子指令实现，内部的存储值使用volatile修饰，因此多线程之间是修改可见的。</p><p>以AtomicInteger为例，某线程调用该对象的incrementAndGet()方式自增时采用CAS尝试修改它的值，若此时没有其他线程操作该值便修改成功否则反复执行CAS操作直到修改成功。</p><blockquote><p><strong>CAS：</strong>不断对变量进行原子性比较和交换，从而解决单个变量的线程安全问题。比较内存中值和预期值，如果相等则交换，如果不相等就代表被其他线程改了则重试。 </p></blockquote><p><strong>AtomicInteger常用方法：</strong>  </p><ul><li>构造方法：<ul><li>AtomicInteger (): 创建一个初始值为0的 AtomicInteger。</li><li>AtomicInteger(int initialValue): 创建一个初始值为 initialValue 的 AtomicInteger。</li><li>获取和设置：<ul><li>int get(): 获取当前的值。</li><li>void set(int newValue): 设置为 newValue。</li><li>int getAndSet(int newValue): 获取当前值，并设置为 newValue。 </li></ul></li></ul></li><li><strong>原子更新：</strong><ul><li> boolean compareAndSet(int expect, int update): 如果当前值等于 expect，则更新为 update。</li><li>int getAndIncrement(): 以原子方式将当前值加1，返回的是旧值。</li><li>int incrementAndGet(): 以原子方式将当前值加1，返回的是新值。</li><li>int getAndDecrement(): 以原子方式将当前值减1，返回的是旧值。</li><li>int decrementAndGet(): 以原子方式将当前值减1，返回的是新值。</li><li>int getAndAdd(int delta): 以原子方式将当前值加上 delta，返回的是旧值。</li><li>int addAndGet(int delta): 以原子方式将当前值加上 delta，返回的是新值。</li></ul></li><li><strong>其他方法：</strong> <ul><li> int getAndUpdate(IntUnaryOperator updateFunction): 获取当前值，并按更新函数计算新值设置。</li><li>int updateAndGet(IntUnaryOperator updateFunction): 按更新函数计算新值设置，并返回新值。</li><li>int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction): 获取当前值，并按累加函数计算新值设置。</li><li>int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction): 按累加函数计算新值设置，并返回新值。 </li></ul></li></ul><p><strong>验证原子类的线程安全：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 创建10个线程，分别对atomicInteger进行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    atomicInteger.incrementAndGet();</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞主线程1s，保证10个线程执行完毕</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(atomicInteger);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行之后，可以看到原子类正常加到100000，而num没有</span></span><br></pre></td></tr></table></figure><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile是一个关键字，被volatile声明的变量存在共享内存中，所有线程要读取、修改这个变量，都是从内存中读取、修改，并且修改操作是原子性的，所以它能保证线程安全。</p><p><strong>volatile特性：</strong></p><ul><li><strong>有序性：</strong>被volatile声明的变量之前的代码一定会比它先执行，而之后的代码一定会比它慢执行。底层是在生成字节码文件时，在指令序列中插入内存屏障防止指令重排序。</li><li><strong>可见性：</strong>一旦修改变量则立即刷新到共享内存中，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的工作空间中读取。每个线程自己的工作空间用于存放堆栈（存方法的参数和返回地址）和局部变量。</li><li><strong>原子性：</strong>volatile变量不能保证完全的原子性，只能保证单次的读/写操作具有原子性（在同一时刻只能被一个线程访问和修改），自增减、复合操作（+=,/=等）则不具有原子性。这也是和synchronized的区别。</li></ul><p><strong>读写内存语义：</strong></p><ul><li><strong>写内存语义：</strong>当写一个volatile变量时，JMM（Java内存模型）会把该线程本地内存中的共享变量的值刷新到主内存中。</li><li><strong>读内存语义：</strong>当读一个volatile变量时，JMM会把该线程本地内存置为无效,使其从主内存中读取共享变量。</li></ul><p><strong>有序性实现机制：</strong></p><p>volatile有序性是通过内存屏障来实现的。内存屏障就是在编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p><strong>机器指令：</strong>JVM包括类加载子系统、运行时数据区、执行引擎。 执行引擎负责将字节码指令转为操作系统能识别的本地机器指令。</p><p><strong>指令重排序：</strong>处理器为了提高运算速度会对指令重排序，重排序分三种类型：编译器优化重排序、处理器指令级并行重排序、内存系统重排序。 </p><ul><li><strong>编译器优化的重排序：</strong>编译器在不改变单线程程序的语义前提下，可以重新安排语句的执行顺序。</li><li><strong>指令级并行的重排序：</strong>现在处理器采用了指令集并行技术，将多条指令重叠执行。如果不存在依赖性，处理器可以改变语句对应的机器指令的执行顺序。</li><li><strong>内存系统的重排序：</strong>由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>加锁的方式有两种，分别是synchronized关键字和Lock接口（在JUC包下）。</p><p><strong>synchronized锁</strong>是互斥锁，可以作用于实例方法、静态方法、代码块，能够保证同一个时刻只有一个线程执行该段代码，保证线程安全。 在执行完或者出现异常时自动释放锁。synchronized锁基于对象头和Monitor对象，在1.6之后引入轻量级锁、偏向锁等优化。</p><p><strong>lock锁</strong>接口可以通过lock、unlock方法锁住一段代码，Lock实现类都是基于AQS实现的。Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// ToDo: handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System. out.println(“释放锁<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    lock. unlock();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><ol><li><strong>Collections工具类：</strong>Collections工具类的synchronizedXxx()方法<strong>，</strong>将ArrayList等集合类包装成线程安全的集合类。</li><li><strong>古老api：</strong>java.util包下性能差的古老api，如Vector、Hashtable</li><li><strong>降低锁粒度的并发容器：</strong>JUC包下Concurrent开头的、以降低锁粒度来提高并发性能的容器，如ConcurrentHashMap。</li><li><strong>复制技术实现的并发容器：</strong>JUC包下以CopyOnWrite开头的、采用写时复制技术实现的并发容器，如CopyOnWriteArrayList。 </li></ol><h2 id="分布式场景下的线程安全"><a href="#分布式场景下的线程安全" class="headerlink" title="分布式场景下的线程安全"></a>分布式场景下的线程安全</h2><p>在分布式系统中，仅靠JVM级别的同步机制无法保证线程安全，需引入分布式锁：</p><ol><li><p><strong>Redis分布式锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;distributed_lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RELEASE_SCRIPT</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLock</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">(String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(LOCK_KEY, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">releaseLock</span><span class="params">(String requestId)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(RELEASE_SCRIPT, <span class="number">1</span>, LOCK_KEY, requestId);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ZooKeeper分布式锁</strong>：使用<code>Apache Curator</code>框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZookeeperLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed_lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> InterProcessMutex lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZookeeperLock</span><span class="params">(String zkConnectString)</span> &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(</span><br><span class="line">            zkConnectString, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">        );</span><br><span class="line">        client.start();</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, LOCK_PATH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        lock.acquire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>多条语句共享数据时，多线程程序会出现<strong>数据安全问题</strong>。</p><p><strong>线程同步：</strong>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态。</p><p>Java主要通过加锁的方式实现线程同步,而锁有两类,分别是synchronized关键字和Lock接口（在JUC包下）。具体见<a href="#%E9%94%81">锁</a></p><p><strong>对比线程安全和线程同步：</strong>线程同步是实现线程安全的一种手段</p><ul><li><strong>线程安全：</strong>程序在多线程环境下可以持续进行正确的处理，不会产生数据竞争（例如死锁）和不一致的问题。解决方案：原子类、volatile、锁、线程安全的集合</li><li><strong>线程同步：</strong>确保多个线程正确、有序地访问共享资源。解决方案：锁</li></ul><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>同步代码块作用在代码块上,则需要在关键字后面的小括号里,显式指定锁对象，例如this、Xxx.class。</p><p>同步代码块简单来说就是将一段代码用一把锁给锁起来, 只有获得了这把锁的线程才访问, 并且同一时刻, 只有一个线程能持有这把锁, 这样就保证了同一时刻只有一个线程能执行被锁住的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步对象) &#123;</span><br><span class="line">    <span class="comment">//多条语句操作共享数据的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步代码块的好处：</strong>解决了多线程的数据安全问题</p><p><strong>弊端：</strong>线程很多时，每个线程都会去判断锁，这是很耗费资源和时间的。例如，共有100张票，三个窗口卖票，通过加锁防止超卖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">sellTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><ol><li><p>作用在静态方法上,则锁是当前类的Class对象。</p></li><li><p>作用在普通方法上,则锁是当前的实例（this）。</p></li></ol><p><strong>非静态同步方法的锁对象为this</strong>。下面代码是相同功能的同步方法和同步代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁的粒度是当前对象</span></span><br><span class="line"><span class="comment">// 方法1：实例方法，使用this对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sellTicket1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：实例方法，使用this对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sellTicket2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 锁的粒度是整个类：</span></span><br><span class="line"><span class="comment">// 静态同步方法的锁对象为：类名.class。下面代码是相同功能的同步方法和同步代码块 </span></span><br><span class="line"><span class="comment">// 方法3：静态方法，使用类对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sellTicket3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">        tickets--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：静态方法，使用类对象锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sellTicket4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在出售第 &quot;</span> + tickets + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="异步执行时保证事务有效性"><a href="#异步执行时保证事务有效性" class="headerlink" title="异步执行时保证事务有效性"></a>异步执行时保证事务有效性</h1><p>Spring的事务管理基于线程绑定的<code>TransactionSynchronizationManager</code>，而异步方法会在独立线程中执行，导致事务上下文丢失。</p><h2 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a><strong>问题根源</strong></h2><p>Spring事务依赖于线程上下文传递事务信息。当使用<code>@Async</code>时，方法在新线程中执行，与调用线程不在同一个事务上下文： </p><ol><li><strong>事务管理器失效</strong>：新线程没有绑定事务上下文。</li><li><strong>数据库连接丢失</strong>：每个线程使用独立的数据库连接。 </li><li><strong>异常回滚失效</strong>：异步线程的异常无法触发调用线程的事务回滚。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="独立事务（推荐）"><a href="#独立事务（推荐）" class="headerlink" title="独立事务（推荐）"></a><strong>独立事务</strong>（推荐）</h3><ul><li><p>为每个异步方法创建独立的事务，适用于可容忍部分失败的场景（如批量处理）</p></li><li><p><strong>特点</strong>：</p><ul><li>每个异步任务独立提交/回滚</li><li>适合批量处理大量数据，部分失败不影响整体</li></ul></li><li><p><strong>配置示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>  <span class="comment">// 创建新事务</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">processData</span><span class="params">(Long recordId)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">        repository.updateStatus(recordId, <span class="string">&quot;PROCESSING&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务逻辑</span></span><br><span class="line">            complexProcessing(recordId);</span><br><span class="line">            repository.updateStatus(recordId, <span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            repository.updateStatus(recordId, <span class="string">&quot;FAILED&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;处理失败&quot;</span>, e);  <span class="comment">// 触发当前事务回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a><strong>事件驱动架构</strong></h3><ul><li><p>将异步操作转为事件，主线程提交事务后再处理事件，确保数据一致性。</p></li><li><p><strong>特点</strong>：</p><ul><li>事务提交后才触发异步处理</li><li>适合耗时操作不影响主线程事务的场景</li></ul></li><li><p><strong>实现步骤</strong>：</p><ul><li><p><strong>定义事件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataProcessEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long recordId;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataProcessEvent</span><span class="params">(Long recordId)</span> &#123; <span class="built_in">this</span>.recordId = recordId; &#125;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>发布事件（在事务内）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createAndProcessData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建记录（事务内）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">recordId</span> <span class="operator">=</span> repository.save(<span class="keyword">new</span> <span class="title class_">Record</span>()).getId();</span><br><span class="line">        <span class="comment">// 发布事件（事务提交后触发）</span></span><br><span class="line">        eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">DataProcessEvent</span>(recordId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>异步监听事件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataProcessListener</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDataProcessEvent</span><span class="params">(DataProcessEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步处理（无事务）</span></span><br><span class="line">        processData(event.getRecordId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="手动管理事务（高级）"><a href="#手动管理事务（高级）" class="headerlink" title="手动管理事务（高级）"></a><strong>手动管理事务</strong>（高级）</h3><ul><li><p>在异步方法中手动获取和管理事务，适用于强一致性要求的场景。 </p></li><li><p><strong>特点</strong>：</p><ul><li>完全控制事务边界</li><li>代码复杂度高，需谨慎处理异常</li></ul></li><li><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManualTransactionService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionDefinition transactionDefinition;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">processWithManualTx</span><span class="params">(Long recordId)</span> &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(transactionDefinition);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 数据库操作</span></span><br><span class="line">            repository.updateStatus(recordId, <span class="string">&quot;PROCESSING&quot;</span>);</span><br><span class="line">            complexProcessing(recordId);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 手动提交事务</span></span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 手动回滚事务</span></span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;处理失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="补偿事务（最终一致性）"><a href="#补偿事务（最终一致性）" class="headerlink" title="补偿事务（最终一致性）"></a><strong>补偿事务</strong>（最终一致性）</h3><ul><li><p>通过补偿机制保证最终一致性，适用于分布式系统</p></li><li><p><strong>特点</strong>：</p><ul><li>保证最终一致性，而非强一致性</li><li>适合跨服务、跨系统的操作</li></ul></li><li><p><strong>实现方案</strong>： </p><ul><li><strong>记录操作日志</strong>：在主事务中记录所有操作。 </li><li><strong>异步执行</strong>：调用外部服务或执行复杂逻辑。 </li><li><strong>补偿逻辑</strong>：若异步操作失败，根据日志执行反向操作</li></ul></li><li><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompensationService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrderWithCompensation</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建订单（主事务）</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">savedOrder</span> <span class="operator">=</span> orderRepository.save(order);</span><br><span class="line">        <span class="comment">// 2. 记录补偿日志（主事务）</span></span><br><span class="line">        compensationLogRepository.save(<span class="keyword">new</span> <span class="title class_">CompensationLog</span>(</span><br><span class="line">            savedOrder.getId(), <span class="string">&quot;CREATE_ORDER&quot;</span>, savedOrder</span><br><span class="line">        ));</span><br><span class="line">        <span class="comment">// 3. 异步处理库存、支付等（无事务）</span></span><br><span class="line">        asyncService.processOrderAsync(savedOrder.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrderAsync</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 扣减库存、调用支付等操作</span></span><br><span class="line">            inventoryService.debitStock(orderId);</span><br><span class="line">            paymentService.processPayment(orderId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 触发补偿逻辑</span></span><br><span class="line">            compensationService.rollbackOrder(orderId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最佳实践总结"><a href="#最佳实践总结" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h2><ol><li><strong>优先使用独立事务</strong>：为每个异步任务创建独立事务，通过状态跟踪失败记录。 </li><li><strong>避免长事务</strong>：将耗时操作移出事务，减少锁持有时间。 </li><li><strong>使用可靠消息队列</strong>：如<code>RabbitMQ、Kafka</code>，确保事件不丢失。 </li><li><strong>实现幂等性</strong>：异步操作需支持重试（如<code>唯一索引、状态校验</code>）。 </li><li><strong>监控与告警</strong>：记录异步任务状态，及时发现并处理失败。</li></ol><h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><ol><li><p><strong>错误配置传播行为</strong>： </p><ul><li><p>使用<code>Propagation.REQUIRED</code>（默认）会导致异步方法加入调用者的事务（但实际上无法加入）。</p></li><li><p>必须使用<code>Propagation.REQUIRES_NEW</code>创建新事务。  </p></li></ul></li><li><p><strong>忽略异步异常</strong>： </p><ul><li>未捕获的异常会导致事务无法回滚。 </li><li>确保在异步方法中处理异常或使用<code>CompletableFuture</code>的异常处理。</li></ul></li><li><p><strong>过度依赖同步事务</strong>：</p><ul><li>在分布式系统中，强一致性难以实现，考虑最终一致性方案</li></ul></li></ol><h2 id="多线程如何保证事务一致性"><a href="#多线程如何保证事务一致性" class="headerlink" title="多线程如何保证事务一致性"></a>多线程如何保证事务一致性</h2><p>‌在多线程环境下保证事务一致性主要通过编程式事务管理、线程资源隔离、分布式事务框架及数据库锁机制等方案实现‌，具体选择需根据业务场景和技术架构灵活适配。‌‌</p><h3 id="核心实现方案：编程式事务管理‌"><a href="#核心实现方案：编程式事务管理‌" class="headerlink" title="核心实现方案：编程式事务管理‌"></a><strong>核心实现方案</strong>：编程式事务管理‌</h3><ol><li><p>通过代码手动控制事务边界，将多个子线程操作纳入统一事务管理框架</p></li><li><p>使用Spring的<code>TransactionTemplate</code>在子线程中执行数据库操作。 </p></li><li><p>主线程等待所有子线程执行完成后统一提交或回滚事务。‌‌‌‌</p></li><li><p><strong>示例代码结构</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Future&lt;?&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">    futures.add(executor.submit(() -&gt;</span><br><span class="line">        transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            <span class="comment">// 事务操作</span></span><br><span class="line">        &#125;);</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查所有子线程结果后决策提交/回滚 (自己判断是提交还是回滚)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="‌关键技术支撑‌"><a href="#‌关键技术支撑‌" class="headerlink" title="‌关键技术支撑‌"></a>‌<strong>关键技术支撑</strong>‌</h3><ul><li><p><strong>事务资源隔离机制</strong>‌</p><ul><li><p>突破默认的<code>ThreadLocal</code>绑定模式，通过自定义<code>TransactionSynchronizationManager</code>实现跨线程Connection共享。‌‌</p></li><li><p>使用<code>@Transactional(propagation = REQUIRES_NEW)</code>创建独立事务上下文。   </p></li></ul></li><li><p><strong>并发控制策略</strong>‌</p><ul><li><p><strong>数据库锁机制</strong>：结合<code>SELECT ... FOR UPDATE</code>实现行级锁，配合事务隔离级别（如<code>REPEATABLE_READ</code>）防止脏写。‌‌</p></li><li><p><strong>Java同步工具</strong>：采用<code>CountDownLatch</code>确保所有子线程就绪后统一提交。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> DataSource dataSource ; </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">cdl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>) ;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">txRollback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>) ;</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      person.setAge(<span class="number">1</span>);</span><br><span class="line">      person.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">      transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          result = jdbcTemplate.update( <span class="string">&quot;insert into t_person (age, name) values (?, ?)&quot;</span>, </span><br><span class="line">                                       person.getAge(), person.getName() );</span><br><span class="line">          <span class="comment">// TODO</span></span><br><span class="line">          <span class="comment">// log.info(1 / 0) ;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          txRollback.set(<span class="literal">true</span>); <span class="comment">// 当发生异常后将状态该为 true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cdl.countDown(); <span class="comment">// 计数减一</span></span><br><span class="line">          cdl.await(); <span class="comment">// 继续等待其它线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (txRollback.get()) &#123; <span class="comment">// 如果回滚状态为 true 说明有线程发生了异常，需要事务回滚</span></span><br><span class="line">          status.setRollbackOnly(); <span class="comment">// 标记当前事务回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;%s Insert Operator Result: %d 次%n&quot;</span>, Thread.currentThread().getName(), result);</span><br><span class="line">        <span class="keyword">return</span> result ;</span><br><span class="line">      &#125;) ;</span><br><span class="line">    &#125;) ;</span><br><span class="line">    transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      person.setAge(<span class="number">2</span>);</span><br><span class="line">      person.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        result = jdbcTemplate.update(<span class="string">&quot;insert into t_person (age, name) values (?, ?)&quot;</span>, </span><br><span class="line">                                     person.getAge(), person.getName()) ;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>) ;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        txRollback.set(<span class="literal">true</span>) ; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cdl.countDown() ;</span><br><span class="line">        cdl.await() ;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (txRollback.get()) &#123;</span><br><span class="line">        status.setRollbackOnly(); <span class="comment">// 回滚</span></span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">&quot;%s Insert Operator Result: %d 次%n&quot;</span>, Thread.currentThread().getName(), result);</span><br><span class="line">      <span class="keyword">return</span> result ;</span><br><span class="line">    &#125;) ;</span><br><span class="line">    cdl.await() ;</span><br><span class="line">    log.info(<span class="string">&quot;Operator Complete...&quot;</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>分布式锁</strong>：通过<code>Redis</code>或<code>ZooKeeper</code>实现跨进程锁协调。‌‌</p></li></ul></li></ul><h3 id="扩展方案选型‌-：分布式事务补偿‌"><a href="#扩展方案选型‌-：分布式事务补偿‌" class="headerlink" title="扩展方案选型‌ ：分布式事务补偿‌"></a>扩展方案选型‌ ：分布式事务补偿‌</h3><ul><li><p><strong>Saga模式：</strong>拆分事务为多个可补偿的本地事务。</p></li><li><p><strong>TCC（Try-Confirm-Cancel）模式：</strong>通过预留资源保证最终一致性。</p></li><li><p>整合<code>Seata</code>等分布式事务框架实现全局事务管理</p></li></ul>]]></content>
    
    
    <summary type="html">多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA I/O流</title>
    <link href="https://southernfish.github.io/2025/07/24/java/java-base-7-io/"/>
    <id>https://southernfish.github.io/2025/07/24/java/java-base-7-io/</id>
    <published>2025-07-24T00:20:36.000Z</published>
    <updated>2025-07-28T10:27:55.452Z</updated>
    
    <content type="html"><![CDATA[<p>java.io是Java编程语言中处理输入输出（I/O）操作的核心类库，定义了数据流模型与多种接口，支持文件操作、网络通信及对象序列化等功能。其通过流（Stream）机制实现数据传输，涵盖字节流、字符流与缓冲处理等设计，为Java标准库的重要组成部分。</p><p>该库将数据源抽象为输入流和输出流，按传输方向分为输入型与输出型，按单位分为字节流（8位字节处理）与字符流（16位字符处理）。功能上包含直接操作设备的节点流和增强功能的过滤流，核心类包括InputStream、OutputStream、Reader、Writer四个抽象类及其子类，形成分层结构的I/O处理体系。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/137256095">https://blog.csdn.net/qq_40991313/article/details/137256095</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><strong>什么是I/O流</strong></p><p>I/O流（Input/Output Stream），即输入（Input）和输出（Output）流，是用于处理输入和输出操作的数据流。在Java中，一般用IO流写一个文件输出到操作系统中，或者从操作系统中输入一个文件进行读取。</p><p><strong>IO流分类：</strong></p><p><strong>按数据流向</strong>：</p><ul><li><strong>输入流</strong>：读数据。</li><li><strong>输出流</strong>：写数据。</li></ul><p><strong>按数据类型</strong>：</p><ul><li><strong>字节流</strong>：它处理单元为1个字节（byte），操作字节和字节数组，存储的是二进制文件。<ul><li><strong>使用场景</strong>：在Java中，一般用IO流写一个文件输出到操作系统中，或者从操作系统中输入一个文件进行读取。如果是<strong>音频文件、图片、歌曲</strong>，就用字节流（1byte = 8位）。</li></ul></li><li><strong>字符流</strong>：它处理的单元为2个字节的<code>Unicode</code>字符，<strong>分别操作字符、字符数组或字符串</strong>，字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的。<ul><li><strong>使用场景</strong>：如果是关系到中文（文本）的，用字符流（1Unicode = 2字节 = 16位）；</li></ul></li></ul><p><strong>字节流</strong></p><p><strong>输入字节流</strong> (<code>InputStream</code>)</p><ul><li>**<code>FileInputStream</code>**：基本的文件输入流，用于读取字节文件（如图片、视频）中的数据。</li><li>**<code>FilterInputStream</code>**：过滤输入流，是所有过滤输入流的父类。用于对数据进行解密、校验、转换、过滤、缓存。因为它是抽象类，所以我们一般用它的子类：<ul><li>**<code>BufferedInputStream</code>**：相比于FileInputStream，它的读取性能会高很多。因为它多了一个缓冲区数组（在内存中），在第一次调用read()读取数据时，他会将数据尽可能多的填满缓冲区，这样再次read()时会优先从缓冲区中读，而不用直接在磁盘中读。我们知道内存读写性能是远高于磁盘的，所以它更快。默认缓冲区大小是8192字节，即8KB，超过这个容量就必须在磁盘读取了。</li><li>**<code>DataInputStream</code>**：与相比于FileInputStream，它的读取性能会高很多。因为它直接提供了读取Java中基本数据类型的方法，如 readInt()、readDouble()、readUTF() 等，而不需要额外的解析步骤。</li><li>**<code>SocketInputStream</code>**：网络输入流。</li></ul></li></ul><p><strong>输出字节流</strong> (<code>OutputStream</code>)</p><ul><li>**<code>FileOutputStream</code>**：基本的文件输出流，用于将数据写入字节文件（如图片、视频）。</li><li>**<code>FilterOutputStream</code>**：过滤输出流，是所有过滤输出流的父类，提供了基本的输出流功能。用于压缩数据、加密数据等。因为它是抽象类，所以我们一般用它的子类：<ul><li>**<code>BufferedOutputStream</code>**：为输出流提供缓冲功能，提高写入效率。每次写入数据时，先写进缓冲区，缓冲区满了会自动刷新写入到磁盘中，也可以手动调用flash()方法刷新。</li><li>**<code>DataOutputStream</code>**：性能高，因为它直接提供了写入Java中基本数据类型的方法，如 wirteInt()，而不需要额外的转换步骤。</li><li><strong>SocketOutputStream</strong>；</li></ul></li></ul><p><strong>字符流</strong></p><p>字符流是以字符为单位处理数据的流，分为输入字符流和输出字符流。</p><p><strong>输入字符流</strong> (<code>Reader</code>)</p><ul><li>**<code>InputStreamReader</code>**：输入流读取类，用于将字节流转换为字符流再读取字符数据。使用系统默认字符编码。</li><li>**<code>FileReader</code>**：文件读取类，用于直接从文件中读取字符数据。可以指定字符编码来解码字节流。</li><li>**<code>BufferedReader</code>**：为字符输入流提供缓冲功能，提高读取效率。</li></ul><p><strong>输出字符流</strong> (<code>Writer</code>)</p><ul><li>**<code>OutputStreamWriter</code>**：将字符流转换为字节流。</li><li>**<code>FileWriter</code>**：用于将字符数据写入文件。</li><li>**<code>BufferedWriter</code>**：为字符输出流提供缓冲功能，提高写入效率。</li></ul><hr><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>File类是用于表示文件和目录路径名的类。</p><blockquote><p> <strong>注意</strong>：File类封装的不是真正的文件，只是路径。所以File类可以对文件进行<strong>创建、删除、重命名、修改时间、文件大小</strong>等操作，但不能对文件里的数据进行读取或者写入，它一般作为输入输出流的构造参数，指明文件的路径。</p></blockquote><p><strong>创建文件示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\1\\2.txt&quot;</span>);</span><br><span class="line">      <span class="comment">//只创建已存在文件夹“D://1”下的2.txt。若“D://1”不存在，报错IOException: 系统找不到指定的路径。</span></span><br><span class="line">        System.out.println(f.createNewFile());  <span class="comment">//true，当目标位置已存在同名文件则创建失败输出false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>文件默认路径：</strong></p><p>在当前包内IO流，使用File类创建文件时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>默认存的位置是在项目文件夹下，而不是包文件夹下。</p><p><strong>关于路径斜杠和反斜杠：</strong></p><p>路径斜杠可以是//,/,\,不能是\，因为它是转义符。 </p><p>正斜杠“/”和“//”都可以，反斜杠必须“\”，因为“\”会ASCII转义，“\”在字符串里才是“\”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://1//1.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/1/2.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\1\\3.txt&quot;</span>);</span><br><span class="line"><span class="comment">// File file3 = new File(&quot;D:\1\4.txt&quot;);          // 这样会报错，单个反斜杠会进行转义</span></span><br><span class="line">System.out.println(file.createNewFile());       <span class="comment">// true</span></span><br><span class="line">System.out.println(file1.createNewFile());       <span class="comment">// true</span></span><br><span class="line">System.out.println(file2.createNewFile());       <span class="comment">// true</span></span><br><span class="line"><span class="comment">// System.out.println(file3.createNewFile());   // false </span></span><br></pre></td></tr></table></figure><p><strong>查看当前路径：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));    <span class="comment">//D:\workspace\java\test</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>常用方法</strong>：</p><ul><li>**<code>boolean createNewFile()</code>**： 当且仅当具有该名称的文件尚不存在时，原子地（保证线程安全）创建一个由该抽象路径名命名的新空文件。抽象路径名指的是构造 File 对象时传递的路径名字符串。创建File对象时，构造参数的路径并不一定真实存在，可能是虚拟的、等待通过createNewFile等方法进行创建。</li><li><strong><code>boolean mkdir()</code></strong> ：创建目录。如果父目录不存在，则不会创建目录，并返回 false。</li><li>**<code>boolean mkdirs()</code>**： 创建目录。如果父目录不存在，它会一并创建。</li><li>**<code>boolean delete()</code>**： 删除文件或目录。成功删除文件或目录时返回 true，否则返回 false。注意如果要删除目录，该目录必须为空，否则会返回false。</li><li>**<code>boolean isDirectory()</code>**： 测试File是否为目录。</li><li>**<code>boolean isFile()</code>**： 测试File是否为文件。</li><li>**<code>boolean exists()</code>**： 测试File是否真实存在。</li><li>**<code>String getAbsolutePath()</code>**： 返回绝对路径名字符串。</li><li>**<code>String getPath()</code>**： 将抽象路径名。也就是构造 File 对象时传递的路径名字符串，可能是绝对路径，也可能是相对路径。</li><li>**<code>String getName()</code>**： 返回由此抽象路径名表示的文件或目录的名称。</li><li>**<code>String[] list()</code>**： 返回对应目录下所有文件的文件名数组。</li><li>**<code>File[] listFiles()</code>**： 返回对应目录下所有文件的File文件数组。</li></ul><p><strong>举例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1\\2\\3&quot;</span>);</span><br><span class="line">    <span class="comment">// mkdirs()如果父目录不存在，它会一并创建。</span></span><br><span class="line">    System.out.println(f.mkdirs());</span><br><span class="line">    <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1\\2\\3\\4.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建失败&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// listFiles()是路径下的所有文件组成的数组，若f文件会报错</span></span><br><span class="line">    File[] f2 = f.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file : f2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(file.getName() + <span class="string">&quot;,&quot;</span> + file.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="comment">// 删除目录时要确保目录下没文件。</span></span><br><span class="line">    <span class="comment">// f1.delete();</span></span><br><span class="line">    <span class="comment">// f.delete();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 4.txt,1\2\3\4.txt</span></span><br></pre></td></tr></table></figure><hr><h1 id="字节流的超类"><a href="#字节流的超类" class="headerlink" title="字节流的超类"></a>字节流的超类</h1><h2 id="字节输出流OutputStream"><a href="#字节输出流OutputStream" class="headerlink" title="字节输出流OutputStream"></a>字节输出流OutputStream</h2><p><strong>概念：</strong> </p><p>Java中的 InputStream 和 OutputStream 都是 io 包中面向字节操作的顶级<strong>抽象类</strong>。所有字节流类都是他们的子类。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250722203841265.png" alt="image-20250722203841265"></p><p><strong>子类</strong>：</p><ul><li><strong>网络数据传输</strong>：SocketOutputStream</li><li><strong>文件操作</strong>：<code>FileOutputStream</code></li><li><strong>字节数据操作</strong>：DataOutputStream</li></ul><p><strong>常用api</strong>： </p><ul><li><strong><code>void close()</code></strong> ：关闭此输出流并释放与此流相关联的任何系统资源。</li><li><strong><code>void flush()</code></strong> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li><li><strong><code>void write(byte[] b)</code></strong> ：将 b.length 字节从指定的字节数组写入此输出流。</li><li><strong><code>void write(byte[] b, int off, int len)</code></strong> ： 从指定的字节数组写入 len 个字节，从偏移 off 开始输出到此输出流。</li><li><strong><code>abstract void write(int b)</code></strong> ：将指定的字节写入此输出流。</li></ul><h2 id="字节输入流InputStream"><a href="#字节输入流InputStream" class="headerlink" title="字节输入流InputStream"></a>字节输入流InputStream</h2><p><strong>概念</strong>： </p><p>Java中的 InputStream 和 OutputStream 都是 io 包中面向字节操作的顶级抽象类，关于java同步 io字节流的操作都是基于这两个的。</p><p><strong>子类</strong>：</p><ul><li><strong>网络数据传输</strong>：SocketInputStream</li><li><strong>文件操作</strong>：FileInputStream</li><li><strong>字节数据操作</strong>：DataInputStream。与相比于FileInputStream，它的读取性能会高很多。因为它直接提供了读取Java中基本数据类型的方法</li><li><strong>带缓冲区的输入流</strong>：BufferedInputStream</li></ul><p><strong>常用api</strong>： </p><ul><li>**<code>abstract int  read()</code>**：从输入流读取数据的下一个字节。</li><li>**<code>int  read(byte[] b)</code>**：从输入流读取一些字节数，并将它们存储到缓冲区 b，返回值为长度 。</li><li>**<code>int  read(byte[] b, int off, int len)</code>**：从输入流读取最多 len字节的数据到一个字节数组。</li></ul><hr><h1 id="字节文件流"><a href="#字节文件流" class="headerlink" title="字节文件流"></a>字节文件流</h1><h2 id="文件输出流FileOutputStream"><a href="#文件输出流FileOutputStream" class="headerlink" title="文件输出流FileOutputStream"></a>文件输出流FileOutputStream</h2><p>基本的文件输出流，用于将数据写入字节文件（如图片、视频）。输出流是写数据，把数据输出到文件里。</p><p><strong>构造方法</strong>：</p><ul><li>**<code>FileOutputStream(File file)</code>**：创建文件输出流以写入由指定的 File对象表示的文件。</li><li>**<code>FileOutputStream(String name)</code>**：创建文件输出流以指定的名称写入文件</li><li>**<code>FileOutputStream(String name, boolean append)</code>**：创建文件输出流以指定的名称写入文件。append默认是false，即彻底覆盖写入。append为true时是追加写入。</li><li><strong><code>FileOutputStream(File file, boolean append)</code></strong>: 使用文件对象创建文件输出流，并选择是否追加数据。</li></ul><p><strong>写操作方法</strong></p><ul><li><strong><code>void write(int b)</code></strong>: 将指定的字节写入输出流。</li><li><strong><code>void write(byte[] b)</code></strong>: 将字节数组 b 写入输出流。</li><li><strong><code>void write(byte[] b, int off, int len)</code></strong>: 将字节数组 b 中从偏移量 off 开始的 len 个字节写入输出流。</li></ul><p><strong>关闭方法</strong></p><ul><li><strong><code>void close()</code></strong>: 关闭文件输出流并释放与此流有关的所有系统资源。</li></ul><p>示例，将“abcde” 写入1.txt文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        FileOutputStream fos=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://1.txt&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] b =<span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">            fos.write(b);</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="comment">// 实际开发不建议用e.printStackTrace()打日志，而是logger.error()</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 判空，防止创建流的时候就失败，进入catch中</span></span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到D盘下多了个1.txt，内容是abcde</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：写数据时的换行符，windows系统下是\r\n，linux的换行是\n，mac换行\r.</p></blockquote><h2 id="文件输入流-FileInputStream"><a href="#文件输入流-FileInputStream" class="headerlink" title="文件输入流 FileInputStream"></a>文件输入流 FileInputStream</h2><p>基本的文件输入流，用于读取字节文件（如图片、视频）中的数据。</p><p><strong>常用方法</strong>： </p><ul><li>**<code>FileInputStream(File file)</code>**：构造方法，创建一个 FileInputStream，它读取从指定File对象的文件。</li><li>**<code>FileInputStream(String name)</code>**：构造方法，创建一个 FileInputStream，它读取从指定文件路径名的文件</li><li>**<code>int read()</code>**：读取一个字节的数据。返回的int是读取字节的个数，如果到达流的末尾，则返回值 -1。</li><li>**<code>int read(byte[] b)</code>**：读取一定字节（0~b.length，具体长度取决于是否读到了末尾）的数据，将其存储在缓冲区数组 b 中。返回读取的字节数，如果没有可用的字节，则返回 -1。</li><li>**<code>int read(byte[] b, int off, int len)</code>**：最多读取 len 个字节的数据到一个字节数组。尝试读取最多 len 个字节的数据到缓冲区 b 中，从 off 位置开始。返回读取的字节数，如果没有可用的字节，则返回 -1。</li></ul><p><strong>代码示例</strong>：通过文件输入输出流复制图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://1.png&quot;</span>);</span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://2.png&quot;</span>);</span><br><span class="line">        <span class="type">byte</span> []b=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len=fis.read(b);</span><br><span class="line">        <span class="keyword">while</span>(len!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b,<span class="number">0</span>,len);len=fis.read(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果就是 D盘多了一个2.png图片</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>扩展</strong></p><p>使用maven后可以导入commons-io包，直接通过工具类复制。</p><p> 使用IOUtils.copy(fis,os)进行流的复制（推荐）</p><p>(1)pom.xml添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2)调用工具类方法实现复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fis:输入流</span></span><br><span class="line"><span class="comment">//os:输出流</span></span><br><span class="line">IOUtils.copy(fis,os);</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="字节缓冲流（推荐）"><a href="#字节缓冲流（推荐）" class="headerlink" title="字节缓冲流（推荐）"></a>字节缓冲流（推荐）</h1><p><strong>特点</strong>： </p><ul><li><p>字节缓冲流仅提供缓冲区，真正读写数据还要靠基本字节流对象操作。</p></li><li><p>字节缓冲流读写数据比基本字节流快很多，因为它有个存在内存中的字节数组，作为缓冲区，读写时先在缓冲区中读写，性能比直接在磁盘中读写快很多。</p></li></ul><h2 id="字节缓冲输出流BufferedOutputStream"><a href="#字节缓冲输出流BufferedOutputStream" class="headerlink" title="字节缓冲输出流BufferedOutputStream"></a>字节缓冲输出流BufferedOutputStream</h2><p>**<code>BufferedOutputStream</code>**是一个带缓冲区的输出流，它跟FileOutputStream一样，都继承自OutputStream抽象类。</p><p>与普通的OutputStream相比，BufferedOutputStream在写入数据时使用了一个存在内存中的中间缓冲区。当向BufferedOutputStream写入数据时，数据首先会被写入到缓冲区，而不是直接写入到目标输出流（即最终的目标输出，比如文件、网络连接、控制台）。当缓冲区满了、手动刷新flash()、手动关闭close()时，BufferedOutputStream会将缓冲区中的数据一次性写入到目标输出流中。</p><p>这种缓冲机制可以减少实际的物理写操作，从而提高写操作的效率。因为磁盘IO是很慢的，而内存IO是很快的，相比于每次写入一个字节到目标输出流，将多个字节一次性写入会更加高效，磁盘IO次数有效减少。</p><p><strong>构造方法</strong></p><ul><li><strong><code>BufferedOutputStream(OutputStream out)</code></strong> ：创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</li><li>**<code>BufferedOutputStream(OutputStream out, int size)</code>**：创建一个新的缓冲输出流，以将数据写入指定的底层输出流，并具有指定的缓冲区大小。</li></ul><p><strong>写入方法</strong></p><ul><li>**<code>void write(int b)</code>**：将指定的字节写入此缓冲输出流。</li><li>**<code>void write(byte[] b, int off, int len)</code>**：将字节数组中的指定字节写入此缓冲输出流。</li></ul><p><strong>刷新方法</strong></p><ul><li><p>**<code>void flush()</code>**：刷新此缓冲输出流，将任何缓冲的输出字节写出到底层输出流。<br>关闭方法</p></li><li><p>**<code>void close()</code>**：关闭此输出流并释放与此流相关联的任何系统资源。在关闭流之前，会刷新它。<br><strong>构造方法</strong></p></li><li><p>**<code>BufferedInputStream(InputStream in)</code>**：创建一个新的缓冲输入流，以从指定的底层输入流读取数据。</p></li><li><p>**<code>BufferedInputStream(InputStream in, int size)</code>**：创建一个新的缓冲输入流，以从指定的底层输入流读取数据，并具有指定的缓冲区大小。</p></li></ul><p><strong>读取方法</strong></p><ul><li>**<code>int read()</code>**：从输入流中读取数据的下一个字节。</li><li>**<code>int read(byte[] b, int off, int len)</code>**：从输入流中将最多 len 个字节的数据读入一个字节数组。</li><li>**<code>int read(byte[] b)</code>**：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</li></ul><p><strong>跳过和可用</strong></p><ul><li>**<code>long skip(long n)</code>**：跳过和丢弃输入流中最多 n 个字节的数据。</li><li>**<code>int available()</code>**：返回可以不受阻塞地从输入流中读取的剩余字节数。阻塞（Blocking） 是指程序在等待某些操作完成（例如读取数据、写入数据、获取网络响应等）时停止执行其他操作，直到该操作完成。</li></ul><p><strong>标记和重置</strong></p><ul><li>**<code>void mark(int readlimit)</code>**：在输入流中标记当前位置。</li><li>**<code>void reset()</code>**：将流重新定位到上次调用 mark 方法时的位置。</li><li>**boolean markSupported()**：测试输入流是否支持 mark 和 reset 方法。</li></ul><p><strong>关闭</strong></p><ul><li>**<code>void close()</code>**：关闭输入流并释放与此流相关联的任何系统资源。</li></ul><h2 id="字节缓冲输入流BufferedInputStream"><a href="#字节缓冲输入流BufferedInputStream" class="headerlink" title="字节缓冲输入流BufferedInputStream"></a>字节缓冲输入流BufferedInputStream</h2><p>BufferedInputStream是字节缓冲输入流。</p><p>相比于FileInputStream，它的读取性能会高很多。因为它多了一个缓冲区数组（在内存中），在第一次调用read()读取数据时，他会将数据尽可能多的填满缓冲区，这样再次read()时会优先从缓冲区中读，而不用直接在磁盘中读。</p><p>内存读写性能是远高于磁盘的，所以它更快。默认缓冲区大小是8192字节，即8KB，超过这个容量就必须在磁盘读取了。</p><p><strong>代码示例</strong>：使用缓冲流复制图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://1.png&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://2.png&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">// 读取和写入字节数据</span></span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果就是 D盘多了一个2.png图片</span></span><br></pre></td></tr></table></figure><hr><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><strong>字符流的继承关系：</strong></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250722203910877.png" alt="image-20250722203910877"></p><h2 id="字符流的编码和解码"><a href="#字符流的编码和解码" class="headerlink" title="字符流的编码和解码"></a>字符流的编码和解码</h2><p><strong>为什么要用字符流</strong></p><p>因为字节流编码不支持汉字。 计算机底层存储数据都是通过二进制的字节文件存储的，所以我们看到的文件信息都是有多少字节、多少KB、多少MB，文本文件需要设置编码是UTF-8、GBK等类型。</p><blockquote><p>GBK编码，一个汉字占用2个字节。<br>utf-8编码，一个汉字占用3个字节。</p></blockquote><p>一个英文字符占一个字节，一个汉字占多个字节，因为字节流都是单字节读取，所以字节流在读中文的时候有可能会读到半个中文,造成乱码，所以这就引入了字符流。</p><p><strong>字符流对字节文件进行编码和解码</strong>：</p><ul><li><strong>编码</strong>：字符输出流将字符编码为字节写入字节文件</li><li><strong>解码</strong>：字符输入流从字节文件解码出字符。 </li></ul><p>这样可以保证写入文件时，写入的格式是字节文件，读取文件时，将字节文件转为字符文件。</p><blockquote><p><strong>字符串的编码解码方法：</strong> 字符串的编码和解码是指在不同字符集之间转换字符数据的过程。</p><ul><li><strong>编码：</strong>将字符串转换为字节数组</li><li><strong>解码：</strong>将字节数组转换为字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = str.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 解码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">bytesToString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(bytesToString);</span><br><span class="line">    <span class="comment">// 如果编码设置的不对，设为GBK就会乱码：浣犲ソ</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">bytesToString2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    System.out.println(bytesToString2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 你好</span></span><br><span class="line"><span class="comment">// 浣犲ソ</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="字符输入输出流"><a href="#字符输入输出流" class="headerlink" title="字符输入输出流"></a>字符输入输出流</h2><h3 id="字符输出流OutputStreamWriter"><a href="#字符输出流OutputStreamWriter" class="headerlink" title="字符输出流OutputStreamWriter"></a>字符输出流OutputStreamWriter</h3><p><strong>OutputStreamWriter</strong>：将字符编码为字节，再写入字节文件。</p><p>OutputStreamWriter 是 Java 中一个桥接器类，用于将字符流转换为字节流。它使用指定的字符编码将字符写入字节流。它可以用于写入文件、网络流等。</p><blockquote><p> 桥接器类：指充当中介，用于连接或转换两种不兼容类型的类 </p></blockquote><p><strong>构造方法</strong>：构造参数都有OutputStream，因为要讲字符流编码成字节流OutputStream</p><ul><li><strong><code>OutputStreamWriter(OutputStream out)</code></strong>: 创建一个使用默认字符编码的 OutputStreamWriter。</li><li><strong><code>OutputStreamWriter(OutputStream out, String charsetName)</code></strong>: 创建一个使用指定字符编码的 OutputStreamWriter。</li><li><strong><code>OutputStreamWriter(OutputStream out, Charset cs)</code></strong>: 创建一个使用指定 Charset 的 OutputStreamWriter。</li><li>OutputStreamWriter(OutputStream out, CharsetEncoder enc): 创建一个使用指定 CharsetEncoder 的 OutputStreamWriter。</li></ul><p><strong>写入方法</strong></p><ul><li><strong><code>void write(int c)</code></strong>: 写入单个字符。</li><li><strong><code>void write(char[] cbuf, int off, int len)</code></strong>: 写入字符数组的一部分。</li><li><strong><code>void write(char[] cbuf)</code></strong>: 写入字符数组。</li><li><strong><code>void write(String str, int off, int len)</code></strong>: 写入字符串的一部分。</li><li><strong><code>void write(String str)</code></strong>: 写入整个字符串。</li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建文件输出流</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://output.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建使用 UTF-8 编码的 OutputStreamWriter</span></span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 写入字符串</span></span><br><span class="line">    osw.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    osw.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    osw.write(<span class="string">&quot;这是一个测试。&quot;</span>);</span><br><span class="line">    <span class="comment">// 刷新和关闭流</span></span><br><span class="line">    osw.flush();</span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文件中会出现以下两行</span></span><br><span class="line"><span class="comment">// Hello, World!</span></span><br><span class="line"><span class="comment">// 这是一个测试。</span></span><br></pre></td></tr></table></figure><h3 id="字符输入流InputStreamReader"><a href="#字符输入流InputStreamReader" class="headerlink" title="字符输入流InputStreamReader"></a>字符输入流InputStreamReader</h3><p><code>InputStreamReader</code> 是 Java 中一个桥接器类，用于从字节文件解码出字符。因为计算机底层存储的数据都是二进制的字节码文件，所以我们要读取文本文件，就需要将其根据编码解析成字符流，才能读取文件中的内容。</p><p><strong>构造方法</strong>：构造参数都有InputStream，因为InputStreamReader作用是将字节文件转为字符</p><ul><li><strong><code>InputStreamReader(InputStream in)</code></strong>: 使用默认字符集将给定的输入流 in 转换为字符流。</li><li><strong><code>InputStreamReader(InputStream in, Charset cs)</code></strong>: 使用指定的字符集 cs 将给定的输入流 in 转换为字符流。</li></ul><p><strong>读取字符</strong>：</p><ul><li><strong><code>int read()</code></strong>: 读取单个字符并返回其 Unicode 编码，如果到达流的末尾，则返回 -1。</li><li><strong><code>int read(char[] cbuf, int offset, int length)</code></strong>: 字符读入数组 cbuf，从 offset 位置开始存放，最多读取 length 个字符。</li></ul><p><strong>其他方法</strong>：</p><ul><li><strong><code>void mark(int readAheadLimit)</code></strong>: 标记流的当前位置，最多可以在流中读取 readAheadLimit 个字符。</li><li><strong><code>void reset()</code></strong>: 将流重置到最后一次标记的位置。</li><li><strong><code>boolean markSupported()</code></strong>: 测试此输入流是否支持标记功能。</li><li><strong><code>void close()</code></strong>: 关闭流并释放与之关联的所有系统资源。</li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建文件输入流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://output.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建使用 UTF-8 编码的 InputStreamReader</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 读取文件内容并输出</span></span><br><span class="line">    <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">while</span> ((length = isr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Hello, World!</span></span><br><span class="line"><span class="comment">// 这是一个测试。</span></span><br><span class="line"><span class="comment">// 进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h2 id="FileWriter和FileReader：简化字符流"><a href="#FileWriter和FileReader：简化字符流" class="headerlink" title="FileWriter和FileReader：简化字符流"></a>FileWriter和FileReader：简化字符流</h2><p><code>FileWriter</code>是OutputStreamWriter的子类，<code>FileReader</code>是InputStreamReader的子类。这两个类的作用是简化字符输入输出流的构造方法。</p><p>看看FileReader的源码，可以看到它继承了InputStreamReader类，并且只有三个构造方法，这几个构造方法封装了<code>super(new FileInputStream(fileName或者file));</code>，从而可以让我们直接将文件名或者File对象作为构造参数，而不需要再麻烦的创建一个FileInputStream对象，再将它作为构造参数创建InputStreamReader对象了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(FileDescriptor fd)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面两段代码效果是一样的，都是创建字符输入流，明显FileReader更方便：</p><p><strong>InputStreamReader创建字符输入流方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件输入流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://output.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 创建使用 UTF-8 编码的 InputStreamReader</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>FileReader创建字符输入流方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;output.txt&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><p>除了构造方法外，其他方法和他们的父类一致，这里不再赘述。</p><p><strong><code>FileReader</code>构造方法</strong></p><ul><li><strong><code>FileReader(String fileName)</code></strong>: 创建一个新的 FileReader，读取指定文件。</li><li><strong><code>FileReader(File file)</code></strong>: 创建一个新的 FileReader，读取指定的 File 对象。</li></ul><p><strong><code>FileWriter</code>构造方法</strong></p><ul><li><p><strong><code>FileWriter(String fileName)</code></strong>: 创建一个使用默认字符编码的 FileWriter，将数据写入指定文件。如果文件不存在，则创建新文件；如果文件存在，则覆盖原有内容。</p></li><li><p><strong><code>FileWriter(String fileName, boolean append)</code></strong>: 创建一个使用默认字符编码的 FileWriter，将数据写入指定文件。若 append 为 true，则在文件末尾追加内容，而不是覆盖。</p></li><li><p><strong><code>FileWriter(File file)</code></strong>: 创建一个 FileWriter，将数据写入指定的 File 对象。</p></li><li><p><strong><code>FileWriter(File file, boolean append)</code></strong>: 创建一个 FileWriter，将数据写入指定 File 对象，并选择是否在文件末尾追加。</p></li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 写文件</span></span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">    writer.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    writer.write(<span class="string">&quot;\nWelcome to Java FileWriter.&quot;</span>);</span><br><span class="line">    writer.close();</span><br><span class="line">    <span class="comment">// 读文件</span></span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> character;</span><br><span class="line">    <span class="keyword">while</span> ((character = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) character);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Hello, World!</span></span><br><span class="line"><span class="comment">// Welcome to Java FileWriter</span></span><br></pre></td></tr></table></figure><h2 id="字符缓冲流（推荐）"><a href="#字符缓冲流（推荐）" class="headerlink" title="字符缓冲流（推荐）"></a>字符缓冲流（推荐）</h2><p><code>BufferedWriter</code>和<code>BufferedReader</code>是带缓冲区的字符流，读写效率相对于普通的字符流OutputStreamWriter和InputStreamReader会高很多。</p><p><strong>为什么字符缓冲流读写效率高？</strong></p><p>原因跟字节缓冲流类似，它维护了默认容量8192容量的char类型数组，在写入时会将字符先写进这个存于内存的数组中，等容量满了之后，会一次性将数据写进磁盘，而不是每次写数据都进行磁盘IO一次，有效降低了读写次数，又因为磁盘的IO效率是远低于内存IO效率的，所以字符缓冲流的写效率高。</p><p><code>BufferedReader</code>也一个道理，它在第一次读的时候将数据尽可能多的塞满char类型数组，下次读的时候优先从char数组中读，读的效率肯定比直接在磁盘中读的效率高很多。</p><p><strong>BufferedWriter</strong></p><p><strong>构造方法</strong></p><ul><li><p>BufferedWriter(Writer out): 创建一个使用默认大小输出缓冲区的缓冲字符输出流。默认值8192足够大，可用于大多数用途。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedWriter</span><span class="params">(Writer out)</span> &#123;</span><br><span class="line">    <span class="comment">// 没指定缓冲区容量时，默认是最大长度8192</span></span><br><span class="line">    <span class="built_in">this</span>(out, defaultCharBufferSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BufferedWriter(Writer out, int sz): 创建一个使用指定大小输出缓冲区的缓冲字符输出流。参数sz可以指定缓冲区大小，或者可以接受默认大小8192。</p></li></ul><p><strong>常用方法</strong></p><ul><li><p><strong><code>void write(int c)</code></strong>: 写入单个字符。</p></li><li><p><strong><code>void write(char[] cbuf, int off, int len)</code></strong>: 写入字符数组的某一部分。</p></li><li><p><strong><code>void write(String s, int off, int len)</code></strong>: 写入字符串的某一部分。</p></li><li><p><strong><code>void newLine()</code></strong>: 写入一个行分隔符。</p></li><li><p>```java<br>public void newLine() throws IOException {</p><pre><code>// lineSeparator是本类的一个属性，在构造函数执行时获取当前操作系统的行分隔符并赋值write(lineSeparator);</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **`void flush()`: 刷新该流的缓冲区。**每次写完bw.flush();可以将缓冲字符写入文本，虽然close()也能刷新后关闭，但加上flush更保险。</span><br><span class="line"></span><br><span class="line">- **`void close()`**: 关闭该流，但要先刷新它。</span><br><span class="line"></span><br><span class="line">**BufferedReader**</span><br><span class="line"></span><br><span class="line">**构造方法**：可以指定缓冲区大小，或者可以使用默认大小8192。 默认值足够大，可用于大多数用途。</span><br><span class="line"></span><br><span class="line">- **`BufferedReader(Reader in)`**: 创建一个使用默认大小输入缓冲区的缓冲字符输入流。</span><br><span class="line">- **`BufferedReader(Reader in, int sz)`**: 创建一个使用指定大小输入缓冲区的缓冲字符输入流。</span><br><span class="line"></span><br><span class="line">**常用方法**</span><br><span class="line"></span><br><span class="line">- **`int read()`**: 读取单个字符。</span><br><span class="line">- **`int read(char[] cbuf, int off, int len)`**: 将字符读入数组的某一部分。</span><br><span class="line">- **`String readLine()`**: 读取一个文本行。</span><br><span class="line">- **`boolean ready()`**: 判断输入流是否准备好被读取。</span><br><span class="line">- **`void close()`**: 关闭该流并释放与之关联的所有资源。</span><br><span class="line"></span><br><span class="line">**代码示例**： </span><br><span class="line"></span><br><span class="line">BufferedWriter写入三行文字，然后BufferedReader读出来：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 定义文件路径</span><br><span class="line">    String filePath = &quot;example.txt&quot;;</span><br><span class="line">    // 使用 BufferedWriter 写文件</span><br><span class="line">    // 使用JDK7的异常处理形式，就不需要finally里关闭流对象了，出异常后系统会自动关闭</span><br><span class="line">    try (BufferedWriter bw = new BufferedWriter(new FileWriter(filePath))) &#123;</span><br><span class="line">        bw.write(&quot;你好&quot;);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(&quot;世界&quot;);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(&quot;宇宙&quot;);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // 实际场景建议用logger.error()，而不是e.printStackTrace()</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用 BufferedReader 读文件</span><br><span class="line">    try (BufferedReader br = new BufferedReader(new FileReader(filePath))) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果</span><br><span class="line">// 你好</span><br><span class="line">// 世界</span><br><span class="line">// 宇宙</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>BufferedReader实现读取键盘录入：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 InputStreamReader 包装 System.in，再使用 BufferedReader 包装 InputStreamReader</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    <span class="comment">// 提示用户输入</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一些文字：&quot;</span>);</span><br><span class="line">    <span class="comment">// 读取用户输入并输出</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;你输入的是：&quot;</span> + input);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭 BufferedReader</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// 请输入一些文字:</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 你输入的是:123</span></span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="I-O流JDK7异常处理"><a href="#I-O流JDK7异常处理" class="headerlink" title="I/O流JDK7异常处理"></a>I/O流JDK7异常处理</h1><p><strong>I/O流的异常处理：</strong></p><p>JDK7之前的常规做法：try…catch…finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类名 变量名) &#123;</span><br><span class="line">    <span class="comment">// 异常的处理代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 执行所有清除操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK7改进方案：try-with-resources</p><blockquote><p>因为之前方案，每次都要finally中再次判空、try-catch区关闭IO流，太过麻烦，所以JDK7引入了新的异常处理形式，可以<strong>把流对象放到try()的括号里</strong>，这样就不需要再写finally了，系统会自动释放资源</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (定义流对象) &#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类名 变量名) &#123;</span><br><span class="line">    <span class="comment">// 异常的处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动释放资源</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>代码示例:</strong></p><p>使用字符缓冲流写文件后，读文件：</p><p><strong>JDK7之前格式：</strong></p><p>异常处理后，需要在finally里关闭流对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"> <span class="comment">// 使用 BufferedWriter 写文件</span></span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath));</span><br><span class="line">        bw.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;Welcome to Java BufferedWriter.&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;This is an example of BufferedWriter.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 实际场景建议用logger.error()，而不是e.printStackTrace()</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 关闭流时也需要异常处理，防止关闭失败</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 使用 BufferedReader 读文件</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>JDK7格式：</strong></p><p>异常处理后，不需要再写finally了，系统会自动释放资源，可以看到代码变简洁很多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 定义文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用 BufferedWriter 写文件</span></span><br><span class="line">    <span class="comment">// 使用JDK7的异常处理形式，就不需要finally里关闭流对象了，出异常后系统会自动关闭</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath))) &#123;</span><br><span class="line">        bw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;宇宙&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 实际场景建议用logger.error()，而不是e.printStackTrace()</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 BufferedReader 读文件</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath))) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="特殊操作流"><a href="#特殊操作流" class="headerlink" title="特殊操作流"></a>特殊操作流</h1><h2 id="标准输入输出流：System-in和System-out"><a href="#标准输入输出流：System-in和System-out" class="headerlink" title="标准输入输出流：System.in和System.out"></a>标准输入输出流：System.in和System.out</h2><p> <strong>什么是标准输入输出流？</strong></p><ul><li>标准输出流：System.out。用于指定输出到控制台的数据。</li><li>标准输入流：System.in。用于读取用户在控制台输入的数据。</li></ul><h3 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a><strong>标准输出流</strong></h3><p><strong>基本介绍</strong></p><p>标准输出流：System.out。用于往控制台输出数据。</p><p><strong>常用方法：</strong></p><ul><li><strong>print()</strong>: 打印数据到控制台，不换行。</li><li><strong>println()</strong>: 打印数据到控制台，并换行。</li><li><strong>printf()</strong>: 使用指定的格式字符串和参数将数据格式化并打印到控制台。 </li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 输出 &quot;Hello, &quot; 不换行</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        <span class="comment">// 输出 &quot;World!&quot; 并换行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用格式化输出</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;数字: %d&quot;</span>, <span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用格式化符号<br>使用System.out、String.format可以对字符串格式化。</p><p>常用格式化符号</p><blockquote><p>%d：十进制整数<br>%f：十进制浮点数<br>%e：科学计数法表示的十进制数<br>%g：根据值的大小，自动选择使用普通计数法或科学计数法<br>%s：字符串<br>%c：字符<br>%b：布尔值（true 或 false）<br>%x：整数的十六进制表示<br>%o：整数的八进制表示<br>%t 或 %T：日期和时间（需要与日期时间转换符配合使用）<br>%%：文字百分号（% 本身）</p></blockquote><p>日期和时间转换符</p><blockquote><p>%tF：年-月-日（yyyy-MM-dd）<br>%tD：月/日/年（MM/dd/yy）<br>%tT：时:分:秒（HH:mm:ss）<br>%tR：时:分（HH:mm）<br>%tY：年（四位数）<br>%ty：年（两位数）<br>%tm：月（两位数）<br>%td：日（两位数）<br>%tH：小时（24 小时制，两位数）<br>%tI：小时（12 小时制，两位数）<br>%tM：分钟（两位数）<br>%tS：秒（两位数）<br>%tp：小写上午或下午标记（am 或 pm）<br>%tZ：时区</p></blockquote><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14159</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 格式化输出整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;整数：%d\n&quot;</span>, number);</span><br><span class="line">        <span class="comment">// 格式化输出浮点数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;浮点数（两位小数）：%.2f\n&quot;</span>, pi);</span><br><span class="line">        <span class="comment">// 格式化输出字符串</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;名字：%s\n&quot;</span>, name);</span><br><span class="line">        <span class="comment">// 格式化输出布尔值</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;布尔值：%b\n&quot;</span>, flag);</span><br><span class="line">        <span class="comment">// 格式化输出十六进制整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;十六进制：%x\n&quot;</span>, number);</span><br><span class="line">        <span class="comment">// 格式化输出八进制整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;八进制：%o\n&quot;</span>, number);</span><br><span class="line">        <span class="comment">// 格式化输出百分比</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">percentage</span> <span class="operator">=</span> <span class="number">0.85</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;百分比：%.2f%%\n&quot;</span>, percentage * <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 左对齐和宽度格式化</span></span><br><span class="line">        <span class="comment">// %-10s 用于左对齐并指定宽度为10的字符串</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;左对齐：%-10s|\n&quot;</span>, name);</span><br><span class="line">        <span class="comment">// 右对齐和宽度格式化</span></span><br><span class="line">        <span class="comment">// %10s 用于右对齐并指定宽度为10的字符串</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;右对齐：%10s|\n&quot;</span>, name);</span><br><span class="line">        <span class="comment">// 格式化输出带符号的数值</span></span><br><span class="line">        <span class="comment">// %+d 用于格式化带符号的整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;带符号的整数：%+d\n&quot;</span>, -number);</span><br><span class="line">        <span class="comment">// %+.2f 用于格式化带符号的浮点数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;带符号的浮点数：%+.2f\n&quot;</span>, pi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h3><p><strong>基本介绍</strong></p><p><strong>标准输入流</strong>：System.in。用于读取用户在控制台输入的数据。</p><p><strong>用法：</strong></p><ul><li><strong>字符输入流：</strong>作为构造参数传入字符输入流InputStreamReader中，例如new InputStreamReader(System.in)。</li><li><strong>Scanner：</strong>因为用字符输入流包装太麻烦，所以Java提供了一个工具类实现键盘录入，即Scanner类，专门用于从各种输入源（如控制台、文件、字符串等）读取输入。</li></ul><p><strong>常用方法：</strong></p><ul><li><strong>read()</strong>: 从输入流中读取一个字节。</li><li><strong>read(byte[] b)</strong>: 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</li><li><strong>read(byte[] b, int off, int len)</strong>: 从输入流中将 len 个字节的数据读入一个字节数组。</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 BufferedReader 包装 System.in</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    <span class="comment">// 提示用户输入</span></span><br><span class="line">    System.out.print(<span class="string">&quot;随便输入一些文字: &quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取用户输入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="comment">// 输出用户输入</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你输入的内容是： &quot;</span> + text);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 实际场景不建议e.printStackTrace()，而是logger.error()</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Scanner类</strong></p><p>因为用字符输入流包装太麻烦，所以Java提供了一个工具类实现键盘录入，即Scanner类，专门用于从各种输入源（如控制台、文件、字符串等）读取输入。</p><p><strong>构造方法：</strong></p><ul><li><strong>Scanner(InputStream source):</strong> 构造一个新的 Scanner，生成的扫描器从指定的输入流读取数据。用于读取用户在控制台输入的数据。一般用System.in，即标准输入流，用于读取用户在控制台输入的数据。</li><li>Scanner(File source): 构造一个新的 Scanner，生成的扫描器从指定的文件读取数据。</li><li>Scanner(String source): 构造一个新的 Scanner，生成的扫描器从指定的字符串读取数据。</li></ul><p><strong>常用方法：</strong></p><ul><li><strong>nextInt()、nextDouble()、next()：</strong>获取输入的整数、浮点数、字符串（不包括空格）等。</li><li><strong>nextLine()：</strong>获取一行输入（包括空格）。</li><li><strong>hasNextInt()、hasNextDouble()、hasNext()：</strong> 判断下一个输入是否为整数、浮点数、字符串。</li><li><strong>useDelimiter(String pattern)：</strong> 设置分隔符模式，用于指定不同类型数据之间的分隔符，默认为空白字符。</li><li><strong>close()：</strong>关闭扫描器。</li></ul><blockquote><p><strong>示例：</strong></p><p>从控制台输入整数、浮点数、字符串，并在控制台打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象，关联 System.in（标准输入流）</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 从控制台读取整数</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter an integer: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + intValue);</span><br><span class="line">        <span class="comment">// 从控制台读取浮点数</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter a double: &quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + doubleValue);</span><br><span class="line">        <span class="comment">// 从控制台读取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringValue</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;You entered: &quot;</span> + stringValue);</span><br><span class="line">        <span class="comment">// 关闭 Scanner 对象</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><h3 id="字节打印流：PrintStream"><a href="#字节打印流：PrintStream" class="headerlink" title="字节打印流：PrintStream"></a>字节打印流：PrintStream</h3><p>PrintStream用于将不同的数据类型格式化为字节并写入到输出流，支持自动刷新。它只负责输出数据，不负责读取数据。</p><p>一般情况下，打印数据用System.out.printf()就可以了，PrintStream适用于需要重定向输出的场景，例如将打印的结果写入一个文件中。</p><blockquote><p> <strong>重定向输出：</strong>将输出重定向到文件、网络流或其他输出目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))) &#123;</span><br><span class="line">        ps.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        ps.println(<span class="number">123</span>);</span><br><span class="line">        ps.println(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>构造方法：</strong></p><ul><li><strong>PrintStream(OutputStream out):</strong> 创建一个新的打印流，使用指定的输出流。</li><li>PrintStream(OutputStream out, boolean autoFlush): 创建一个新的打印流，使用指定的输出流和自动刷新设置。</li><li>PrintStream(OutputStream out, boolean autoFlush, String encoding): 创建一个新的打印流，使用指定的输出流、自动刷新设置和字符编码。</li><li>PrintStream(String fileName): 创建一个新的打印流，使用指定的文件名。</li><li>PrintStream(String fileName, String encoding): 创建一个新的打印流，使用指定的文件名和字符编码。</li><li>PrintStream(File file): 创建一个新的打印流，使用指定的文件。</li><li>PrintStream(File file, String encoding): 创建一个新的打印流，使用指定的文件和字符编码。</li></ul><p><strong>常用方法：</strong></p><ul><li>void print(String s): 打印字符串。</li><li>PrintStream printf(String format, Object… args): 使用指定的格式字符串和参数，将格式化的字符串输出到该流。</li><li>void println(int i): 打印整数并换行。</li><li>close()：关闭。</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印到控制台：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// true 表示自动刷新</span></span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(System.out, <span class="literal">true</span>);</span><br><span class="line">    ps.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    ps.println(<span class="string">&quot;Hello, World2!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印到文件：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    PrintStream pw= <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pw = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    pw.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    pw.println(<span class="number">23</span>);</span><br><span class="line">    pw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符打印流：PrintWriter"><a href="#字符打印流：PrintWriter" class="headerlink" title="字符打印流：PrintWriter"></a>字符打印流：PrintWriter</h3><p>PrintWriter与 PrintStream 类似，都用于打印数据到文件。主要区别是PrintWriter用于打印字符流，而不是字节流，它可以自动处理字符编码。 </p><p><strong>构造方法</strong>：</p><ul><li><p>PrintWriter(OutputStream out): 创建一个新的 PrintWriter，从现有的 OutputStream 输出字符。</p></li><li><p>PrintWriter(OutputStream out, boolean autoFlush): 创建一个新的 PrintWriter，从现有的 OutputStream 输出字符，并指定是否在调用 println、printf 或 format 方法时自动刷新。</p></li><li><p><strong>PrintWriter(Writer out):</strong> 创建一个新的 PrintWriter，从现有的 Writer 输出字符。</p></li><li><p>PrintWriter(Writer out, boolean autoFlush): 创建一个新的 PrintWriter，从现有的 Writer 输出字符，并指定是否在调用 println、printf 或 format 方法时自动刷新。</p></li><li><p><strong>PrintWriter(String fileName):</strong> 创建一个新的 PrintWriter，将输出写入指定的文件。</p></li><li><p>PrintWriter(String fileName, String csn): 创建一个新的 PrintWriter，将输出写入指定的文件，使用给定的字符集。</p></li><li><p>PrintWriter(File file): 创建一个新的 PrintWriter，将输出写入指定的文件。</p></li><li><p>PrintWriter(File file, String csn): 创建一个新的 PrintWriter，将输出写入指定的文件，使用给定的字符集。</p></li></ul><p><strong>常用方法：</strong></p><ul><li>跟PrintStream基本一致，这里不再赘述。 </li></ul><p><strong>代码示例：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//自动刷新true</span></span><br><span class="line">    PrintWriter pw=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//直接写一行加刷新</span></span><br><span class="line">    pw.println(<span class="string">&quot;hello&quot;</span>);        </span><br><span class="line">    pw.println(<span class="number">23</span>);</span><br><span class="line">    pw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列号流和反序列化流"><a href="#序列号流和反序列化流" class="headerlink" title="序列号流和反序列化流"></a>序列号流和反序列化流</h2><h3 id="Serializable-接口和serialVersionUID变量"><a href="#Serializable-接口和serialVersionUID变量" class="headerlink" title="Serializable 接口和serialVersionUID变量"></a>Serializable 接口和serialVersionUID变量</h3><p><strong>序列化和反序列化：</strong></p><ul><li><strong>序列化：</strong>将对象转换为字节流。转为字节流后可以把它写入文件、数据库，或者传输到网络中。</li><li><strong>反序列化：</strong>序列化的逆过程，也就是将字节流转换回对象。</li></ul><p><strong>不参与序列化的字段：</strong>被transient修饰的成员变量不参与序列化。 </p><p>被序列化的类必须实现Serializable接口，并且声明一个成员变量<strong>serialVersionUID</strong>。 </p><p><strong>Serializable 接口：</strong></p><p>用于标记一个类的对象可被序列化。该接口没有任何方法，它仅仅是一个标记，表明实现这个接口的类可以被 Java 的序列化机制处理。 </p><p>若一个类的对象没有实现这个接口，并且他的对象被序列号，则会报错不能序列号异常<code>java.io.NotSerializableException</code></p><p><strong>erialVersionUID变量：</strong></p><ul><li><strong>作用：</strong>serialVersionUID是类的版本号，类型是长整型数值，该字段的主要作用是检查反序列化时类的版本，与序列化时类的版本是否一致。</li><li><strong>私有：</strong>为了保证不同Java编译器实现之间的一致的serialVersionUID值，一个可序列化的类必须声明一个显式的serialVersionUID值，尽量使用private修饰符。</li><li><strong>序列化类必须包含serialVersionUID：</strong>为了保证不同Java编译器实现之间的一致的serialVersionUID值，一个可序列化的类必须声明一个显式的serialVersionUID值，尽量使用private修饰符。</li><li><strong>建议手动指定</strong>：如果实现了Serializable接口，并且没有指定serialVersionUID，编译器会隐式地自动生成一个serialVersionUID，但是建议手动指定，因为默认的serialVersionUID计算对类详细信息非常敏感，从而出现<strong>InvalidClassException</strong>。</li></ul><p><strong>InvalidClassException异常：</strong></p><p>序列化时版本号不匹配，会抛出无效类异常。例如反序列化时类的版本号，与序列化时类的版本号不一致在序列化之后，类的结构发生了变化，例如添加、删除或修改了字段，导致版本号不匹配。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可序列号的Dog类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// ... 其他定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象序列化流：ObjectOutputStream"><a href="#对象序列化流：ObjectOutputStream" class="headerlink" title="对象序列化流：ObjectOutputStream"></a>对象序列化流：ObjectOutputStream</h3><p>序列化流可以将对象转换为字节流，并保存到文件或者传输到网络。</p><p><strong>构造方法：</strong></p><ul><li><strong>ObjectOutputStream(OutputStream out):</strong> 创建一个写入指定 OutputStream 的 ObjectOutputStream。构造参数是FileOutputStream等OutputStream的子类。</li></ul><p><strong>常用方法：</strong></p><ul><li><strong>void writeObject(Object obj):</strong> 将指定的对象写入 ObjectOutputStream。</li><li>void close(): 关闭输出流并释放与此流相关联的所有系统资源。</li><li>void flush(): 刷新输出流，并强制任何缓冲的输出字节被写出。</li></ul><p><strong>代码示例：</strong>被序列化的类使用上一节创建的Dog类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">5</span>, <span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用JDK7的异常捕获，不需要手动关闭流</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dog.txt&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(dog);</span><br><span class="line">            System.out.println(<span class="string">&quot;序列化完成：&quot;</span> + dog);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象反序列化流：ObjectInputStream"><a href="#对象反序列化流：ObjectInputStream" class="headerlink" title="对象反序列化流：ObjectInputStream"></a>对象反序列化流：ObjectInputStream</h3><p>ObjectInputStream是序列化的逆过程，也就是将字节流转换回对象。</p><p><strong>构造方法</strong></p><ul><li>ObjectOutputStream(OutputStream out): 创建一个写入指定 OutputStream 的 ObjectOutputStream。</li></ul><p><strong>常用方法</strong></p><ul><li>void writeObject(Object obj): 将指定的对象写入 ObjectOutputStream。</li><li>void close(): 关闭输出流并释放与此流相关联的所有系统资源。</li><li>void flush(): 刷新输出流，并强制任何缓冲的输出字节被写出。</li></ul><p><strong>代码示例：</strong>反序列化上一节创建的dog.txt：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dog.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;反序列化完成：&quot;</span> + dog);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 反序列化完成:Dog&#123;weight=0,name=&quot;旺财&quot;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java.io是Java编程语言中处理输入输出（I/O）操作的核心类库，定义了数据流模型与多种接口，支持文件操作、网络通信及对象序列化等功能。其通过流（Stream）机制实现数据传输，涵盖字节流、字符流与缓冲处理等设计，为Java标准库的重要组成部分。&lt;/p&gt;
&lt;p&gt;该库将</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java中的泛型</title>
    <link href="https://southernfish.github.io/2025/07/23/java/java-base-6-generics/"/>
    <id>https://southernfish.github.io/2025/07/23/java/java-base-6-generics/</id>
    <published>2025-07-23T14:58:36.000Z</published>
    <updated>2025-07-23T14:34:27.991Z</updated>
    
    <content type="html"><![CDATA[<p>Java泛型是J2 SE1.5中引入的一个新特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在<a href="https://baike.baidu.com/item/%E7%B1%BB/6824577?fromModule=lemma_inlink">类</a>、<a href="https://baike.baidu.com/item/%E6%8E%A5%E5%8F%A3/15422203?fromModule=lemma_inlink">接口</a>和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/137256095">https://blog.csdn.net/qq_40991313/article/details/137256095</a></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>泛型，即<strong>参数化类型</strong>。泛型的出现是为了<em>统一集合当中的数据类型</em>。可<em>在编译阶段约束操作的数据类型，并进行检查</em><br><strong>参数化类型：</strong>在方法定义时，<em>将方法签名中的形参数据类型设置为参数</em>（可称之为类型参数：尖括号 &lt;&gt; 中的泛型标识，用于指代任何数据类型），调用该方法时再从外部传入一个具体的数据类型和变量。</p><p><strong>泛型的本质</strong></p><p>将类、接口和方法中具体的类型参数化，并且提供了编译时类型安全检测机制。通过使用泛型，可以避免使用Object类导致的类型转换错误和减少了代码的冗余。泛型使用过程中，数据类型被设置为一个参数，<strong>使用时从外部传入一个数据类型</strong>；而一旦传入了具体的数据类型后，<strong>传入变量（实参）的数据类型若不匹配，编译器就会直接报错</strong>。这种参数化类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。<br><strong>细节：</strong>不能写基本数据类型；指定泛型具体类型后，传递数据时可传该类型和其子类类型；若不写泛型，默认是Object。</p><p><strong>使用场景：</strong>定义类、方法、接口的时候，若类型不确定，可定义泛型；<em>若类型不确定，但知道继承体系，可用泛型通配符 ？</em></p><blockquote><p><strong>注意</strong>：泛型不具备继承性，但数据具备继承性 </p></blockquote><p><strong>泛型的标志</strong></p><p>尖括号<code>&lt;&gt;</code>是泛型的标志，例如<code>ArrayList&lt;E&gt;</code>就是一个泛型，<code>&lt;E&gt;</code>将实际的集合元素类型参数化了，这样我们使用时可以指定<code>new ArrayList&lt;String&gt;</code>，将它指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList&lt;E&gt;是标准的类泛型，在使用时指定这个“E”具体是什么</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在使用ArrayList时，尖括号指定&lt;String&gt;，这样它就只能存String类型的元素了</span></span><br><span class="line"><span class="comment">// 一旦存其他类型，就会在代码下面出现红色波浪线，编译期间就报错</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>若不用泛型，而用<code>public class ArrayList&lt;Object&gt;&#123;&#125;</code>方式声明ArrayList，就可往集合里存所有类型的参数，编译不报错，但可读性很差，不知道它具体应存哪些类型，存的类型非业务所需类型时，编译期间不报错，直到生产环境运行时报错，就会出现不好的影响。</p><p><strong>详细介绍：</strong></p><p><strong>泛型</strong>：将具体的类型参数化，是一种编程范式，提供了编译时类型安全检测机制。</p><p>通过使用泛型，可以将数据类型作为参数传递给类、接口或方法，可以在编译时期进行类型检查，避免在运行时期出现类型转换错误。</p><p><strong>泛型的范围</strong>：泛型接口，泛型类（创建对象时再指定具体类型），泛型方法。</p><p><strong>实现方式</strong>：以泛型类举例。只需要在类名后面使用尖括号&lt;&gt;将一个符号或多个符号包裹起来，这样在类里面就可以使用该符号代替具体类型了。使用泛型类时，调用者实际传进来什么类型，编译时就会将泛型符号擦除，替换成这个实际类型。</p><p><strong>泛型标识：</strong>泛型符号可以是任意符号，但我们约定使用<code>T、E、K、V</code>等符号。Java 常见泛型标识及其代表含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T ：代表一般的任何类。</span><br><span class="line">E ：代表 Element 元素的意思，或者 Exception 异常的意思。</span><br><span class="line">K ：代表 Key 的意思。</span><br><span class="line">V ：代表 Value 的意思，通常与 K 一起配合使用。</span><br><span class="line">S ：代表 Subtype 的意思。</span><br></pre></td></tr></table></figure><hr><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="泛型参数类型"><a href="#泛型参数类型" class="headerlink" title="泛型参数类型"></a>泛型参数类型</h2><p>我们可以看见，前面 ArrayList<E>，尖括号内是“E”，然后我们可能看见其他泛型尖括号内是“T”，具体是哪个大写字母，其实并没有特定的要求，只是遵循了某些约定俗成的惯例。</p><p><strong>泛型参数类型的惯例</strong>：</p><ul><li>**<code>&lt;E&gt;</code>**：表示元素（Element），通常在集合类中使用。例如，List<E>，Set<E>。</li><li>**<code>&lt;T&gt;</code>**：表示类型（Type），通常在一般类型中使用。例如，Box<T>，Comparable<T>。</li><li>**<code>&lt;K&gt;</code> 和 <code>&lt;V&gt;</code>**：分别表示键（Key）和值（Value），通常在映射（Map）类中使用。例如，Map&lt;K, V&gt;，Entry&lt;K, V&gt;。</li><li>**<code>&lt;N&gt;</code>**：表示数字（Number），在需要表示数字的泛型中使用。</li></ul><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类定义了一个泛型参数，创建对象时给它传入这个参数的实际类型。 <strong>格式：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList简化版</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 当前元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 构造方法，初始化数组和大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyList</span><span class="params">()</span> &#123;</span><br><span class="line">        elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[INITIAL_CAPACITY];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前数组容量不足，则扩容</span></span><br><span class="line">        <span class="keyword">if</span> (size == elementData.length) &#123;</span><br><span class="line">            grow();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将元素添加到数组中，并增加元素数量</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定位置的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> E &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查索引是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span> + index + <span class="string">&quot;, Size: &quot;</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回元素，强制转换为泛型类型</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回当前元素数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容方法，将数组容量扩大 1.5 倍</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> elementData.length + (elementData.length &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyList&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">        myList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        myList.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        myList.add(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素数量: &quot;</span> + myList.size());</span><br><span class="line">        <span class="comment">// 输出: 第一个元素: Hello</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个元素: &quot;</span> + myList.get(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 输出: 第二个元素: World</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二个元素: &quot;</span> + myList.get(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 输出: 第三个元素: !</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第三个元素: &quot;</span> + myList.get(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 尝试获取索引越界的元素，抛出 IndexOutOfBoundsException</span></span><br><span class="line">        <span class="comment">// System.out.println(myList.get(3));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口和泛型类类似，也是定义了一个泛型参数。不同的点是，泛型接口在被实现或者被继承时需要指定具体类型。</p><p><strong>如果泛型接口的实现类不是泛型</strong>：</p><ul><li>实现泛型接口时，如果没有省略尖括号“&lt;&gt;”，则必须在接口“&lt;&gt;”中指定类型</li><li>实现泛型接口时，如果省略了尖括号“&lt;&gt;”，则默认“&lt;&gt;”内是Object类</li></ul><p><strong>如果泛型接口的实现类是泛型</strong>：</p><ul><li>实现泛型接口时，实现类也必须是泛型类，并且类型与泛型接口保持一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口泛型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceName</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 接口中的方法可以使用类型参数T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGen</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果泛型接口的实现类不是泛型，实现泛型接口时，如果没有省略尖括号“&lt;&gt;”，则必须在接口“&lt;&gt;”中指定类型</span></span><br><span class="line"><span class="comment">// 泛型接口实现类必须指定具体类型，否则会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gen</span> <span class="keyword">implements</span> <span class="title class_">IGen</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果泛型接口的实现类不是泛型，实现泛型接口时，如果省略了尖括号“&lt;&gt;”，则默认“&lt;&gt;”内是Object类</span></span><br><span class="line"><span class="comment">// 泛型接口实现类：如果接口省略&lt;&gt;，则默认是Object</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gen</span> <span class="keyword">implements</span> <span class="title class_">IGen</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果参数不是Object，就报错。因为接口了省略&lt;&gt;，默认是IGen&lt;Object&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Object integer)</span> &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果泛型接口的实现类是泛型，实现泛型接口时，实现类也必须是泛型类，并且类型与泛型接口保持一致</span></span><br><span class="line"><span class="comment">// 泛型接口实现类也是泛型类时，泛型参数类型必须与泛型接口保持一致，用&lt;E&gt;，而不是&lt;T&gt;等</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gen</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">IGen</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>当在一个方法签名中的返回值前面声明了一个 &lt; T &gt; 时，该方法就被声明为一个泛型方法。</p><p>然后返回类型、参数类型都可以用这个<T>，当然也可以不用。<strong>格式：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法泛型</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; 返回类型 方法名(参数类型 parameter) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法1：返回值和参数可以T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> T &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fun1</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法1：参数可以是多个，但类型必须都是T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> T &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fun2</span><span class="params">(T a,T b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法2：返回值和参数并不一定是T，也可以是具体类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Integer &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">(Integer integer)</span>&#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="comment">// 实参传入String类型</span></span><br><span class="line">        System.out.println(test.fun1(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">        <span class="comment">// 实参传入int类型</span></span><br><span class="line">        System.out.println(test.fun1(<span class="number">1111</span>));</span><br><span class="line">        <span class="comment">// 实参传入多个String类型</span></span><br><span class="line">        System.out.println(test.fun2(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>));</span><br><span class="line">        test.fun3(<span class="number">2222</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h1><p>类型通配符跟泛型参数<code>&lt;T&gt;、&lt;E&gt;</code>等类似，用于表示不确定的类型，不同的点在于：</p><ul><li><strong>类型参数</strong>：用于声明泛型类、泛型接口或泛型方法。声明时是未知类型，使用时擦除成具体的类型（在编译时泛型擦除）。</li><li><strong>类型通配符</strong>：用于使用泛型时，表示一种未知的类型。</li></ul><p><strong>类型通配符有三种</strong>：</p><ul><li><code>&lt;?&gt; </code>：<strong>无限定的通配符</strong>。可用来表示任何类型。无限定通配符只能读Object类型的值，只能写null类型的值，其他类型都不能读写。</li><li><code>&lt;? extends T&gt;</code> ：<strong>有上界的通配符</strong>。表示继承自T的任何类型，这里上界指的就是T。它通常用于生产者，即返回T。上界通配符只允许读值，不允许写null以外值。</li><li><code>&lt;? super T&gt; </code>：<strong>有下界的通配符</strong>。表示子类是T的任何类型，这里下界指的就是T。它通常用于消费者，即写入T。下界类型通配符只允许写值，不允许读Object以外的值。</li></ul><h2 id="无限定类型通配符：-lt-gt"><a href="#无限定类型通配符：-lt-gt" class="headerlink" title="无限定类型通配符：&lt;?&gt;"></a>无限定类型通配符：&lt;?&gt;</h2><p>例如List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何类型。无限定通配符只能读Object类型的值，只能写null类型的值，其他类型都不能读写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        strings.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">        integers.add(<span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 1.无界通配符用作形参，实参可以是任意元素</span></span><br><span class="line">        <span class="comment">// 打印集合：List&lt;?&gt;可以接受所有List元素类型的实参</span></span><br><span class="line">        printList(strings);</span><br><span class="line">        printList(integers);</span><br><span class="line">        List&lt;?&gt; anyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 正确，因为无限定通配符可以写null类型的值。</span></span><br><span class="line">        anyList.add(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 下面代码会报错，因为无限定通配符只能读Object类型的值，只能写null类型的值，其他类型都不能读写。</span></span><br><span class="line">        <span class="comment">// anyList.add(23);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * * 打印集合：List&lt;?&gt;可以接受所有List元素类型的实参。Collection&lt;?&gt;可以接受任何类型任何元素类型的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上界类型通配符-List-lt-extends-指定类型-gt"><a href="#上界类型通配符-List-lt-extends-指定类型-gt" class="headerlink" title="上界类型通配符:List&lt;? extends 指定类型&gt;"></a>上界类型通配符:List&lt;? extends 指定类型&gt;</h2><p>表示继承自T的任何类型，这里上界指的就是T。它主要用于写入数据的场景。</p><p>上界类型通配符只允许读值，不允许写null以外的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    strings.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">    integers.add(<span class="number">23</span>);</span><br><span class="line">    <span class="comment">// 上界通配符可以接受继承于T的类，即T的子类</span></span><br><span class="line">    printNumbers(integers);</span><br><span class="line">    <span class="comment">// 下面会报错，因为上界通配符，元素类型只能是Number的子类</span></span><br><span class="line">    <span class="comment">// printNumbers(strings);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上界通配符可以接受继承于T的类，即T的子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 下面会报错，因为上界类型通配符只允许读值，不允许写null以外值。</span></span><br><span class="line">    <span class="keyword">for</span> (Number number : list) &#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下界类型通配符-List-lt-super-指定类型-gt"><a href="#下界类型通配符-List-lt-super-指定类型-gt" class="headerlink" title="下界类型通配符:List&lt;? super 指定类型&gt;"></a>下界类型通配符:List&lt;? super 指定类型&gt;</h2><p>表示子类是T的任何类型，这里下界指的就是T。它主要用于读取数据的场景。</p><p>下界类型通配符只允许写值，不允许读Object以外的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    strings.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">    integers.add(<span class="number">23</span>);</span><br><span class="line">    addNumbers(integers);</span><br><span class="line">    printList(integers);</span><br><span class="line">    <span class="comment">// 下面会报错，因为上界通配符，元素类型只能是Number的子类</span></span><br><span class="line">    <span class="comment">// printNumbers(strings);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * * 下界通配符可以接受实现了Integer接口的类，即Integer的父类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 正确。因为下界类型通配符允许写值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 下面会报错，因为下界类型通配符只允许写值，不允许读Object以外类型的值。</span></span><br><span class="line">    <span class="comment">// Number number=list.get(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>(int… a)是将所有int参数封装到a数组里。</p><p> 注意可变参数要放在后面。例如(int a,int… b)正确，(int… a,int b)会报错</p><p><strong>Arrays工具类中有一个静态方法：</strong></p><ul><li><code>public static &lt;T&gt; List&lt;T&gt; asList(T.. a)</code>：返回由指定数组支持的固定大小的列表</li><li>返回的集合不能做增删操作，可以做修改操作</li></ul><p><strong>List接口中有一个静态方法：</strong></p><ul><li><code>public static &lt;E&gt; List&lt;E&gt; of(E.. elements)</code>：返回包含任意数量元素的不可变列表</li><li>返回的集合不能做增删改操作</li></ul><p><strong>Set接口中有一个静态方法：</strong></p><ul><li><code>public static &lt;E&gt;Set&lt;E&gt;of([...elements)</code>：返回一个包含任意数量元素的不可变集合</li><li>在给元素的时候，不能给重复的元素</li><li>返回的集合不能做增删操作，没有修改的方法</li></ul><hr><h1 id="知识加油站"><a href="#知识加油站" class="headerlink" title="知识加油站"></a>知识加油站</h1><h2 id="泛型的向上转型"><a href="#泛型的向上转型" class="headerlink" title="泛型的向上转型"></a>泛型的向上转型</h2><p>泛型类或接口可以向上转型为父类，泛型符号不能向上转型。</p><p>泛型向上转型指的是将一个泛型对象转换为其父类类型或者接口类型的过程。这个过程实际上是将泛型对象的类型参数擦除，重新赋值为其父类或接口类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类或接口可以向上转型：ArrayList&lt;T&gt;可以向上转型为List&lt;T&gt;</span></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = arrayList;  <span class="comment">// 向上转型为 List&lt;Integer&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型符号不能向上转型：ArrayList&lt;Integer&gt;泛型不可以向上转化为ArrayList&lt;Number&gt;。因为ArrayList&lt;Number&gt;接收ArrayList&lt;float&gt;，但ArrayList&lt; Integer&gt;不可以接收ArrayList&lt; Float&gt;，不能转回来 </span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;  <span class="comment">// 编译错误：不能将 ArrayList&lt;Integer&gt; 向上转型为 ArrayList&lt;Number&gt;</span></span><br></pre></td></tr></table></figure><h2 id="泛型的向下转型"><a href="#泛型的向下转型" class="headerlink" title="泛型的向下转型"></a>泛型的向下转型</h2><p>向下转型和向上转型类似，指的是将一个父类类型的对象转换为子类类型的过程。这种转换需要进行类型检查，确保转换是安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = (ArrayList&lt;Integer&gt;) list;  <span class="comment">// 向下转型为 ArrayList&lt;Integer&gt;</span></span><br></pre></td></tr></table></figure><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p><strong>泛型擦除</strong>：java的泛型是伪泛型，因为<strong>java在编译期间，所有的泛型类型都会被擦掉，并转换为普通类型</strong>。  </p><p>泛型擦除的主要目的是为了<strong>向低版本兼容</strong>，因为Java泛型是在JDK 1.5之后才引入的特性，为了保证旧有的代码能正常运行，Java编译器采用了泛型擦除来兼容之前的代码。</p><h2 id="为什么要有泛型，而不是使用Object类"><a href="#为什么要有泛型，而不是使用Object类" class="headerlink" title="为什么要有泛型，而不是使用Object类"></a>为什么要有泛型，而不是使用Object类</h2><p>因为泛型是在编译时泛型擦除和替换实际类型的，而使用Object类会很麻烦，需要经常强制转换。</p><p>如List集合里，若直接声明存Object类，存的时候可通过多态机制直接向上转型，而取的时候就麻烦了，要强转Object类为String等对象，然后才能访问该对象的成员；而且不知道实际元素到底是String类型还是Integer等其他类型，还要通过<code>i instanceof String</code>判断类型，就更麻烦了。</p><h2 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h2><ul><li><strong>防止运行时报错</strong>：可以在编译时检查类型安全，防止在程序运行期间出现BUG。</li><li><strong>隐式转换</strong>：所有的强制转换都是自动和隐式的，可以提高代码的重用率。</li></ul><blockquote><p>编译时安全检查：</p><p>Java在1.5版本中引入了泛型，在没有泛型之前，每次从集合中读取对象都必须进行类型转换，而这么做带来的结果就是：如果有人不小心插入了类型错误的对象，那么在运行时转换处理阶段就会出错。<br>在提出泛型之后，我们可以告诉编译器集合中接受哪些对象类型。编译器会自动的为你的插入进行转化，并在编译时告知是否插入了类型错误的对象。这使程序变得更加安全更加清楚。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java泛型是J2 SE1.5中引入的一个新特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在&lt;a href=&quot;https://baike.baidu.com/item/%E7%B1%BB/6824577?</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>集合体系</title>
    <link href="https://southernfish.github.io/2025/07/23/java/java-base-5-collection/"/>
    <id>https://southernfish.github.io/2025/07/23/java/java-base-5-collection/</id>
    <published>2025-07-23T14:08:36.000Z</published>
    <updated>2025-07-28T10:27:55.452Z</updated>
    
    <content type="html"><![CDATA[<p>集合类是Java数据结构的实现。Java的集合类是<a href="https://baike.baidu.com/item/java.util/5180624?fromModule=lemma_inlink">java.util</a>包中的重要内容，它允许以各种方式将元素分组，并定义了各种使这些元素更容易操作的方法。Java集合类是Java将一些基本的和使用频率极高的基础类进行封装和增强后再以一个类的形式提供。集合类是可以往里面保存多个对象的类，存放的是对象，不同的集合类有不同的功能和特点，适合不同的场合，用以解决一些实际问题。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40991313/article/details/137256095">https://blog.csdn.net/qq_40991313/article/details/137256095</a></p><h1 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h1><h2 id="集合和映射"><a href="#集合和映射" class="headerlink" title="集合和映射"></a>集合和映射</h2><p>在Java中，集合是一组用于操作和存储数据的接口和类。 它主要包括Collection和Map两种。</p><p><strong>集合（Collection）</strong>：一组单独的元素。它通常应用了某种规则，例如 List（列表）必须按特定的顺序容纳元素，而一个Set（集）不可包含任何重复的元素。<br><strong>映射（Map）</strong>：一系列“键－值”对的集合。它的存储内容是一系列键值对，如果知道了键（key），我们可以直接获取到这个键所对应的值（value），时间复杂度是O(1)。散列表是Map的一种较为普遍的展现。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250722172620947.png" alt="image-20250722172620947"></p><p>Java中的集合类分为4大类,分别由4个接口来代表,它们是Set、List、Queue、Map。其中,Set、List、Queue接口都继承自Collection接口，Map接口不继承自其他接口。</p><p><code>Set</code>代表<strong>无序的、元素不可重复</strong>的集合。</p><p><code>List</code>代表<strong>有序的、元素可以重复</strong>的集合。有序说的是元素顺序直接由插入顺序决定。</p><p><code>Queue</code>代表<strong>先进先出（FIFO）</strong>的队列。</p><p><code>Map</code>代表<strong>具有映射关系（key-value）</strong>的集合。</p><p>Java提供了众多集合的实现类，它们都是这些接口的直接或间接的实现类，其中比较常用的有：<code>HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap</code>等。</p><h2 id="常见集合的底层和性能对比"><a href="#常见集合的底层和性能对比" class="headerlink" title="常见集合的底层和性能对比"></a>常见集合的底层和性能对比</h2><table><thead><tr><th>集合</th><th>使用场景</th><th>底层</th><th>性能</th></tr></thead><tbody><tr><td>ArrayList</td><td>频繁查询但不经常增删元素</td><td>数组，允许存储多个null值</td><td>查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)</td></tr><tr><td>LinkedList</td><td>频繁增删元素但不经常查询</td><td>链表，允许存储多个null值</td><td>查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为O(n) ），增删很快（只需调整链表的指针，插入（add）和删除（remove）操作时间复杂度为O(1)）</td></tr><tr><td>Stack</td><td>需要后进先出（LIFO）访问顺序的数据结构，例如递归、回溯算法等。线程安全，因为它是Vector的实现类</td><td>数组（因为它是Vector的实现类），允许存储多个 null 值</td><td>增删改查都是在栈顶操作，所以时间复杂度都是O(1)</td></tr><tr><td>HashSet</td><td>需要高效去重、快速查找、不考虑内存浪费的场景</td><td>哈希表（快速查找）和Set（去重）。它自动对元素进行去重（通过 hashCode 和 equals 方法），并且无序（存入后顺序会乱），允许存储一个null值。</td><td>底层是哈希表，所以插入、删除和查找操作的时间复杂度都是O(1)，代价是浪费一些空间。</td></tr><tr><td>TreeSet</td><td>适用于多读少写、排序的场景</td><td>红黑树（快速查找、排序）和Set（去重），不允许存储null值</td><td>插入、删除、查找操作的时间复杂度为O(log n)，因为操作需要维护树的平衡，所以适用于多读少写的场景。</td></tr><tr><td>HashMap</td><td>适用于多读少写、需要快速读的场景。</td><td>哈希表（快速查找）和Map（键值对），可以存储一个null键（key）和多个null值（value）。</td><td>底层是哈希表，所以插入、删除和查找操作的时间复杂度都是O(1)，代价是浪费一些空间。</td></tr></tbody></table><blockquote><p><strong>Stack常用方法</strong>：</p><ul><li>**push(E item)**：将元素压入栈顶</li><li>**pop()**：移除并返回栈顶元素</li><li>**peek()**：返回栈顶元素但不移除</li><li>**isEmpty()**：检查栈是否为空</li><li>**search(Object o)**：返回元素在栈中的位置，以 1 为基准</li></ul><p><strong>红黑树</strong>： </p><p>近似平衡二叉树，左右子树高差可能大于 1，查找效率略低于平衡二叉树，但增删效率高于平衡二叉树，适合频繁插入删除。</p><ul><li><p>结点非黑即红；</p></li><li><p>根结点是黑色，叶节点是黑色空节点（常省略）；</p></li><li><p>任何相邻节点不能同时为红色；</p></li><li><p>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；</p></li><li><p>**查询性能稳定O(logN)**，高度最高2log(n+1)；</p></li></ul></blockquote><h2 id="知识加油站"><a href="#知识加油站" class="headerlink" title="知识加油站"></a>知识加油站</h2><h2 id="集合的线程安全性"><a href="#集合的线程安全性" class="headerlink" title="集合的线程安全性"></a>集合的线程安全性</h2><p><strong>线程不安全的集合</strong>：</p><p>Java提供了众多集合的实现类,它们都是这些接口的直接或间接的实现类，其中比较常用的有：HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。这些集合都是线程不安全的。</p><p><strong>线程安全的集合</strong>：</p><ol><li><p><strong>Collections工具类</strong>：Collections工具类的<code>synchronizedXxx()</code>方法，将ArrayList等集合类包装成线程安全的集合类。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br></pre></td></tr></table></figure></li><li><p><strong>古老api</strong>：如Vector、Hashtable，在JDK1就出现了，不推荐使用，因为线程安全的方案不成熟，性能差。</p></li><li><p><strong>降低锁粒度的并发容器（推荐）</strong>：JUC包下<code>Concurrent</code>开头的、以降低锁粒度来提高并发性能的容器，如<code>ConcurrentHashMap</code>。适用于读写操作都很频繁的场景。</p></li><li><p><strong>复制技术实现的并发容器</strong>：JUC包下以<code>CopyOnWrite</code>开头的、采用写时写入时复制技术实现的并发容器，如<code>CopyOnWriteArrayList</code>。写操作时，先将当前数组进行一次复制，对复制后的数组进行操作，操作完成后再将原来的数组引用指向复制后的数组。避免了并发修改同一数组的线程安全问题。适用于读操作比写操作频繁且数据量不大的场景。适用于读操作远多于写操作的场景。</p></li></ol><h3 id="什么是线程不安全"><a href="#什么是线程不安全" class="headerlink" title="什么是线程不安全"></a>什么是线程不安全</h3><p>线程不安全是指在多线程环境下，当多个线程并发地访问和修改共享数据时，由于缺乏适当的同步机制，可能导致数据的不一致、错误或者程序行为不可预测的现象。</p><h2 id="Collection常用API"><a href="#Collection常用API" class="headerlink" title="Collection常用API"></a>Collection常用API</h2><ul><li>**add()**：向集合中添加一个元素。</li><li><strong>获取元素</strong>：没有直接提供获取指定位置元素的方法，因为它的实现类元素不一定有序。若需访问，需要通过迭代器iterator()</li><li>**remove()**：从集合中移除一个指定的元素。</li><li>**contains(Object o)**： 检查集合中是否包含指定元素。</li><li>**size()**：返回集合中的元素数量。</li><li>**isEmpty()**：检查集合是否为空。</li><li><strong>clear()</strong>:：移除集合中的所有元素。</li></ul><h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><p>Java 的集合框架提供了许多有用的工具类，用于简化集合的操作。最常见的工具类是 java.util.Collections 和 java.util.Arrays。这些工具类提供了许多静态方法，可以对集合进行排序、搜索、填充、反转等操作</p><h3 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h3><p>Collections工具类常用方法：</p><ul><li><code>sort(List&lt;T&gt; list)</code>：对指定的列表按自然顺序进行升序排序。</li><li>sort(List<T> list, Comparator&lt;? super T&gt; c)：使用指定的比较器对指定的列表进行排序。</li><li><code>reverse(List&lt;?&gt; list)</code>：反转指定列表中元素的顺序。</li><li><code>max(Collection&lt;? extends T&gt; coll)</code>：返回给定集合的最大元素，按自然顺序比较。</li><li>max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)：返回给定集合的最大元素，使用指定的比较器比较。</li><li><code>binarySearch(List&lt;? extends T&gt; list, T key)</code>：使用二分法搜索指定列表以查找指定对象。</li><li><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code>：将源列表的所有元素复制到目标列表中。</li><li><code>fill(List&lt;? super T&gt; list, T obj)</code>：用指定的元素替换指定列表中的所有元素。</li><li><code>frequency(Collection&lt;?&gt; c, Object o)</code>：返回指定集合中等于指定对象的元素数。</li><li><code>indexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target)</code>：返回指定源列表中首次出现指定目标列表的起始位置。</li><li><code>swap(List&lt;?&gt; list, int i, int j)</code>：交换指定列表中指定位置的元素。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个ArrayList并添加元素</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">5</span>);list.add(<span class="number">3</span>);list.add(<span class="number">8</span>);list.add(<span class="number">1</span>);list.add(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 输出原始列表</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用sort方法按自然顺序排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用reverse方法反转列表</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;反转后的列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用binarySearch方法查找元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素3的索引: &quot;</span> + index);</span><br><span class="line">        <span class="comment">// 创建一个目标列表并使用copy方法复制元素</span></span><br><span class="line">        List&lt;Integer&gt; destList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Collections.nCopies(list.size(), <span class="number">0</span>));</span><br><span class="line">        Collections.copy(destList, list);</span><br><span class="line">        System.out.println(<span class="string">&quot;复制后的目标列表: &quot;</span> + destList);</span><br><span class="line">        <span class="comment">// 使用fill方法填充列表</span></span><br><span class="line">        Collections.fill(list, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后的列表: &quot;</span> + list);</span><br><span class="line">        <span class="comment">// 使用swap方法交换元素</span></span><br><span class="line">        Collections.swap(destList, <span class="number">0</span>, destList.size() - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;交换后的目标列表: &quot;</span> + destList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.1.3.2 数组工具类Arrays<br>Arrays工具类常用方法：</p><ul><li><p><code>asList(T... a)</code>：将数组转换为固定大小列表。例如Arrays.asList(1,2,3);则返回有三个元素的数组</p><ul><li><p><strong>基本类型数组视作单个元素</strong>：如果传入基本类型数组，会将其整个数组视作单个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">Arrays.asList(nums); </span><br><span class="line"><span class="comment">// 返回列表是List&lt;int[]&gt;类型，只有一个数组元素。而传入对象类型（String、包装类等），则会拆开。</span></span><br><span class="line">Integer[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">Arrays.asList(nums);</span><br><span class="line"><span class="comment">// 返回列表是List&lt;Integer&gt;类型。其实主要原因是List&lt;T&gt;，T只能是包装类、数组、对象，不能是基本数据类型。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>与原数组共享内存</strong>：<code>asList()</code>后，修改列表的元素，变动会同步到原数组。</p></li><li><p><strong>列表固定大小</strong>：因为返回列表与原数组共享数据，所以列表是固定大小的，不能再增删元素。</p></li></ul></li><li><p><code>sort(T[] a)</code>：对指定数组按自然顺序进行升序排序。</p></li><li><p><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code>：使用指定的比较器对数组进行排序。</p></li><li><p><code>binarySearch(T[] a, T key)</code>：使用二分法搜索指定数组以查找指定对象。</p></li><li><p><code>binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</code>：使用二分法搜索指定数组以查找指定对象，使用指定的比较器。</p></li><li><p><code>copyOf(T[] original, int newLength)</code>：复制指定的数组，截取或填充 null 以使副本具有指定的长度。</p></li><li><p><code>copyOfRange(T[] original, int from, int to)</code>：复制指定的数组，从指定的起始位置开始到终止位置结束。</p></li><li><p><code>equals(Object[] a, Object[] a2)</code>：如果两个指定数组彼此相等，则返回 true。一维数组时比较内容是否一致，多维数组时只比较最外层数组对象的内容。</p></li><li><p><code>deepEquals(Object[] a1, Object[] a2)</code>：如果两个指定数组彼此深度相等，则返回 true。一维和多维数组比较内容是否一致。</p></li><li><p><code>fill(T[] a, T val)</code>：用指定的值填充指定数组。</p></li><li><p><code>toString(T[] a)</code>：返回指定数组内容的字符串表示形式。</p></li><li><p><code>deepToString(Object[] a)</code>：返回指定数组内容的深层字符串表示形式。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用asList方法将数组转换为列表。列表与原数组共享内存，列表固定大小</span></span><br><span class="line">        String[] stringArray = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; stringList = Arrays.asList(stringArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;数组转换为列表: &quot;</span> + stringList);</span><br><span class="line">        <span class="comment">// 使用sort方法对数组进行排序</span></span><br><span class="line">        <span class="type">int</span>[] intArray = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;原数组（直接打印）: &quot;</span> + intArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;原数组（用Arrays.toString()打印）：&quot;</span> + Arrays.toString(intArray));</span><br><span class="line">        Arrays.sort(intArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组: &quot;</span> + Arrays.toString(intArray));</span><br><span class="line">        <span class="comment">// 使用binarySearch方法查找元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(intArray, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素3的索引: &quot;</span> + index);</span><br><span class="line">        <span class="comment">// 使用copyOf方法复制数组</span></span><br><span class="line">        <span class="type">int</span>[] copiedArray = Arrays.copyOf(intArray, intArray.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;复制后的数组: &quot;</span> + Arrays.toString(copiedArray));</span><br><span class="line">        <span class="comment">// 使用deepEquals方法比较多维数组</span></span><br><span class="line">        Integer[][] deepArray1 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        Integer[][] deepArray2 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">deepEqual</span> <span class="operator">=</span> Arrays.deepEquals(deepArray1, deepArray2);</span><br><span class="line">        System.out.println(<span class="string">&quot;多维数组是否深度相等: &quot;</span> + deepEqual);</span><br><span class="line">        <span class="comment">// 使用fill方法填充数组</span></span><br><span class="line">        <span class="type">int</span>[] fillArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(fillArray, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后的数组: &quot;</span> + Arrays.toString(fillArray));</span><br><span class="line">        <span class="comment">// 使用toString方法将数组转换为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">arrayString</span> <span class="operator">=</span> Arrays.toString(intArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;数组的字符串表示: &quot;</span> + arrayString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li><strong>基本介绍：</strong>可以动态修改的数组，没有固定大小的限制。</li><li><strong>使用场景：</strong>频繁查询但不经常增删元素</li><li><strong>底层：</strong>数组 。允许存储多个null值。</li><li><strong>性能：</strong>查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)。</li><li><strong>常用API：</strong><ul><li>Collection接口的add()、remove()等方法</li><li><strong>get()：</strong>获取一个指定下标的元素</li><li><strong>subList(int fromIndex, int toIndex)：</strong>返回从 fromIndex（包括）到 toIndex（不包括）之间的部分列表。</li><li><strong>trimToSize()：</strong>将 ArrayList 的容量调整为当前元素的数量，以节省内存。</li></ul></li></ul><p><strong>排序方法：</strong></p><ul><li><strong>Collections工具类的sort()方法：</strong>Collections.sort(list);</li><li><strong>stream流：</strong>list.stream().sort();</li><li><strong>比较器：</strong>list.sort(new Comparator<Integer>() {})</li><li><strong>手写排序：</strong>冒泡排序、选择排序、插入排序、二分法排序、快速排序、堆排序。</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList</span></span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用 add() 方法向集合中添加元素</span></span><br><span class="line">    arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;添加元素后: &quot;</span> + arrayList);</span><br><span class="line">    <span class="comment">// 使用 get() 方法获取指定索引的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">elementAtIndex2</span> <span class="operator">=</span> arrayList.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;索引 2 处的元素: &quot;</span> + elementAtIndex2);</span><br><span class="line">    <span class="comment">// 使用 set() 方法修改指定索引的元素</span></span><br><span class="line">    arrayList.set(<span class="number">2</span>, <span class="number">35</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改索引 2 后: &quot;</span> + arrayList);</span><br><span class="line">    <span class="comment">// 使用 remove() 方法移除指定索引的元素</span></span><br><span class="line">    arrayList.remove(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;移除索引 1 后: &quot;</span> + arrayList);</span><br><span class="line">    <span class="comment">// 使用 size() 方法获取集合的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arrayList.size();</span><br><span class="line">    System.out.println(<span class="string">&quot;集合的大小: &quot;</span> + size);</span><br><span class="line">    <span class="comment">// 使用 contains() 方法检查集合中是否包含某个元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">contains30</span> <span class="operator">=</span> arrayList.contains(<span class="number">30</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;集合中是否包含 30: &quot;</span> + contains30);</span><br><span class="line">    <span class="comment">// 使用 isEmpty() 方法检查集合是否为空</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> arrayList.isEmpty();</span><br><span class="line">    System.out.println(<span class="string">&quot;集合是否为空: &quot;</span> + isEmpty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层源码和扩容机制"><a href="#底层源码和扩容机制" class="headerlink" title="底层源码和扩容机制"></a>底层源码和扩容机制</h2><p><strong>数组实现：</strong></p><p>ArrayList是<strong>基于数组实现的</strong>，它的内部封装了一个<strong>Object[]数组</strong>。通过<strong>默认构造器</strong>创建容器时,该数组先被<strong>初始化为空数组</strong>，之后在<strong>首次添加数据</strong>时再将其初始化成<strong>长度为10的数组</strong>。我们也可以使用有参构造器来创建容器，并通过参数来显式指定数组的容量，届时该数组被初始化为指定容量的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制的源码中的一部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default initial capacity. 初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access 底层数组</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每次扩容1.5倍：</strong></p><p>如果向ArrayList中添加数据会造成超出数组长度限制,则会触发<strong>自动扩容</strong>,然后再添加数据。扩容就是<strong>数组拷贝</strong>,将<strong>旧数组中的数据拷贝到新数组</strong>里,而新数组的长度为原来<strong>长度的1.5倍</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minCapacity 代表着最小扩容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// elementData 是 ArrayList 存储数据的数组，这里是获取当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 计算扩容后的数组长度 = 当前数组长度 + (当前数组长度 * 0.5)；也就是扩容到当前的 1.5 倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断新的数组是否满足最小扩容量，如果不满足就将新数组的扩容长度赋值为最小扩容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果扩容后的长度超过了最大数组大小，则将其设置为合适的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity 通常接近于 size，因此这是一个有效的优化</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动缩容：</strong></p><p>ArrayList支持缩容,但<strong>不会自动缩容</strong>,即便是ArrayList中只剩下少量数据时也不会主动缩容。如果我们希望缩减ArrayList的容量,则需要自己调用它的<strong>trimToSize()方法</strong>,届时数组将按照元素的实际个数进行缩减，底层也是通过创建新数组拷贝实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 增加modCount，modCount是ArrayList的属性，用于记录集合被修改的次数。</span></span><br><span class="line">    <span class="comment">// 除了ArrayList，LinkedList、HashSet、TreeSet、HashMap、TreeMap等集合都有modCount属性</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果当前大小小于数组的长度，则进行缩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        <span class="comment">// 如果 size 为 0，则将 elementData 置为 EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="comment">// 否则将 elementData 缩容到 size 大小</span></span><br><span class="line">        elementData = (size == <span class="number">0</span>) </span><br><span class="line">            ? EMPTY_ELEMENTDATA </span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程不安全问题和解决方案"><a href="#线程不安全问题和解决方案" class="headerlink" title="线程不安全问题和解决方案"></a>线程不安全问题和解决方案</h2><p>添加元素add()方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.扩容：判断列表的capacity容量是否足够，是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2.添加：真正将元素放在列表的元素数组里面</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.某线程刚扩容后就失去调度</strong></p><p>在JVM中，CPU在多个线程中通过程序计数器来回调度，同一时刻一个CPU只能运行一个线程，所以就存在add()时，某个线程在刚刚ensureCapacityInternal()扩容后、还没往数组存元素时被暂停，等待被调度，然后其他线程add()成功把数组存满了，此时原线程恢复运行，执行elementData[size++] = e，因为数组容量已经满了，就会报错数组越界异常ArrayIndexOutOfBoundsException。</p><p><strong>例如：</strong></p><p>表大小为9，线程A新增一个元素，判断容量是不是足够，同时线程B也新增一个元素，判断容量是不是足够，线程A开始进行设置值操作， elementData[size++] = e 操作。此时size变为10，线程B也开始进行设置值操作，它尝试设置elementData[10] = e，而elementData没有进行过扩容，它的下标最大为9。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException。</p><p><strong>2.数组存值时不是原子操作</strong><br>另外第二步 elementData[size++] = e 设置值的操作同样会导致线程不安全。从这儿可以看出，这步操作也不是一个原子操作。</p><p><strong>解决方案：</strong></p><ul><li><p>原子类</p></li><li><p>volatile</p></li><li><p>锁</p></li><li><p><strong>线程安全的集合：</strong></p><ul><li><p><strong>Collections工具类：</strong>Collections工具类的synchronizedXxx()方法<strong>，</strong>将ArrayList等集合类包装成线程安全的集合类。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure></li><li><p><strong>古老api</strong>：java.util包下性能差的古老api，如Vector、Hashtable</p></li><li><p><strong>降低锁粒度的并发容器</strong>：JUC包下Concurrent开头的、以降低锁粒度来提高并发性能的容器，如ConcurrentHashMap。</p></li><li><p><strong>复制技术实现的并发容器</strong>：JUC包下以CopyOnWrite开头的、采用写时复制技术实现的并发容器，如CopyOnWriteArrayList。 </p></li></ul></li></ul><h2 id="六种遍历方法"><a href="#六种遍历方法" class="headerlink" title="六种遍历方法"></a>六种遍历方法</h2><h3 id="常规-for-循环"><a href="#常规-for-循环" class="headerlink" title="常规 for 循环"></a>常规 for 循环</h3><p>普通 for 循环适用于遍历数组和实现了 List 接口的集合。它通过索引访问元素，性能通常较好。</p><p><strong>优点：</strong></p><ul><li><strong>性能高：</strong>性能通常优于增强 for 循环和迭代器，尤其是对于数组和 ArrayList。</li><li><strong>复杂操作：</strong>允许在遍历过程中进行复杂的控制操作。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>可读性差：</strong>代码相对冗长，需要手动管理循环变量。</li><li><strong>只能通过索引访问：</strong>仅适用于可以通过索引下标访问元素的集合。</li></ul><p><strong>通过for循环，用get(下标) 的方法遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 通过arrayList.add(value)增加值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">    System.out.print(arrayList.get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强-for-循环（只遍历不修改）"><a href="#增强-for-循环（只遍历不修改）" class="headerlink" title="增强 for 循环（只遍历不修改）"></a>增强 for 循环（只遍历不修改）</h3><p>在某些情况下，常规的遍历方式容易显得代码臃肿，增强for可以简化数组和Collection集合的遍历，增强代码的可读性。</p><p><strong>增强 for 循环：</strong>一种<strong>简洁</strong>的遍历集合的方法，它适用于遍历数组和实现了 Iterable 接口的所有集合。</p><blockquote><p><strong>Collection实现类都实现了Iterable 接口：</strong></p><p>在标准的 Java Collections Framework 中，所有主要的集合实现类都实现了 Iterable 接口。换句话说，如果一个类实现了 Collection 接口，那么它也会实现 Iterable 接口，因为这是 Collection 接口的一个基本要求。 </p><p><strong>tip：</strong>Map集合没有实现Iterable 接口，因为它也没有实现Collection接口。</p></blockquote><p><strong>IDEA快捷键：</strong>输入iter然后回车</p><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据类型：即遍历对象中元素的数据类型。</span></span><br><span class="line"><span class="comment">// 变量名：遍历时声明的变量，每次遍历得到的元素都会赋值给这个变量。</span></span><br><span class="line"><span class="comment">// 数组或者集合对象：需要遍历的对象。</span></span><br><span class="line"><span class="keyword">for</span> (数据类型 变量名 : 数组或者Collection集合对象) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">    System.out.println(变量名);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><strong>简洁易读</strong>：增强 for 循环语法简洁，代码更容易阅读。</li><li><strong>避免错误</strong>：相比传统的 for 循环，不需要手动管理循环变量，减少了出错的可能性。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了可读性 </li><li>不允许修改；</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用增强 for 循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (Integer num : arrayList) &#123;</span><br><span class="line">    System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器-Iterator（遍历并修改）"><a href="#迭代器-Iterator（遍历并修改）" class="headerlink" title="迭代器 Iterator（遍历并修改）"></a>迭代器 Iterator（遍历并修改）</h3><p>迭代器是遍历Collection集合的通用方式，它不需要关注集合和集合内元素的类型，对集合内的元素进行读取、添加、修改操作。  </p><p><strong>基本方法：</strong></p><ul><li><strong>hasNext()：</strong>返回 true 如果还有未遍历的元素。</li><li><strong>next()：</strong>返回下一个元素。</li><li><strong>remove()：</strong>从集合中移除 next() 返回的最后一个元素。</li></ul><p><strong>优点：</strong></p><ul><li><strong>各类型集合统一迭代器</strong>：不需要了解集合的内部实现，通过 Iterator 可以统一遍历不同类型的集合。</li><li><strong>安全</strong>：在遍历过程中，如果其他线程修改了集合，Iterator 可以抛出 ConcurrentModificationException 以防止不一致性。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了可读性 </li><li><strong>复杂：</strong>相比增强for，需要next()、hasNext()，麻烦了一些</li><li>不能双向遍历</li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorRemoveExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 ArrayList 并添加一些元素</span></span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 获取 ArrayList 的迭代器</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = arrayList.iterator();</span><br><span class="line">        <span class="comment">// 使用迭代器遍历 ArrayList 并移除元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用迭代器遍历 ArrayList 并移除元素:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">30</span>) &#123;</span><br><span class="line">                iterator.remove(); <span class="comment">// 移除大于 30 的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印修改后的 ArrayList</span></span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的 ArrayList:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer num : arrayList) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器-ListIterator-（双向遍历并修改）"><a href="#迭代器-ListIterator-（双向遍历并修改）" class="headerlink" title="迭代器 ListIterator （双向遍历并修改）"></a>迭代器 ListIterator （双向遍历并修改）</h3><p>Set、List、Queue都是Collection的子接口，它们都继承了父接口的iterator()方法,从而具备了迭代的能力。Map使用迭代器必须通过先entrySet()转为Set，然后再使用迭代器或for遍历。</p><p>但相比于另外两个接口，<strong>List</strong>还单独提供了<strong>listIterator()方法</strong>,增强了迭代能力。iterator()方法返回Iterator迭代器，listIterator()方法返回ListIterator迭代器，并且<strong>ListIterator是Iterator的子接口</strong>。</p><p>ListIterator在Iterator的基础上，增加了listIterator.previous()向前遍历的支持，增加了listIterator.set()在迭代过程中修改数据的支持。与 Iterator 相比，ListIterator 提供了更多的方法，但只适用于实现了 List 接口的集合（如 ArrayList 和 LinkedList）。</p><p><strong>常用方法：</strong></p><ul><li>hasNext()：如果列表中有下一个元素，则返回 true。</li><li><strong>next()：</strong>返回列表中的下一个元素。</li><li>hasPrevious()：如果列表中有上一个元素，则返回 true。</li><li><strong>previous()：</strong>返回列表中的上一个元素。</li><li>nextIndex()：返回下一元素的索引。</li><li>previousIndex()：返回上一元素的索引。</li><li>remove()：移除上一个通过 next() 或 previous() 返回的元素。</li><li>set(E e)：替换上一个通过 next() 或 previous() 返回的元素。</li><li>add(E e)：在列表中插入指定元素。 </li></ul><p><strong>优点：</strong></p><ul><li>可读性高；</li><li><strong>安全：</strong>在遍历过程中，如果其他线程修改了集合，迭代器可以抛出 ConcurrentModificationException 以防止不一致性。</li><li>双向遍历；</li></ul><p><strong>缺点：</strong></p><ul><li><strong>只支持List：</strong>只适用于实现了 List 接口的集合（如 ArrayList 和 LinkedList）。</li><li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了可读性 </li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 使用 ListIterator 遍历（正向）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 ListIterator 正向遍历:&quot;</span>);</span><br><span class="line">        ListIterator&lt;Integer&gt; listIterator = arrayList.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(listIterator.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 使用 ListIterator 反向遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 ListIterator 反向遍历:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">            System.out.print(listIterator.previous() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forEach-Lambda-表达式（只遍历不修改）"><a href="#forEach-Lambda-表达式（只遍历不修改）" class="headerlink" title="forEach + Lambda 表达式（只遍历不修改）"></a>forEach + Lambda 表达式（只遍历不修改）</h3><p>在 Java 8 及以上版本中，forEach 方法与 Lambda 表达式的结合提供了一种简洁、功能强大的方式来遍历集合。forEach 方法<strong>属于 Iterable 接口</strong>，允许对集合中的每个元素执行指定的操作。</p><p><strong>优点：</strong></p><ul><li><strong>简洁：</strong>相比于传统的 for 循环和迭代器，代码更简洁，减少样板代码。</li><li><strong>可读性强：</strong>使用 Lambda 表达式和方法引用，使代码更加易读和表达意图明确。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>性能略差：</strong>性能略差于普通for循环，以略微的性能代价，提高了代码的优雅性可读性 ；同时各个元素之间的遍历是顺序执行的，不像Stream流的forEach是并发执行的，性能略差。</li><li><strong>不允许修改元素：</strong>因为 Lambda 表达式的参数是 final 或等效于 final 的，所以不允许修改集合中的元素。想修改的话，只能创建另一个集合，然后在遍历时将处理后的元素add进另一个集合。</li><li><strong>版本限制：</strong>只适用JDK8及以上；</li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachLambdaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 使用 forEach 方法和 Lambda 表达式遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 forEach 方法和 Lambda 表达式遍历:&quot;</span>);</span><br><span class="line">        arrayList.forEach(num -&gt; System.out.print(num + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream-API-遍历（推荐，并发遍历并修改）"><a href="#Stream-API-遍历（推荐，并发遍历并修改）" class="headerlink" title="Stream API 遍历（推荐，并发遍历并修改）"></a>Stream API 遍历（推荐，并发遍历并修改）</h3><p>Stream 流是 Java 8 引入的一项新特性，用于对集合进行函数式编程风格的操作。它允许我们以声明性方式对数据进行过滤、加工、遍历、排序等操作，而不是以命令式方式逐个操作元素。</p><p><strong>优点：</strong></p><ul><li><strong>简洁：</strong>相比于传统的 for 循环和迭代器，代码更简洁，减少样板代码。</li><li><strong>生成修改后的新集合：</strong>允许通过map()、filter()等方法修改元素，然后收集成一个新集合。</li><li><strong>性能高：</strong>因为是并发的，所以性能高。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>版本限制：</strong>只适用JDK8及以上；</li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">20</span>);arrayList.add(<span class="number">30</span>);arrayList.add(<span class="number">40</span>);arrayList.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 使用 Stream API 遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 Stream API 遍历:&quot;</span>);</span><br><span class="line">        arrayList.stream().forEach(num -&gt; System.out.print(num + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结：六种遍历方法的适用场景"><a href="#小结：六种遍历方法的适用场景" class="headerlink" title="小结：六种遍历方法的适用场景"></a>小结：六种遍历方法的适用场景</h3><ul><li><strong>需要根据索引下标遍历：</strong>普通for</li><li><strong>只需要顺序读取元素：</strong>建议增强for，也可以用其他所有遍历方法</li><li><strong>需要修改元素：</strong>普通for、迭代器、Stream流</li><li><strong>需要双向遍历：</strong>ListIterator </li><li><strong>需要过滤、加工、排序等高级操作：</strong>Stream流</li></ul><hr><h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>参考链接：<a href="https://blog.csdn.net/qq_47980550/article/details/148012216">java基础——java集合list详解</a>、<a href="https://blog.csdn.net/qq_38322527/article/details/114703142">JUC中的List安全类集合</a></p><h2 id="主要实现类"><a href="#主要实现类" class="headerlink" title="主要实现类"></a><strong>主要实现类</strong></h2><p>Collection将集合划分为两大类，即List和Set。</p><p>常见的 List 实现类包括 ArrayList、LinkedList、Vector（JDK1的上古集合，虽然线程安全但性能差，已经基本不用） 和 Stack。 </p><ol><li><p><strong>ArrayList：</strong></p><ul><li><p><strong>使用场景：</strong>频繁查询但不经常增删元素</p></li><li><p><strong>底层：</strong>数组 。允许存储多个null值。</p></li><li><p><strong>性能：</strong>查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)。</p></li></ul></li><li><p><strong>LinkedList：</strong></p><ul><li><p><strong>使用场景：</strong>频繁增删元素但不经常查询</p></li><li><p><strong>底层：</strong>链表 。允许存储多个null值。</p></li><li><p><strong>性能：</strong> 查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为O(n) ），增删很快（只需调整链表的指针，插入（add）和删除（remove）操作时间复杂度为O(1)）。</p></li></ul></li><li><p><strong>Vector：</strong></p><ul><li><p><strong>使用场景：</strong>需要线程安全且频繁查询的场景（JDK1的上古集合，虽然线程安全但性能差，已经基本不用。</p></li><li><p><strong>线程安全集合：</strong></p><ul><li><strong>Collections工具类：</strong>Collections工具类的synchronizedXxx()方法<strong>，</strong>将ArrayList等集合类包装成线程安全的集合类。</li><li><strong>古老api：</strong>java.util包下性能差的古老api，如Vector、Hashtable</li><li>无序列表<strong>降低锁粒度的并发容器：</strong>JUC包下Concurrent开头的、以降低锁粒度来提高并发性能的容器，如ConcurrentHashMap。</li><li><strong>复制技术实现的并发容器：</strong>JUC包下以CopyOnWrite开头的、采用写时复制技术实现的并发容器，如CopyOnWriteArrayList。 </li></ul></li><li><p><strong>底层：</strong>数组。允许存储多个 null 值。</p><ul><li><strong>性能：</strong> 查询（get、contains）操作时间复杂度为O(1)，添加（add）和删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为O(n)。</li></ul></li></ul></li><li><p><strong>Stack：</strong></p><ul><li><p><strong>使用场景：</strong>需要后进先出（LIFO）访问顺序的数据结构，例如递归、回溯算法等。线程安全，因为它是Vector的实现类</p></li><li><p><strong>底层：</strong>数组（因为它是Vector的实现类）。允许存储多个 null 值。</p></li><li><p><strong>性能：</strong> 增删改查都是在栈顶操作，所以时间复杂度都是O(1)</p></li><li><p><strong>常用方法：</strong></p><ul><li>**push(E item)**：将元素压入栈顶</li><li>**pop()**：移除并返回栈顶元素</li><li>**peek()**：返回栈顶元素但不移除</li><li>**isEmpty()**：检查栈是否为空</li><li>**search(Object o)**：返回元素在栈中的位置，以 1 为基准 </li></ul></li></ul></li></ol><h2 id="ArrayList，LinkedList，Vector-对比"><a href="#ArrayList，LinkedList，Vector-对比" class="headerlink" title="ArrayList，LinkedList，Vector 对比"></a>ArrayList，LinkedList，Vector 对比</h2><table><thead><tr><th></th><th>ArrayList</th><th>LinkedList</th><th>Vector</th></tr></thead><tbody><tr><td>底层结构</td><td>动态数组</td><td>双向链表</td><td>动态数组</td></tr><tr><td>线程安全</td><td>不安全</td><td>不安全</td><td>安全，方法都加了<code>Synchronized</code></td></tr><tr><td>是否允许重复元素</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>是否有序</td><td>是</td><td>是</td><td>是</td></tr><tr><td>随机访问</td><td>快O(1)，索引访问</td><td>慢O(n)，需遍历链表</td><td>快O(1)，但因同步影响性能较低</td></tr><tr><td>插入/删除</td><td>慢O(n)，需移动元素</td><td>快O(1)，只需修改指针</td><td>慢，同步开销大</td></tr><tr><td>扩容机制</td><td>默认增长50%</td><td>无需扩容，动态添加节点</td><td>默认翻倍容量</td></tr><tr><td>加载因子</td><td>1</td><td>无</td><td>1</td></tr></tbody></table><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>有序【存储有序】</li><li>可重复</li><li>可以存储 null值</li><li>部分子集合线程安全，部分不安全 例如 ArrayList 和 Vector</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>List接口继承自<code>Collection</code>接口，提供了额外的功能来处理索引位置上的元素。与Set、Map不同，List允许包含重复的元素，并且可以通过索引来访问或修改特定位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 核心接口方法 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="comment">// 添加指定元素到列表末尾。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span><span class="comment">// 在指定索引处插入指定元素。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> <span class="comment">// 在指定索引 index 处插入集合 c 中的所有元素。</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">// 移除指定索引处的元素。</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">// 获取指定索引处的元素。</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> <span class="comment">// 替换指定索引处的元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回列表中的元素数量。</span></span><br><span class="line"><span class="comment">/* 其他常用方法 */</span> </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断列表是否为空。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> <span class="comment">// 检查列表是否包含指定元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> <span class="comment">// 返回指定元素首次出现的索引，如果不存在则返回-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> <span class="comment">// 返回指定元素最后一次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> <span class="comment">// 获取从fromIndex（包括）到toIndex（不包括）之间的子列表</span></span><br></pre></td></tr></table></figure><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 增加元素</span></span><br><span class="line">    list.add(<span class="string">&quot;元素1&quot;</span>);list.add(<span class="string">&quot;元素2&quot;</span>);list.add(<span class="string">&quot;元素3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;增加元素后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 在指定索引插入元素</span></span><br><span class="line">    list.add(<span class="number">1</span>, <span class="string">&quot;元素4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;在索引1插入元素4后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 删除指定索引的元素</span></span><br><span class="line">    list.remove(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除索引2的元素后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 修改指定索引的元素</span></span><br><span class="line">    list.set(<span class="number">1</span>, <span class="string">&quot;元素5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改索引1的元素为元素5后：&quot;</span> + list);</span><br><span class="line">    <span class="comment">// 获取指定索引的元素</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> list.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;获取索引2的元素：&quot;</span> + element);</span><br><span class="line">    <span class="comment">// 获取元素的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="string">&quot;元素5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;元素5的索引：&quot;</span> + index);</span><br><span class="line">    <span class="comment">// 获取子列表</span></span><br><span class="line">    List&lt;String&gt; subList = list.subList(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;子列表（从索引1到索引2）： &quot;</span> + subList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ol><li><p><code>for</code>循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：可以灵活控制索引。支持随机访问（适合 ArrayList）。</span></span><br><span class="line"><span class="comment">// 缺点：对于 LinkedList 来说效率较低（因为每次都要从头开始查找元素）。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Index: &quot;</span> + i + <span class="string">&quot;, Value: &quot;</span> + list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：简洁易读。适用于所有实现了 Iterable 接口的集合类。</span></span><br><span class="line"><span class="comment">// 缺点：无法获取索引。不能修改集合结构（如删除元素会抛出异常）。</span></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Item: &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Iterator</code>。可以安全地在遍历时进行删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;元素：&quot;</span> + iterator.next());</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(item)) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 安全删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="去重方式"><a href="#去重方式" class="headerlink" title="去重方式"></a>去重方式</h2><ol><li><p>利用 <code>HashSet</code> 或 <code>LinkedHashSet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet 不保留顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出顺序可能不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashSet 保留插入顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Stream.distinct()</code>，Java 8+ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; uniqueList = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(uniqueList);</span><br></pre></td></tr></table></figure></li></ol><h2 id="List-与数组的转换"><a href="#List-与数组的转换" class="headerlink" title="List 与数组的转换"></a>List 与数组的转换</h2><ul><li><p>List 转数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无类型参数：丢失类型信息</span></span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line"><span class="comment">// 带类型参数：推荐，自动匹配类型</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 函数式写法</span></span><br><span class="line">String[] array = list.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li><li><p>数组转 List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(array);（只读）</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));（可修改）</span><br></pre></td></tr></table></figure></li></ul><h2 id="List-的元素判断机制"><a href="#List-的元素判断机制" class="headerlink" title="List 的元素判断机制"></a>List 的元素判断机制</h2><p>List的 <code>contains(Object o)</code> 和 <code>indexOf(Object o)</code> 方法通过 <code>equals()</code>而非 <code>==</code> 判断元素是否相等。</p><h2 id="List的安全类"><a href="#List的安全类" class="headerlink" title="List的安全类"></a>List的安全类</h2><p>在单线程应用中，通常采取<code>new ArrayList()</code>，指定一个List集合，用于存放可重复的数据。但<code>ArrayList</code>是不安全的集合。多线程操作同一集合对象信息，往往会出现<code>java.util.ConcurrentModificationException</code>异常报错信息。</p><h3 id="Java的安全类Vector"><a href="#Java的安全类Vector" class="headerlink" title="Java的安全类Vector"></a>Java的安全类Vector</h3><p>java提供了<code>java.util.Vector</code>类，多线程下不会出现<code>java.util.ConcurrentModificationException</code>报错信息。因为采取了 <code>synchronized</code> 针对方法执行调用者加锁，保证add操作的多线程安全性！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建lists集合</span></span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JUC下的安全List集合"><a href="#JUC下的安全List集合" class="headerlink" title="JUC下的安全List集合"></a>JUC下的安全List集合</h3><ol><li><code>Collections.synchronizedList(new ArrayList&lt;&gt;());</code>。该方法返回具有同步包装器的List，保证了对List的操作是安全的。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">( <span class="meta">@NotNull</span> List&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(list <span class="keyword">instanceof</span> RandomAccess ? </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) : </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">synchronizedList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断传入的 list 集合类型，判断类型是否为 java.util.RandomAccess，如果是则采取java.util.Collections.SynchronizedRandomAccessList构造集合，如果不是则采取java.util.Collections.SynchronizedList构造集合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码中对应的add操作逻辑如下所示。采取synchronized同步代码块的方式，对数据的add操作实现加锁！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>&#123; </span><br><span class="line">    synchron1zed (mutex) &#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>new CopyOnWriteArrayList();</code>。该类中所有修改操作都在一个独立的副本上进行，不会影响原始数据，保证了线程安全。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&quot;</span>+lists);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates an empty list</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyonWriteArrayList</span><span class="params">()</span>&#123; setArray(<span class="keyword">new</span> <span class="title class_">object</span>[<span class="number">0</span>]); &#125;</span><br><span class="line"><span class="comment">// add 逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[]elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copy0f(elements, len +<span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong><code>add</code>逻辑如下所示</strong><br>  1、调用add方法后，拿到<code>java.util.concurrent.locks.ReentrantLock</code>对象信息。<br>  2、调用 <code>lock.lock()</code> 拿到锁！<br>  3、将原数组对象<code>copy</code>操作，并创建<code>原数组大小+1</code>的新数组。<br>  4、将新数据放入新数组中。<br>  5、任何操作<code>finally</code>，都进行锁的释放</p><h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>面向接口编程（<code>Programming to an Interface</code>）是一种编程原则，它强调使用接口（Interface）而不是具体实现类（Concrete Class）来编写代码。</p><p>具体的使用方法是，声明一个接口的变量（接口的引用）可以指向一个实现类（实现该接口的类）的实例。</p><p><strong>注意：</strong>因为是接口的引用，所以该引用的变量不能使用实现类中有、但接口中没有的方法（实现类中没有重写的方法，自添加的方法）。</p><blockquote><p><strong>以面向接口编程为原则，以多态的形式创建集合对象：</strong></p><p>以下两种方法都可以创建ArrayList，但是更推荐第一种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐，面向接口编程，多态形式，对象实例指向接口引用</span></span><br><span class="line">List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 不推荐，常规创建对象形式</span></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>因为前者符合设计模式中的依赖倒置原则。即程序要尽量依赖于抽象，不依赖于具体。</p><p>在Java语法中，这种方式符合Java三大特性中的多态，即使用接口引用指向具体实现。<br>依赖倒转的好处是，后期扩展方便。比如，你若希望用LinkedList的实现来替代ArrayList的话，只需改动一行即可，其他的所有的都不需要改动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()；</span><br></pre></td></tr></table></figure></blockquote><p><strong>优点：</strong></p><ul><li><strong>解耦合</strong>：声明的变量与具体实现类解耦。变量只依赖于接口，而不是具体实现，这样可以很容易地替换具体实现类，而不需要修改客户端代码。</li><li><strong>可扩展性</strong>：当需要添加新功能时，只需实现新的接口，让原引用指向新的实现类，而不需要修改现有代码。例如SpringBoot项目中，我们经常用XxxService接口和XxxServiceImpl1、XxxServiceImpl2等业务实现类，在使用时，通常将这个接口引用通过@Autowired等注解注入XxxService，然后通过@Primary、@Qualifier等注解指定具体注入XxxServiceImpl1还是XxxServiceImpl2，方便扩展。</li><li><strong>可测试性</strong>：在单元测试中，可以轻松地使用接口的模拟实现来替换真实的实现，从而进行隔离测试。</li></ul><p><strong>符合设计原则：</strong></p><ul><li><strong>开闭原则OCP(Open－Close Principle)：</strong> 对拓展开放、对修改关闭。</li><li><strong>依赖倒置原则DIP(Dependency Inversion Principle)：</strong> 抽象不应该依赖于细节、细节应该依赖于抽象。例如我们开发中要用Service接口和ServiceImpl实现类，而不是直接一个ServiceImpl类中写业务。</li></ul><blockquote><p><strong>设计原则详细参考：</strong></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/130403757?spm=1001.2014.3001.5502">设计模式——设计模式简介和七大原则_理解设计模式的核心思想和基本理念是什么-CSDN博客</a></p></blockquote><hr><h1 id="LinkedList接口"><a href="#LinkedList接口" class="headerlink" title="LinkedList接口"></a>LinkedList接口</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>LinkedList：</strong></p><ul><li><strong>使用场景：</strong>频繁增删元素但不经常查询</li><li><strong>底层：</strong>链表 。允许存储多个null值。</li><li><strong>性能：</strong> 查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为O(n) ），增删很快（只需调整链表的指针，插入（add）和删除（remove）操作时间复杂度为O(1)）。</li></ul><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public void add(int index, E element)</td><td>向指定位置插入元素</td></tr><tr><td>public void addFirst(E e)</td><td>元素添加到头部</td></tr><tr><td>public void addLast(E e)</td><td>元素添加到尾部</td></tr><tr><td>public void clear()</td><td>清空链表</td></tr><tr><td>public E remove(int index)</td><td>删除指定位置的元素</td></tr><tr><td>public E removeFirst()</td><td>删除并返回第一个元素</td></tr><tr><td>public E removeLast()</td><td>删除并返回最后一个元素</td></tr><tr><td>public boolean contains(Object o)</td><td>判断是否含有某一元素</td></tr><tr><td>public E getFirst()</td><td>返回第一个元素</td></tr><tr><td>public E getLast()</td><td>返回最后一个元素</td></tr></tbody></table><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedList&lt;String&gt; link=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    link.addLast(<span class="string">&quot;hello&quot;</span>);link.addLast(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s:link) System.out.println(s);</span><br><span class="line">    System.out.println(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>ArrayList</strong></th><th><strong>LinkedList</strong></th></tr></thead><tbody><tr><td><strong>使用场景</strong></td><td>频繁查询但不经常增删元素</td><td>频繁增删元素但不经常查询</td></tr><tr><td><strong>底层</strong></td><td>数组</td><td>链表</td></tr><tr><td><strong>允许存储 null 值</strong></td><td>是。允许存储多个null值</td><td>是。允许存储多个null值</td></tr><tr><td><strong>查询性能</strong></td><td>快。根据索引查询（get、contains）操作时间复杂度为 O(1)</td><td>慢。根据索引查询很慢（需要从头（或尾）遍历链表，查询操作时间复杂度为 O(n)）</td></tr><tr><td><strong>添加性能</strong></td><td>慢。添加（add）元素时，可能需要移动数组中的元素，导致时间复杂度为 O(n)</td><td>快。插入（add）操作时间复杂度为 O(1)，插入后不需要移动元素</td></tr><tr><td><strong>删除性能</strong></td><td>慢。删除（remove）元素时，可能需要移动数组中的元素，导致时间复杂度为 O(n)</td><td>快。删除（remove）操作时间复杂度为 O(1)，删除后不需要移动元素</td></tr></tbody></table><hr><h1 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h1><p>列表迭代器允许沿任一方向遍历列表</p><h2 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h2><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method</th><th>Description</th></tr></thead><tbody><tr><td align="left"><code>void</code></td><td align="left"><code>add(E e)</code></td><td>将指定的元素插入列表（可选操作）</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>hasNext()</code></td><td>返回 <code>true</code>如果遍历正向列表，列表迭代器有多个元素</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>hasPrevious()</code></td><td>返回 <code>true</code>如果遍历反向列表，列表迭代器有多个元素</td></tr><tr><td align="left"><code>E</code></td><td align="left"><code>next()</code></td><td>返回列表中的下一个元素，并且前进光标位置</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>nextIndex()</code></td><td>返回随后调用 <a href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#next--"><code>next()</code></a>返回的元素的索引</td></tr><tr><td align="left"><code>E</code></td><td align="left"><code>previous()</code></td><td>返回列表中的上一个元素，并向后移动光标位置</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>previousIndex()</code></td><td>返回由后续调用 <a href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的元素的索引</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>remove()</code></td><td>从列表中删除由 <a href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#next--"><code>next()</code></a>或 <a href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的最后一个元素（可选操作）</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>set(E e)</code></td><td>用 <a href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#next--">指定的</a>元素替换由 <a href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#next--"><code>next()</code></a>或 <a href="https://blog.csdn.net/qq_40991313/java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的最后一个元素（可选操作）</td></tr></tbody></table><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; it=sites.listIterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) System.out.println(it.next());</span><br></pre></td></tr></table></figure><hr><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>参考链接：<a href="https://blog.csdn.net/FAQEW/article/details/146542959">HashMap底层原理</a>、<a href="https://blog.csdn.net/winterPassing/article/details/148248794">HashMap安全性问题</a>、<a href="https://blog.csdn.net/qq_42077317/article/details/138009817">Java中的ConcurrentHashMap原理详解</a></p><p>HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。其核心实现包括数组+链表（JDK1.7及之前）或数组+链表+红黑树（JDK1.8及之后），通过哈希冲突解决机制（链地址法）和动态扩容优化性能。</p><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>使用场景</strong>: 适用于需要基于键值对快速查找数据的场景。“键”可以理解为钥匙，通过这个钥匙，可以找到它唯一对应的“值”。</p><p><strong>底层</strong>: 哈希表（数组+链表/红黑树）。</p><p><strong>性能</strong>:</p><ul><li><strong>查询性能</strong>: 快，时间复杂度为 O(1)。</li><li><strong>添加性能</strong>: 快，时间复杂度为 O(1)。</li><li><strong>删除性能</strong>: 快，时间复杂度为 O(1)。</li></ul><p><strong>是否允许 null</strong>:</p><ul><li>键可以为 null（但最多一个键为 null）。</li><li>值可以为 null。</li></ul><h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><strong>put()：</strong>向映射中添加一个键值对。如果键已经存在，则更新其对应的值<ol><li>计算键的哈希值并定位桶索引。</li><li>桶为空：直接插入新节点。</li><li>桶非空：遍历链表或红黑树，若存在相同键（通过<code>equals</code>判断），则更新值；否则追加节点。</li><li>触发扩容：插入后检查元素总数是否超过阈值</li></ol></li><li><strong>get()：</strong>根据键获取对应的值。根据哈希值定位桶，遍历链表或红黑树，通过<code>equals</code>匹配键</li><li><strong>getOrDefault()：</strong>获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值</li><li><strong>keySet()：</strong>返回所有key的Set集合</li><li><strong>remove(Object key):</strong> 根据键移除键值对</li><li><strong>containsKey(Object key):</strong> 检查是否包含指定键</li><li><strong>containsValue(Object value):</strong> 检查是否包含指定值</li><li><strong>size():</strong> 返回映射中的键值对数量</li><li><strong>isEmpty():</strong> 检查映射是否为空</li><li><strong>clear():</strong> 移除映射中的所有键值对</li></ul><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 HashMap</span></span><br><span class="line">        Map&lt;String, String&gt; fruitColor = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用 put() 方法向映射中添加键值对</span></span><br><span class="line">        fruitColor.put(<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;红色&quot;</span>);fruitColor.put(<span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;黄色&quot;</span>);fruitColor.put(<span class="string">&quot;樱桃&quot;</span>, <span class="string">&quot;红色&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加键值对后: &quot;</span> + fruitColor);</span><br><span class="line">        <span class="comment">// 使用 get() 方法根据键获取对应的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> fruitColor.get(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;键 &#x27;香蕉&#x27; 对应的值: &quot;</span> + value);</span><br><span class="line">        <span class="comment">// 遍历 keySet</span></span><br><span class="line">        Set&lt;String&gt; keys = fruitColor.keySet();</span><br><span class="line">        System.out.println(<span class="string">&quot;遍历 keySet:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;水果: &quot;</span> + key + <span class="string">&quot; 颜色: &quot;</span> + fruitColor.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 containsKey() 方法检查是否包含指定键</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsKeyBanana</span> <span class="operator">=</span> fruitColor.containsKey(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;包含键 &#x27;香蕉&#x27;: &quot;</span> + containsKeyBanana);</span><br><span class="line">        <span class="comment">// 使用 containsValue() 方法检查是否包含指定值</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsValueYellow</span> <span class="operator">=</span> fruitColor.containsValue(<span class="string">&quot;黄色&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;包含值 &#x27;黄色&#x27;: &quot;</span> + containsValueYellow);</span><br><span class="line">        <span class="comment">// 使用 size() 方法返回映射中的键值对数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> fruitColor.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;映射的大小: &quot;</span> + size);</span><br><span class="line">        <span class="comment">// 使用 isEmpty() 方法检查映射是否为空</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> fruitColor.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;映射是否为空: &quot;</span> + isEmpty);</span><br><span class="line">        <span class="comment">// 使用 remove() 方法根据键移除键值对</span></span><br><span class="line">        fruitColor.remove(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;移除键 &#x27;香蕉&#x27; 后: &quot;</span> + fruitColor);</span><br><span class="line">        <span class="comment">// 再次使用 size() 方法返回映射中的键值对数量</span></span><br><span class="line">        size = fruitColor.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;移除后映射的大小: &quot;</span> + size);</span><br><span class="line">        <span class="comment">// 使用 clear() 方法移除映射中的所有键值对</span></span><br><span class="line">        fruitColor.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空映射后: &quot;</span> + fruitColor);</span><br><span class="line">        <span class="comment">// 使用 isEmpty() 方法检查映射是否为空</span></span><br><span class="line">        isEmpty = fruitColor.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空后映射是否为空: &quot;</span> + isEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><code>HashMap</code>是基于哈希表实现的键值对存储结构，HashMap的核心实现结合了<code>数组</code>、<code>链表</code>和<code>红黑树</code>。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>数组</code>：默认初始容量为16，数组的每个位置称为一个桶(<code>Bucket</code>)。容量始终为<strong>2的幂次方</strong>(如16、32)，便于通过位运算快速定位索引。<br><code>链表</code>：当多个键的哈希值冲突时，这些键值对以链表形式存储在同一个桶中（链地址法）。<br><code>红黑树</code>：当链表长度超过阈值（默认8）且数组容量≥64时，链表会转换为<code>红黑树</code>，以提高查找效率（从<code>O(n)</code>优化为<code>O(log n)</code>）。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250727210620835.png" alt="image-20250727210620835"></p><h3 id="哈希函数与索引定位"><a href="#哈希函数与索引定位" class="headerlink" title="哈希函数与索引定位"></a>哈希函数与索引定位</h3><p>HashMap通过哈希函数将键映射到数组的索引位置。具体步骤如下：</p><ol><li><p>调用键的<code>hashCode()</code>方法获取哈希值。</p></li><li><p><strong>扰动处理：</strong>将高16位与低16位异或<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，减少哈希碰撞概率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>(n-1) &amp; hash</code>计算桶位置，等价于<code>hash % n</code>，但性能更高‌。</p></li></ol><h3 id="冲突处理机制"><a href="#冲突处理机制" class="headerlink" title="冲突处理机制"></a>冲突处理机制</h3><ol><li><p><strong>链地址法：</strong>冲突的键值对以链表形式链接。在JDK 8之前采用头插法，JDK 8之后采用尾插法以避免多线程下的死循环问题‌</p></li><li><p><strong>红黑树转换：</strong></p><ol><li><p>当链表长度≥8且数组容量≥64时，链表会转换为红黑树‌。</p></li><li><p>红黑树节点数≤6时，退化为链表</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250623125725272.png" alt="image-20250623125725272"></p></li></ol></li></ol><blockquote><p><strong>红黑树：</strong> 近似平衡二叉树，左右子树高差有可能大于 1，查找效率略低于平衡二叉树，但增删效率高于平衡二叉树，适合频繁插入删除。</p><ul><li>结点非黑即红；</li><li>根结点是黑色，叶节点是黑色空节点（常省略）；</li><li>任何相邻节点不能同时为红色；</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；</li><li>查询性能稳定O(logN)，高度最高2log(n+1)；</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250727210703513.png" alt="image-20250727210703513"></p></blockquote><h3 id="动态扩容机制"><a href="#动态扩容机制" class="headerlink" title="动态扩容机制"></a>动态扩容机制</h3><p>HashMap的扩容机制基于负载因子（默认值为0.75）。当元素数量超过<code>容量乘以负载因子</code>时，比如<strong>当数组添加到16*0.75=12时</strong>，HashMap会自动触发扩容，扩容为自身的两倍：16*2=32。扩容步骤如下：</p><ol><li>创建一个新的数组，<code>容量为原容量的两倍</code>（保持2的幂次方）。采用2的指数进行扩容，是为了利用位运算，提高扩容运算的效率。</li><li>重新计算所有元素的位置并放入新数组的对应位置，利用高位快速判断元素是否需要移动（如原索引为<code>oldIndex</code>，新索引可能为<code>oldIndex</code>或<code>oldIndex + oldCapacity</code>）。</li><li>数组每个元素存的是链表头结点地址，链地址法处理冲突，若链表的长度达到了8，红黑树代替链表。扩容后，链表或红黑树可能会被拆分到不同的桶中‌。</li></ol><h3 id="HashMap如何计算key"><a href="#HashMap如何计算key" class="headerlink" title="HashMap如何计算key"></a>HashMap如何计算key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key=value&amp;(2^n-1) <span class="comment"># 结果相当于value%(2^n)，使用位运算只要是为了提高计算速度。</span></span><br></pre></td></tr></table></figure><p>例如当前数组容量是16，我们要存取18，那么就可以用18&amp;15==2。相当于18%16==2。</p><blockquote><p> put()里，计算key的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// 此处省略了代码</span></span><br><span class="line">    <span class="comment">// i = (n - 1) &amp; hash]</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 省略了代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="HashMap容量为什么是2的n次方"><a href="#HashMap容量为什么是2的n次方" class="headerlink" title="HashMap容量为什么是2的n次方"></a>HashMap容量为什么是2的n次方</h3><p>计算value对应key的Hash运算：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key=value&amp;(2^n-1）<span class="comment">#结果相当于value%(2^n)。例如18&amp;15和18%16值是相等的</span></span><br></pre></td></tr></table></figure><p>2^n-1和2^(n+1)-1的二进制除了第一位，后几位都相同。这样<em>使得添加的元素均匀分布在HashMap的每个位置上，防止哈希碰撞</em>。</p><p><strong>例如</strong>15的二进制为1111，31的二进制为11111，63的二进制为111111，127的二进制为1111111。</p><p><strong>扩容均匀散列演示：从2^4扩容成2^5</strong></p><p>0&amp;(2^4-1)=0；0&amp;(2^5-1)=0</p><p>16&amp;(2^4-1)=0；16&amp;(2^5-1)=16。所以扩容后，key为0的一部分value位置没变，一部分value迁移到扩容后的新位置。</p><p>1&amp;(2^4-1)=1；1&amp;(2^5-1)=1</p><p>17&amp;(2^4-1)=1；17&amp;(2^5-1)=17。所以扩容后，key为1的一部分value位置没变，一部分value迁移到扩容后的新位置。</p><h3 id="put-流程"><a href="#put-流程" class="headerlink" title="put()流程"></a>put()流程</h3><ol><li>计算key存取位置，与运算hash&amp;(2^n-1），实际就是哈希值取余，位运算效率更高。</li><li>判断数组，若发现数组为空，则进行首次扩容为初始容量16。</li><li>判断数组存取位置的头节点，若发现头节点为空，则新建链表节点，存入数组。</li><li>判断数组存取位置的头节点，若发现头节点非空，则看情况将元素覆盖或插入链表（JDK7头插法，JDK8尾插法）、红黑树。</li><li>插入元素后，判断元素的个数，若发现超过阈值则以2的指数再次扩容。</li></ol><p>其中，第3步又可以细分为如下三个小步骤：</p><ol><li><p>若元素的key与头节点的key一致，则直接覆盖头节点。</p></li><li><p>若元素为树型节点，则将元素追加到树中。</p></li><li><p> 若元素为链表节点，则将元素追加到链表中。追加后，需要判断链表长度以决定是否转为红黑树。若链表长度达到8、数组容量未达到64，则扩容。若链表长度达到8、数组容量达到64，则转为红黑树。</p></li></ol><p><strong>哈希表处理冲突：</strong>开放地址法（线性探测、二次探测、再哈希法）、链地址法</p><h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><ul><li><p><strong>遍历EntrySet（键值对）</strong>：支持通过<code>iterator.remove()</code>安全删除元素(优点)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>遍历KeySet（仅键）</strong>：性能低于<code>EntrySet</code>遍历，需多次调用<code>get()</code>（缺点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;K&gt; keyIterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">// 需要额外查询值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for-each循环"></a>for-each循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历EntrySet</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历键</span></span><br><span class="line"><span class="keyword">for</span> (K key : map.keySet()) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span> (V value : map.values()) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式遍历（Java-8-）"><a href="#Lambda表达式遍历（Java-8-）" class="headerlink" title="Lambda表达式遍历（Java 8+）"></a>Lambda表达式遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach( (key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value) );</span><br></pre></td></tr></table></figure><h3 id="Stream-API遍历（Java-8-）"><a href="#Stream-API遍历（Java-8-）" class="headerlink" title="Stream API遍历（Java 8+）"></a>Stream API遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程遍历</span></span><br><span class="line">map.entrySet().stream().forEach(entry -&gt; ...);</span><br><span class="line"><span class="comment">// 多线程遍历</span></span><br><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; ...);</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table><thead><tr><th><strong>遍历方式</strong></th><th><strong>时间复杂度</strong></th><th><strong>适用场景</strong></th><th><strong>线程安全</strong></th></tr></thead><tbody><tr><td>EntrySet迭代器</td><td>O(n)</td><td>需要删除元素</td><td>需手动同步</td></tr><tr><td>EntrySet for-each</td><td>O(n)</td><td>常规遍历</td><td>需手动同步</td></tr><tr><td>KeySet遍历</td><td>O(n)（性能较低）</td><td>仅需键</td><td>需手动同步</td></tr><tr><td>Lambda表达式</td><td>O(n)</td><td>代码简洁性优先</td><td>需手动同步</td></tr><tr><td>Stream API</td><td>O(n)</td><td>大数据量处理或并行计算</td><td>需手动同步</td></tr></tbody></table><p><strong>推荐选择</strong>：</p><ul><li><strong>需键值对</strong>：优先使用<code>entrySet()</code>（迭代器或for-each）。</li><li><strong>仅需键或值</strong>：直接遍历<code>keySet()</code>或<code>values()</code>。</li><li><strong>代码简洁性</strong>：Java 8+环境下推荐Lambda表达式。</li><li><strong>线程安全</strong>：改用<code>ConcurrentHashMap</code>或使用同步包装类。</li></ul><h2 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别"></a>HashMap和HashSet区别</h2><p><strong>相同点：</strong></p><ul><li><p>他们的前缀的是HashXxx，代表他们底层都是哈希表，用hashCode()判断元素是否重复。</p><p>哈希表增删改查的时间复杂度是O(1)，缺点是可能出现冲突。</p><p>HashXxx都使用哈希算法来确定元素的存储位置，因此插入元素的速度通常比较快。哈希表插入时主要看是否发生冲突，如果key通过哈希算法计算后的值所处位置已有元素，则需要根据链地址法或开放地址法处理冲突。</p></li></ul><p><strong>不同点：</strong></p><table><thead><tr><th align="left">特性</th><th align="left">HashMap</th><th align="left">HashSet</th></tr></thead><tbody><tr><td align="left"><strong>接口</strong></td><td align="left">实现了 Map 接口</td><td align="left">实现了 Set 接口</td></tr><tr><td align="left"><strong>存储结构</strong></td><td align="left">存储<strong>键值对</strong>（Key-Value pairs）</td><td align="left">仅存储<strong>对象</strong>（Unique elements）</td></tr><tr><td align="left"><strong>存储方式</strong></td><td align="left">使用 put() 方法将元素放入 Map 中</td><td align="left">使用 add() 方法将元素放入 Set 中</td></tr><tr><td align="left"><strong>底层实现</strong></td><td align="left">基于哈希表，使用数组+链表+红黑树</td><td align="left">基于 <strong>HashMap</strong> 实现<strong>HashMap 的key是每个元素</strong>value是一个私有常量对象PRESENT，仅用于占位。</td></tr><tr><td align="left"><strong>存储内容</strong></td><td align="left">键和值都可以为 null，键最多只能有一个 null</td><td align="left">仅允许一个 null 元素因为它底层是HashMap的key，键只允许一个null</td></tr><tr><td align="left"><strong>是否允许重复</strong></td><td align="left">键不允许重复，值可以重复</td><td align="left">不允许重复元素</td></tr><tr><td align="left"><strong>时间复杂度</strong></td><td align="left">插入、删除、查找的平均时间复杂度为 O(1)</td><td align="left">插入、删除、查找的平均时间复杂度为 O(1)，但 contains() 时间复杂度可能更高</td></tr><tr><td align="left"><strong>插入速度</strong></td><td align="left">比较快，因为底层是哈希表</td><td align="left">比较快，因为底层是哈希表</td></tr><tr><td align="left"><strong>使用场景</strong></td><td align="left">需要键值对映射的场景</td><td align="left">需要存储唯一元素、自动去重的场景</td></tr></tbody></table><h2 id="HashMap安全"><a href="#HashMap安全" class="headerlink" title="HashMap安全"></a>HashMap安全</h2><p>HashMap是线程不安全的，多线程环境下建议使用Collections工具类和JUC包的ConcurrentHashMap。</p><blockquote><ul><li><strong>线程安全：</strong>程序在多线程环境下可以持续进行正确的处理，不会产生数据竞争（例如死锁）和不一致的问题。</li></ul></blockquote><h3 id="HashMap线程不安全的表现"><a href="#HashMap线程不安全的表现" class="headerlink" title="HashMap线程不安全的表现"></a>HashMap线程不安全的表现</h3><ol><li><p><strong>JDK8 put时数据覆盖（丢失）</strong><br><strong>场景：</strong>多线程同时调用 <code>put()</code> 方法插入数据。<br><strong>原因：</strong>两个线程同时计算哈希值并定位到同一个桶(bucket)时，若该位置为空，可能发生数据覆盖。<strong>无锁导致复合操作非原子性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设线程A和线程B同时执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> (table[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line"> table[bucket] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value); <span class="comment">// 可能被覆盖</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK 1.8 的数据覆盖问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapUnsafeDemo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">             map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">             map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     t1.start();</span><br><span class="line">     t2.start();</span><br><span class="line">     t1.join();</span><br><span class="line">     t2.join();</span><br><span class="line">     System.out.println(<span class="string">&quot;Map size: &quot;</span> + map.size()); <span class="comment">// 结果可能小于 1000</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 底层源码</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)     <span class="comment">// 如果没有 hash 碰撞，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>链表成环</strong>（JDK7 的经典问题）<br><strong>场景：</strong>多线程同时触发 <code>resize()</code>（扩容）。<br><strong>原因：</strong>JDK7 的 HashMap 使用<strong>头插法</strong>迁移链表，<strong>并发扩容时可能导致链表成环</strong>，后续的 <code>get()</code>操作触发死循环。</p><p><strong>单线程扩容流程</strong>：JDK7中，HashMap链地址法处理冲突时采用头插法，在扩容时依然头插法，所以链表里结点顺序会反过来。</p><p>假如有T1、T2两个线程同时对某链表扩容，他们都标记头结点和第二个结点，此时T2阻塞，T1执行完扩容后链表结点顺序反过来，此时T2恢复运行再进行翻转就会产生环形链表，即B.next=A; A.next=B，从而死循环。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250724151230023.png" alt="image-20250724151230023"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7 的扩容代码（简化）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">     <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">         Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程A执行到这里挂起</span></span><br><span class="line">         e.next = newTable[bucket]; <span class="comment">// 线程B先执行，导致链表成环</span></span><br><span class="line">         newTable[bucket] = e;</span><br><span class="line">         e = next;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK8 尾插法：</strong>JDK8中，HashMap采用尾插法，扩容时链表节点位置不会翻转，解决了扩容死循环问题，但是性能差了一点，因为要遍历链表再查到尾部。 例如A——&gt;B——&gt;C要迁移，迁移时先移动头结点A，再移动B并插入A的尾部，再移动C插入尾部，这样结果还是A——&gt;B——&gt;C。顺序没变，扩容线程。</p></li><li><p><strong>size 不准确</strong><br><strong>场景：</strong>多线程同时调用 <code>put()</code> 或 <code>remove()</code>。<br><strong>原因：</strong>size 变量是非原子操作（如 size++），并发修改可能导致最终值错误。<strong>非原子操作 + 无可见性保证</strong>。</p></li><li><h5 id="modCount非原子性自增问题"><a href="#modCount非原子性自增问题" class="headerlink" title="modCount非原子性自增问题"></a><strong>modCount非原子性自增问题</strong></h5><p>modCount： HashMap的成员变量，用于记录HashMap被修改次数</p><p>put会执行modCount++操作（modCount是HashMap的成员变量，用于记录HashMap被修改次数），这步操作分为读取、增加、保存，不是一个原子性操作，也会出现线程安全问题。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// put会执行modCount++操作，这步操作分为读取、增加、保存，不是一个原子性操作，也会出现线程安全问题。 </span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="HashMap线程不安全的根本原因"><a href="#HashMap线程不安全的根本原因" class="headerlink" title="HashMap线程不安全的根本原因"></a>HashMap线程不安全的根本原因</h3><ol><li><strong>无同步机制</strong><br>HashMap 的设计目标是单线程高性能，未对多线程操作进行同步（如 <code>synchronized</code> 或 <code>CAS</code>）。<br>关键操作（<code>put()、get()、resize()</code>）没有锁保护。</li><li><strong>可见性问题</strong><br>多线程修改共享变量（如 <code>table、size</code>）时，未使用 <code>volatile</code> 关键字，可能导致一个线程的修改对其他线程不可见。</li><li><strong>复合操作非原子性</strong><br>例如 <code>put()</code> 操作包含多个步骤（计算哈希、定位桶、插入节点），多线程交叉执行时可能破坏内部结构。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>原子类、volatile、锁、线程安全的集合 </p><ol><li>使用线程安全的替代类<pre><code>`Collections.synchronizedMap()`：通过包装类对所有方法加锁（性能较差）。`ConcurrentHashMap`：分段锁（JDK 1.7）或 CAS + synchronized（JDK 1.8），高并发性能更好。</code></pre></li><li>避免多线程直接操作 HashMap<br>限制为单线程使用，或通过副本、消息队列等方式隔离并发访问。</li></ol><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>在<code>jdk1.7</code>版本<ul><li>ConcurrentHashMap的数据结构是由一个<code>Segment</code>数组和多个<code>HashEntry</code>组成。</li><li>主要实现原理是实现了<strong>锁分离</strong>的思路，采用<strong>分段锁的机制</strong>，实现并发的更新操作。</li><li>底层采用<strong>数组+链表</strong>的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。</li><li>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到 的锁分离技术。每一个Segment元素存储的是HashEntry 数组+链表（若干个桶），这个和HashMap的数据存储结构一样。</li><li>HashEntry用来封装映射表的键值对，每个桶是由若干个HashEntry对象链接起来的链表。</li></ul></li><li>在<code>jdk1.8</code>后<ul><li>取消了Segment类，直接用table数组存储键值对。采用<code>Node + CAS + Synchronized</code>来保证并发安全。</li><li>Node数据结构比较简单，就是一个链表，但是只允许对数据进行查找，不允许进行修改。</li><li>当HashEntry对象组成的链表长度超过8时，或数组长度小于64 就会扩容，则链表转换为红黑树，提升性能。底层变更为<strong>数组＋链表＋红黑树</strong>。</li></ul></li></ul><h4 id="底层原理（jdk1-8）"><a href="#底层原理（jdk1-8）" class="headerlink" title="底层原理（jdk1.8）"></a>底层原理（jdk1.8）</h4><ol><li><p>Node节点数字用的是<code>volatile</code>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap使用volatile修饰节点数组，保证其可见性，禁止指令重排。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>ConcurrentHashMap的<code>put()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put()方法直接调用putVal()方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以直接看putVal()方法。</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            tab = initTable();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法并未用synchronized修饰。<strong>put过程如下：</strong><br>（1）根据 key 计算出 hashcode，然后开始遍历 table；<br>（2）判断是否需要初始化；<br>（3）f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。<br>（4）如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。<br>（5）如果都不满足，则利用 synchronized 锁写入数据。<br>（6）如果数量大于 TREEIFY_THRESHOLD ，则要转换为红黑树。</p></li><li><p>ConcurrentHashMap的<code>get()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap的get()方法是不加锁的，方法内部也没加锁。</span></span><br><span class="line"><span class="comment">// 因为table有`volatile`关键字修饰，保证每次获取值都是最新的。</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure><p>get方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头节点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get过程如下：</strong><br>（1）首先根据key计算出来的 hashcode 寻址，如果就在桶上那么直接返回值，<br>（2）如果是红黑树那就按照树的方式获取值，<br>（3）都不满足那就按照链表的方式遍历获取值。</p></li></ol><hr><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>参考链接：<a href="https://blog.csdn.net/m0_37741420/article/details/112407684">Java集合（四）Set的常用实现类</a></p><p>List是有序集合的根接口，Set是无序集合的根接口，无序也就意味着元素不重复。更严格地说，Set集合不包含一对元素e1和e2 ，使得e1.equals(e2) ，并且最多一个空元素。<br>使用Set存储的特点与List相反：<strong>元素无序、不可重复</strong>。常用的实现方式：HashSet、LinkedHashSet和TreeSet。</p><table><thead><tr><th>具体实现</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashSet</td><td>底层数据结构是哈希表，可以存储null元素，效率高</td><td>线程不安全，需要重写hashCode()和equals()来保证元素唯一性</td></tr><tr><td>LinkedHashSet</td><td>底层数据结构是链表和哈希表(链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性)，效率高</td><td>线程不安全</td></tr><tr><td>TreeSet</td><td>底层数据结构是二叉树，元素唯一且已经排好序</td><td>需要重写hashCode和equals()来保证元素唯一性</td></tr></tbody></table><p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的<code>hashCode()</code>方法来得到该对象的hashCode值，然后根据hashCode值来决定该对象在HashSet中存储位置。简单的说，<strong>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等</strong>。<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p><p>在使用Set存储数据时，为保障元素唯一性，常常要重写hashCode。重写hashCode方法时，尽量遵循以下原则：</p><ul><li>相同的对象返回相同的hashCode值。</li><li>不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。</li><li>尽量的让hashCode值散列开（用异或运算可使结果的范围更广）。</li></ul><h2 id="Hashset"><a href="#Hashset" class="headerlink" title="Hashset"></a>Hashset</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>HashSet是一个无序集合，其底层结构是HashMap，简单来说，HashSet是value是固定值（<code>Object PRESENT = new Object()</code>）的HashMap。HashSet的特点(<strong>底层是HashMap/元素无序且不能重复/线程不安全</strong>)：</p><ul><li><p><strong>使用场景：</strong>需要高效去重、快速查找、不考虑内存浪费的场景</p></li><li><p>HashSet的<strong>底层实现是HashMap</strong>（HashSet的值存放于HashMap的key上，HashMap的value是一个统一的值）。</p></li><li><p><strong>底层：</strong>哈希表（快速查找）和Set（去重）。它自动对元素进行去重（通过 hashCode 和 equals 方法），并且无序（存入后顺序会乱），允许存储一个null值。</p></li><li><p><strong>性能：</strong>底层是哈希表，所以插入、删除和查找操作的时间复杂度都是O(1)，代价是浪费一些空间。</p></li><li><p><strong>线程不安全</strong>。如果要保证线程安全，其中一种方法是将其改造成线程安全的类，示例：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>(...));</span><br></pre></td></tr></table></figure></li></ul><p>哈希表是元素为链表的数组，默认容量16，负载因子0.75，处理冲突方法是链地址法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;String &gt; h = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        h.add(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">        h.add(s1);</span><br><span class="line">        System.out.println(s1 == <span class="string">&quot;nihao&quot;</span>);        <span class="comment">//false</span></span><br><span class="line">        <span class="keyword">for</span>(String s:h) System.out.println(s);     <span class="comment">//不含重复元素 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果Hashset里的元素是对象，若想将成员变量相同视为对象相同，要重写hashCode()：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="comment">//输出23</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>);</span><br><span class="line">        HashSet&lt;Dog&gt; h = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Dog&gt;();</span><br><span class="line">        h.add(dog1);h.add(dog2);</span><br><span class="line">        <span class="keyword">for</span>(Dog dog:h)&#123;</span><br><span class="line">            System.out.println(dog.weight); </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//         System.out.println(&quot;doggouzaao&quot;);</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> weight)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.weight=weight;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;dogname&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// alt+insert生成equals()和hashCode()方法。这里只需重写hashCode方法就能保证自动去重，equals方法用于元素间的比较</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">        <span class="keyword">return</span> weight == dog.weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p><strong>HashSet自动去重的原理：</strong>hashCode值。</p><p>所有Java的类或接口都直接或间接继承了Object类，Object类是一切类的根类。Object类有<code>clone()，HashCode()，equals()，toString()，wait()，notify()</code>等基本方法，可以重写这些方法，对类的特性进行设置。</p><p>例如给测试类新加一个hashCode()方法，而不加@Override注解（用于声明一个方法为重写的方法），编译器将进行警告：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译器将进行警告：hashCode()&#x27;缺少&#x27;@Override&#x27;注解</span></span><br></pre></td></tr></table></figure><p>默认情况下，哈希值是根据对象的地址计算出的一个整数值，故同一对象的哈希值一定相同（因为地址是同一地址），不同对象的哈希值默认不同（因为地址不同）。</p><p>把对象加入HashSet时，HashSet会<strong>先计算对象的hashcode值来判断对象加入的位置</strong>，同时也会与Set中其他元素的hashcode值作比较，如果没有相同的hashcode，HashSet会假设对象没有重复出现。如果发现有相同hashcode值的对象，这时会调用<code>equals</code>方法来检查<strong>hashcode相等的对象是否真的相同</strong>。如果两者相同，HashSet就不再存储该元素。<code>hashCode()</code>与 <code>equals()</code>的相关规定：</p><ul><li>如果两个对象相等，则hashcode一定也是相同的；</li><li>两个对象相等，对两个equals方法返回true；</li><li>两个对象有相同的hashcode值，它们也不一定是相等的；</li><li>如果equals方法被覆盖过，则hashCode方法也必须被覆盖；</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ul><p>重写hashCode()后哈希值可以相同，例如给Student类重写hashCode()，返回学生的学号，那么学号相同的学生，哈希值就一定相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 hashCode() 方法，返回学号作为哈希值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 equals() 方法，判断学号是否相同</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">        <span class="keyword">return</span> id == student.id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 toString() 方法，返回学生姓名和学号</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, id=&quot;</span> + id + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 根据重写的 equals() 方法输出</span></span><br><span class="line">        System.out.println(student1.equals(student2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(student1.hashCode()); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(student2.hashCode()); <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 根据重写的 toString() 方法输出</span></span><br><span class="line">        System.out.println(student1.toString()); <span class="comment">// Student&#123;name=&#x27;Tom&#x27;, id=1&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> <span class="comment">// 默认初始容量为16，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> <span class="comment">// 指定初始容量，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> <span class="comment">// 指定初始容量和负载因子</span></span><br><span class="line"><span class="comment">/* 增、删、包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断Set是否为空    </span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> <span class="comment">//获取迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回此集合中的元素数        </span></span><br></pre></td></tr></table></figure><h3 id="知识加油站-1"><a href="#知识加油站-1" class="headerlink" title="知识加油站"></a>知识加油站</h3><h4 id="equals-和hashcode-的关系"><a href="#equals-和hashcode-的关系" class="headerlink" title="equals()和hashcode()的关系"></a>equals()和hashcode()的关系</h4><p><strong>两者在用途上的区别：</strong></p><ul><li>hashCode()方法的主要用途是获取哈希码；</li><li>equals()主要用来比较两个对象是否相等。</li></ul><h4 id="为什么重写equals-就要重写hashcode"><a href="#为什么重写equals-就要重写hashcode" class="headerlink" title="为什么重写equals()就要重写hashcode()"></a><strong>为什么重写equals()就要重写hashcode()</strong></h4><p>因为二者之间有两个约定，<strong>相等对象的哈希码也要相等</strong>。所以equals()方法重写时，通常也要将hashCode()进行重写，使得这两个方法始终满足相关的约定。 例如HashSet排序机制底层就是通过计算哈希码进行排序的，如果只重写equals()将达不到根据哈希码排序的效果。</p><p>如果两个对象相等，它们必须有相同的哈希码；但如果两个对象的哈希码相同，他们却不一定相等。</p><h4 id="与equals-的区别"><a href="#与equals-的区别" class="headerlink" title="==与equals()的区别"></a><code>==</code>与equals()的区别</h4><ul><li><p><strong><code>==</code></strong> 比较基本数据类型时，比较的是两个数值是否相等； 比较引用类型是，比较的是对象的内存地址是否相等。  </p></li><li><p><strong><code>equals()</code></strong> 未重写时，Object类默认以<code>==</code>来实现，即比较两个对象的内存地址是否相等； 重写以后，按照重写的逻辑进行比较。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(0bject obj)</span> &#123; <span class="keyword">return</span>(<span class="built_in">this</span> == obj); &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet是有序集合，其底层是通过LinkedHashMap来实现的，LinkedHashMap其实也就是value是固定值的LinkedHashMap。因此LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。LinkedHashSet继承了HashSet。LinkedHashSet的特点(<strong>底层是LinkedHashMap/线程不安全/元素有序</strong>)：</p><ul><li><p>底层是用LinkedHashMap来实现的。</p></li><li><p>线程不安全 。</p></li><li><p>元素有序，是按照插入的顺序排序的。</p></li><li><p>最多只能存一个null。</p></li><li><p>不支持按访问顺序对元素排序</p><p>LinkedHashSet所有的构造方法都是调用HashSet的同一个构造方法：（accessOrder = false）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li><p><strong>使用场景：</strong>适用于多读少写、排序的场景。</p></li><li><p><strong>底层：</strong>红黑树（快速查找、排序）和Set（去重）。<strong>不允许存储null值</strong></p></li><li><p><strong>性能：</strong>插入、删除、查找操作的时间复杂度为O(log n)，因为操作需要维护树的平衡，所以适用于多读少写的场景。</p></li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>TreeSet是一个有序集合，基于TreeMap实现。TreeSet特点(<strong>支持元素排序/线程不安全/去重复</strong>):</p><ul><li><p>TreeSet的基本操作（增删）的时间复杂度是log(n) 。</p></li><li><p>TreeSet是非线程安全的。</p></li><li><p>TreeSet的迭代器是fail-fast策略的。</p></li><li><p>TreeSet中元素不允许为null，不允许重复值。</p></li><li><p>TreeSet有序（自然顺序或自定义排序器）。支持元素自然排序和按照在创建时指定Comparator比较器(外比较器)进行排序：</p><ul><li>TreeSet使用二叉树原理对新增对象按照指定顺序排序，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li></ul></li></ul><pre><code>- TreeSet中存储自定义类的对象时， 自定义的类必须实现Comparable接口，并且覆写相应`compareTo()`函数。- **元素为基本类型时自然有序：**new TreeSet&lt;int&gt;()。如果TreeSet内元素是**基本数据类型**，它会自动去重有序。Integer和String对象都可以进行默认的TreeSet排序。- **元素为类时自然或比较器排序：**new TreeSet&lt;类&gt;(Comperable c)。如果TreeSet内元素是类，要实现去重有序，有两种方法。  - **自然排序：**类要实现Comparable&lt;&gt;接口，并重写compareTo（T）方法；  - **比较器排序：**以比较器作为构造参数，创建TreeSet对象。如果即实现了Comparable&lt;&gt;接口，又指定了比较器，则使用比较器排序。  - 在重写compareTo()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。示例：    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>  <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(student s)</span> &#123;</span><br><span class="line">        <span class="comment">// 主要条件：按照年龄从小到大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="built_in">this</span>.age - s.age;</span><br><span class="line">        <span class="comment">//次要条件：年龄相同时，按照姓名的字母顺序排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num == <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(s.name) : num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comparabledemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;student&gt; tree = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;student&gt;();</span><br><span class="line">        <span class="type">student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;wuer&quot;</span>,<span class="number">27</span>);</span><br><span class="line">        <span class="type">student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;weuers&quot;</span>,<span class="number">250</span>);</span><br><span class="line">        tree.add(s1);</span><br><span class="line">        tree.add(s2);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="方法一：自然排序"><a href="#方法一：自然排序" class="headerlink" title="方法一：自然排序"></a>方法一：自然排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗类：按自然排序时要实现Comperable&lt;&gt;并重写compareTo()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>  <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt;&#123;        </span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> weight, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123; weight=&quot;</span> + weight + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog dog)</span>&#123;    <span class="comment">// 实参是上一只狗，本狗与上狗做比较</span></span><br><span class="line">        <span class="comment">// 返回正数，即本狗比上只狗大，按存取顺序排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// return -1; 存储逆序排序</span></span><br><span class="line">        <span class="comment">// return 0; 视为相等，后插入的重复元素会被删除。</span></span><br><span class="line">        <span class="comment">// return this.weight-dog.weight; 按体重从小到大排序，后狗-前狗。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个小狗对象，让他们按自己compareTo()逻辑排序，即按存取顺序排序</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">23</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">45</span>,<span class="string">&quot;abc&quot;</span>); <span class="type">Dog</span> <span class="variable">dog3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">45</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        TreeSet&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        dogs.add(dog1);dogs.add(dog2);dogs.add(dog3);</span><br><span class="line">        <span class="comment">// 因为第三只狗和第二只狗存取顺序不同，所以他们被认为是两只狗</span></span><br><span class="line">        <span class="comment">// [Dog&#123;weight=23, name=&#x27;abc&#x27;&#125;, Dog&#123;weight=45, name=&#x27;abc&#x27;&#125;, Dog&#123;weight=45, name=&#x27;abc&#x27;&#125;]</span></span><br><span class="line">        System.out.println(dogs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：比较器排序"><a href="#方法二：比较器排序" class="headerlink" title="方法二：比较器排序"></a>方法二：比较器排序</h3><p>无需Dog类再实现Comparable接口，直接TreeSet类带参构造方式创建对象即可，参数为比较器Comparator&lt;&gt;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗类：按比较器排序时不需要再实现Comperable&lt;&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> weight, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123; weight=&quot;</span> + weight + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">        <span class="keyword">return</span> weight == dog.weight &amp;&amp; Objects.equals(name, dog.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(weight, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//下面比较器也可以用Lambda表达式形式，即TreeSet&lt;&gt;((a,b)-&gt;&#123;..&#125;)</span></span><br><span class="line">        TreeSet&lt;Dog&gt; dogs=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Dog&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dog a, Dog b)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a.weight!=b.weight) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a.weight-b.weight;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a.name.compareTo(b.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">34</span>,<span class="string">&quot;abc&quot;</span>)); dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">26</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">26</span>,<span class="string">&quot;abcd&quot;</span>)); dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">26</span>,<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line">        <span class="comment">// 可以看见，前三只狗按体重、名称排序，第四只狗被去重了</span></span><br><span class="line">        <span class="comment">// [Dog&#123;weight=26, name=&#x27;abc&#x27;&#125;, Dog&#123;weight=26, name=&#x27;abcd&#x27;&#125;, Dog&#123;weight=34, name=&#x27;abc&#x27;&#125;]</span></span><br><span class="line">        System.out.println(dogs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> <span class="comment">// 创建一个空的 TreeSet，使用自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> <span class="comment">// 指定比较器，如果比较器是 null 将使用自然排序</span></span><br><span class="line"><span class="comment">/* 增 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="comment">// 添加一个元素</span></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">// 添加集合中的元素</span></span><br><span class="line"><span class="comment">/* 删 */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> <span class="comment">// 检索和删除最小（第一个）元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> <span class="comment">// 检索和删除最大（最后）元素</span></span><br><span class="line"><span class="comment">/* 包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 获取特殊元素 */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">last</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">first</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">floor</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中小于或者等于给定元素的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">ceiling</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中大于或者等于给定元素的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">higher</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中大于某个元素的最小的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">lower</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中小于某个元素的最大的元素   </span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 获取TreeSet元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断TreeSet是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空TreeSet</span></span><br></pre></td></tr></table></figure><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p><strong>相同点：</strong>元素都可以自动去重</p><p><strong>不同点：</strong></p><table><thead><tr><th align="left"></th><th align="left">HashSet</th><th><strong>TreeSet</strong></th></tr></thead><tbody><tr><td align="left"><strong>实现</strong></td><td align="left">基于哈希表 实现</td><td>基于红黑树 (Red-Black Tree) 实现</td></tr><tr><td align="left"><strong>排序</strong></td><td align="left">不保证顺序</td><td>按自然顺序或指定的比较器排序</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">插入、删除和查找操作的时间复杂度为 O(1)</td><td>插入、删除和查找操作的时间复杂度为 O(log n)</td></tr><tr><td align="left"><strong>是否允许 null 元素</strong></td><td align="left">允许存储一个 null 元素</td><td>不允许存储 null 元素</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">适用于对顺序无要求、自动去重、快速查找和插入的场景</td><td>适用于需要自动有序、去重存储的场景</td></tr><tr><td align="left"><strong>去重原理</strong></td><td align="left">通过复写hashCode()方法和equals()方法来保证</td><td>Treeset通过Compareable接口的compareto来保证。</td></tr></tbody></table><hr><h1 id="ArrayDeque：双端队列"><a href="#ArrayDeque：双端队列" class="headerlink" title="ArrayDeque：双端队列"></a>ArrayDeque：双端队列</h1><p>ArrayDeque 是 Java 中基于动态数组实现的双端队列（<code>Double-Ended Queue</code>），同时支持栈（Stack）和队列（Queue）的操作。在刷力扣等算法题时经常使用这个集合。</p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul><li>双端操作：可以在队列的头部和尾部高效地插入/删除元素（时间复杂度 O(1)）。</li><li>动态扩容：底层是循环数组，容量不足时自动扩容（默认初始容量为 16）。</li><li>非线程安全：需手动处理并发问题。</li><li>性能高：对比 LinkedList（基于链表），数组结构对 CPU 缓存更友好，随机访问更快。</li></ul><h2 id="作为栈（先进后出）的核心方法"><a href="#作为栈（先进后出）的核心方法" class="headerlink" title="作为栈（先进后出）的核心方法"></a>作为栈（先进后出）的核心方法</h2><table><thead><tr><th>操作类型</th><th>方法名</th><th>功能描述</th><th>返回值/异常</th></tr></thead><tbody><tr><td><strong>增</strong></td><td><strong><code>push(E element)</code></strong></td><td>压栈（元素添加到头部）</td><td>无返回值，队列满时自动扩容</td></tr><tr><td></td><td><code>addFirst(E element)</code></td><td>同 <code>push</code></td><td>队列满时抛出 <code>IllegalStateException</code>（但 <code>ArrayDeque</code> 动态扩容，一般不会）</td></tr><tr><td><strong>删</strong></td><td><strong><code>pop()</code></strong></td><td>弹栈（移除并返回头部元素）</td><td>返回头部元素；栈为空时抛出 <code>NoSuchElementException</code></td></tr><tr><td></td><td><code>removeFirst()</code></td><td>同 <code>pop()</code></td><td>同上</td></tr><tr><td><strong>查</strong></td><td><strong><code>peek()/peekFirst()</code></strong></td><td>查看栈顶元素（不删除）</td><td>返回头部元素；栈为空时返回 <code>null</code></td></tr><tr><td></td><td><strong>peekLast()</strong></td><td><strong>查看栈尾元素</strong>（不删除）</td><td>返回尾部元素；栈为空时返回 <code>null</code></td></tr></tbody></table><h2 id="作为队列（先进先出）的核心方法"><a href="#作为队列（先进先出）的核心方法" class="headerlink" title="作为队列（先进先出）的核心方法"></a>作为队列（先进先出）的核心方法</h2><table><thead><tr><th>操作类型</th><th>方法名</th><th>功能描述</th><th>返回值/异常</th></tr></thead><tbody><tr><td><strong>增</strong></td><td><strong><code>offer(E element)</code></strong></td><td>入队（元素添加到尾部）</td><td>成功返回 <code>true</code>，队列满时返回 <code>false</code>（但 <code>ArrayDeque</code> 动态扩容，总是成功）</td></tr><tr><td></td><td><code>addLast(E element)</code></td><td>同 <code>offer</code></td><td>队列满时抛出 <code>IllegalStateException</code>（理论上不会触发）</td></tr><tr><td><strong>删</strong></td><td><strong><code>poll()</code></strong></td><td>出队（移除并返回头部元素）</td><td>返回头部元素；队列为空时返回 <code>null</code></td></tr><tr><td></td><td><code>removeFirst()</code></td><td>同 <code>poll()</code></td><td>队列为空时抛出 <code>NoSuchElementException</code></td></tr><tr><td><strong>查</strong></td><td><strong><code>peek()/peekFirst()</code></strong></td><td>查看队首元素（不删除）</td><td>返回头部元素；队列为空时返回 <code>null</code></td></tr><tr><td></td><td><strong>peekLast()</strong></td><td><strong>查看队尾元素</strong>（不删除）</td><td>返回尾部元素；队列为空时返回 <code>null</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈</span></span><br><span class="line">ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 压栈</span></span><br><span class="line">stack.push(<span class="number">1</span>); stack.push(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 查看栈顶</span></span><br><span class="line">System.out.println(stack.peek()); <span class="comment">// 输出 2</span></span><br><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop(); <span class="comment">// 返回 2，栈中剩余 [1]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line">ArrayDeque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line">queue.offer(<span class="number">1</span>); queue.offer(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 查看队首</span></span><br><span class="line">System.out.println(queue.peek()); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 返回 1，队列中剩余 [2]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;集合类是Java数据结构的实现。Java的集合类是&lt;a href=&quot;https://baike.baidu.com/item/java.util/5180624?fromModule=lemma_inlink&quot;&gt;java.util&lt;/a&gt;包中的重要内容，它允许以各种方式将元</summary>
      
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
