<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-06-21T08:05:35.151Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://southernfish.github.io/2025/06/21/front-end-websocket/"/>
    <id>https://southernfish.github.io/2025/06/21/front-end-websocket/</id>
    <published>2025-06-21T05:33:36.000Z</published>
    <updated>2025-06-21T08:05:35.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>WebSocket</strong>是一种在单个<a href="https://baike.baidu.com/item/TCP/0?fromModule=lemma_inlink">TCP</a>连接上进行<a href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5/0?fromModule=lemma_inlink">全双工</a>通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><h2 id="WebSocket-的优势和适用场景是什么？">WebSocket 的优势和适用场景是什么？</h2><ol><li><code>WebSocket</code> 提供了<strong>低延迟的实时通信能力</strong>，能够在服务器端有新数据时立即推送给客户端。</li><li><code>WebSocket</code> 支持<strong>客户端和服务器之间的双向通信</strong>，可以实现实时聊天、实时数据更新等场景</li><li><code>WebSocket</code> 使<strong>用长连接，相对于频繁的短连接请求，减少了网络开销</strong>。</li><li><code>WebSocket</code> 具备<strong>跨域通信</strong>的能力，可以跨域进行实时通信</li></ol><p><strong>适用场景：<strong>实时聊天应用、股票行情推送、实时协作编辑、多人游戏、实时数据监控等</strong>需要实时双向通信的场景</strong>。</p><h2 id="WebSocket-的连接建立过程是怎样的？">WebSocket 的连接建立过程是怎样的？</h2><ol><li>客户端<strong>发送 <code>WebSocket</code> 握手请求</strong></li><li>服务器收到握手请求后，<strong>验证请求头的字段，并返回握手响应</strong></li><li>客户端收到握手响应后，<strong>验证响应头的字段，并生成一个 <code>Sec-WebSocket-Accept</code> 值进行验证</strong></li><li>验证通过后，<code>WebSocket</code> <strong>连接建立成功，客户端和服务器可以开始进行实时通信</strong></li></ol><h2 id="如何处理错误和关闭连接？">如何处理错误和关闭连接？</h2><p>WebSocket 在<strong>出现错误时会触发 error 事件</strong>，可以通过**设置 <code>onerror</code> 事件处理函数来处理错误。**例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = function(error) &#123;</span><br><span class="line">    console.error(&#x27;WebSocket 错误:&#x27;, error); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 WebSocket <strong>连接关闭时，会触发 close 事件</strong>，可以通过<strong>设置 <code>onclose</code> 事件处理函数</strong>来执行一些清理操作或重新连接等操作，可以通过<strong>调用 <code>close()</code> 方法来显式地关闭</strong> WebSocket 连接</p><h2 id="实际应用中，如何处理连接状态的变化和重连机制？">实际应用中，如何处理连接状态的变化和重连机制？</h2><p>在 <code>onopen</code> 事件中，使用 <code>setInterval</code> 方法定时发送心跳数据包。如<strong>每 5000 毫秒发送一次心跳数据包</strong>，如下所示代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws .onopen = function()&#123;</span><br><span class="line">  heartcheck = setInterval(function()&#123;</span><br><span class="line">    ws.send(&#x27;HeartBeat&#x27;); // 发送心跳数据包</span><br><span class="line">  &#125;，5000); // 时间间隔，单位毫秒</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>onmessage</code>事件中，当接收到服务器返回的心跳响应或其他消息时，可以<strong>重置心跳定时器</strong>，以避免不必要的心跳发送。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ws .onmessage = function()&#123;</span><br><span class="line">  clearInterval(heartcheck);// 清除原来的心跳定时器</span><br><span class="line">  heartcheck=setInterval(function()&#123; </span><br><span class="line">    ws.send(&#x27;HeartBeat&#x27;); // 重新创建心跳定时器并发送心跳数据包</span><br><span class="line">  &#125;, 5000);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>onclose</code>和<code>onerror</code>事件中，需要<strong>清除心跳定时器</strong>，以避免在连接关闭后继续发送心跳数据包。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = function()&#123;</span><br><span class="line">  clearInterval(heartcheck);//清除心跳定时器</span><br><span class="line">&#125;;</span><br><span class="line">ws.onerror = function()&#123;</span><br><span class="line">  clearInterval(heartcheck);// 清除心跳定时器</span><br><span class="line">  // 可以添加重连逻辑或其他错误处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">WebSocket</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="WebSocket" scheme="https://southernfish.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://southernfish.github.io/2025/06/21/docker-commands/"/>
    <id>https://southernfish.github.io/2025/06/21/docker-commands/</id>
    <published>2025-06-21T04:55:36.000Z</published>
    <updated>2025-06-21T08:05:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一个用于创建、部署和管理容器的开源平台。在使用Docker时，有效地管理和监控容器是非常重要的，其中查看和解析Docker命令(command)是基本且关键的一步。本文将介绍一些关于Docker的命令。</p><h1>基础命令</h1><h2 id="Docker命令的格式">Docker命令的格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker &lt;<span class="built_in">command</span>&gt;[options] [arguments]</span><br></pre></td></tr></table></figure><h2 id="Docker基础命令">Docker基础命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker version           <span class="comment">#显示版本信息</span></span><br><span class="line">docker info              <span class="comment">#显示docker系统信息，包括容器、镜像</span></span><br><span class="line">docker stats             <span class="comment">#cpu/内存使用情况</span></span><br><span class="line">docker  [<span class="built_in">command</span>] --<span class="built_in">help</span>       <span class="comment">#帮助命令</span></span><br></pre></td></tr></table></figure><h1>镜像相关命令</h1><h2 id="查看本地镜像-images">查看本地镜像 images</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">    -a, --all             <span class="comment"># 列出所有的镜像</span></span><br><span class="line">    -q, --quiet           <span class="comment"># 只显示的镜像的id</span></span><br><span class="line"><span class="comment"># 举例说明</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID           CREATED        SIZE</span><br><span class="line">centos              7         8652b9f0cb4c   2 months ago   204MB</span><br><span class="line"><span class="comment"># 解释</span></span><br><span class="line">    REPOSITORY  镜像仓库源</span><br><span class="line">    TAG         标签（版本）</span><br><span class="line">    IMAGE ID    镜像ID</span><br><span class="line">    CREATED     创建时间</span><br><span class="line">    SIZE        大小</span><br></pre></td></tr></table></figure><h2 id="搜索镜像-search">搜索镜像 search</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search [镜像名]</span><br><span class="line">    --filter=STARS=3000                            <span class="comment"># 列出收藏数不小于指定值的镜像</span></span><br><span class="line">docker search centos                            <span class="comment"># 搜索centos镜像</span></span><br><span class="line">docker search --filter=STARS=3000 centos        <span class="comment"># 搜索收藏大于3000的centos镜像</span></span><br></pre></td></tr></table></figure><h2 id="下载镜像-pull">下载镜像 pull</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull [镜像名]:[版本号]</span><br><span class="line">      -a, --all-tags                <span class="comment"># 下载所有镜像名的镜像</span></span><br><span class="line">docker pull nginx                    <span class="comment"># 下载nginx镜像，默认最新版</span></span><br><span class="line">docker pull nginx:1.14.0            <span class="comment"># 下载nginx镜像，版本为1.14.0</span></span><br><span class="line">docker pull -a nginx                <span class="comment"># 下载REPOSITORY为nginx的所有镜像</span></span><br></pre></td></tr></table></figure><h2 id="删除镜像-rmi">删除镜像 rmi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">删除镜像 rmi</span><br><span class="line">docker rmi [镜像名或者镜像<span class="built_in">id</span>]</span><br><span class="line">    -f                                       <span class="comment"># 强制删除</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>                        <span class="comment"># 删除指定的镜像</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>    镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span>  <span class="comment"># 删除多个镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)         <span class="comment"># 删除全部的镜像</span></span><br></pre></td></tr></table></figure><h2 id="推送镜像">推送镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [镜像名或者镜像<span class="built_in">id</span>]                  <span class="comment"># 将镜像推送至远程仓库</span></span><br></pre></td></tr></table></figure><h1>容器相关命令</h1><h2 id="启动容器-rmi">启动容器 rmi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">启动容器 run</span><br><span class="line">docker run [镜像名]</span><br><span class="line">-d                                            <span class="comment"># 后台运行容器，并返回容器ID</span></span><br><span class="line">-i                                            <span class="comment"># 以交互模式运行容器，通常与 -t 同时使用；</span></span><br><span class="line">-P                                            <span class="comment"># 随机端口映射，容器内部端口随机映射到主机的端口</span></span><br><span class="line">-p                                            <span class="comment"># 指定端口映射，格式为：主机(宿主)端口:容器端口</span></span><br><span class="line">    -p ip:主机端口:容器端口</span><br><span class="line">    -p 主机端口:容器端口</span><br><span class="line">    -p 容器端口</span><br><span class="line">-t                                            <span class="comment"># 为容器重新分配一个伪输入终端，通常与 -i 同时使用（-it    交互模式运行）</span></span><br><span class="line">--name=<span class="string">&quot;nginx-lb&quot;</span>                            <span class="comment"># 为容器指定一个名称</span></span><br><span class="line">--dns 8.8.8.8                                <span class="comment"># 指定容器使用的DNS服务器，默认和宿主一致</span></span><br><span class="line">--dns-search example.com                    <span class="comment"># 指定容器DNS搜索域名，默认和宿主一致</span></span><br><span class="line">-h <span class="string">&quot;hostname&quot;</span>                                <span class="comment"># 指定容器的hostname</span></span><br><span class="line">-e username=<span class="string">&quot;ritchie&quot;</span>                        <span class="comment"># 设置环境变量</span></span><br><span class="line">--env-file=[]                                <span class="comment"># 从指定文件读入环境变量；</span></span><br><span class="line">--cpuset=<span class="string">&quot;0-2&quot;</span> or --cpuset=<span class="string">&quot;0,1,2&quot;</span>            <span class="comment"># 绑定容器到指定CPU运行；</span></span><br><span class="line">-m                                             <span class="comment"># 设置容器使用内存最大值；</span></span><br><span class="line">--net=<span class="string">&quot;bridge&quot;</span>                                 <span class="comment"># 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span></span><br><span class="line">--<span class="built_in">link</span>=[]                                    <span class="comment"># 添加链接到另一个容器</span></span><br><span class="line">--expose=[]                                 <span class="comment"># 开放一个端口或一组端口；</span></span><br><span class="line">--volume , -v                                 <span class="comment"># 绑定一个卷</span></span><br><span class="line">docker run -it centos /bin/bash               <span class="comment"># 启动并进入容器</span></span><br><span class="line">docker run -it -v 主机目录：容器内目录           <span class="comment"># 挂载目录</span></span><br></pre></td></tr></table></figure><h2 id="查看容器信息-ps">查看容器信息 ps</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [CONTAINER ID or CONTAINER NAME]</span><br><span class="line">-a                        <span class="comment"># 列出当前正在运行的容器+历史运行过的容器</span></span><br><span class="line">-n=?                    <span class="comment"># 显示最近创建的容器</span></span><br><span class="line">-q                        <span class="comment"># 只显示容器的ID</span></span><br><span class="line">docker ps                <span class="comment"># 显示正在运行的容器</span></span><br><span class="line">docker ps -n=3          <span class="comment"># 显示最近三个创建的容器</span></span><br></pre></td></tr></table></figure><h2 id="退出容器-exit">退出容器 exit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">退出容器 <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span>            <span class="comment"># 直接容器停止并退出</span></span><br><span class="line">Ctrl + P + Q    <span class="comment"># 容器不停止退出</span></span><br></pre></td></tr></table></figure><h2 id="删除容器-rm">删除容器 rm</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span>                          <span class="comment"># 删除指定容器，不能删除正在运行的容器   </span></span><br><span class="line">docker <span class="built_in">rm</span> --f 容器<span class="built_in">id</span>                     <span class="comment"># 删除正在运行的容器    </span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)            <span class="comment"># 删除全部的容器</span></span><br><span class="line">docker ps -q -a|xargs docker <span class="built_in">rm</span>         <span class="comment"># 删除全部的容器</span></span><br></pre></td></tr></table></figure><h2 id="启动和停止容器的操作">启动和停止容器的操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动和停止容器的操作</span><br><span class="line">docker start 容器<span class="built_in">id</span>        <span class="comment"># 启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span>      <span class="comment"># 重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>         <span class="comment"># 停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span>         <span class="comment"># 强制停止当前的容器</span></span><br></pre></td></tr></table></figure><h2 id="查看容器日志-logs">查看容器日志 logs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --<span class="built_in">tail</span> 10 8e633673e3c2     <span class="comment"># 查看容器id为8e633673e3c2的容器，最新10条日志</span></span><br><span class="line">    -f                 <span class="comment"># 跟踪日志输出</span></span><br><span class="line">    --since         <span class="comment"># 显示某个开始时间的所有日志</span></span><br><span class="line">    -t                 <span class="comment"># 显示时间戳</span></span><br><span class="line">    --<span class="built_in">tail</span>             <span class="comment"># 仅列出最新N条容器日志</span></span><br><span class="line">docker logs -tf --<span class="built_in">tail</span> 10 8e633673e3c2</span><br></pre></td></tr></table></figure><h2 id="查看容器中的进程信息-top">查看容器中的进程信息 top</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [容器<span class="built_in">id</span>]        <span class="comment"># 显示容器的进程信息</span></span><br></pre></td></tr></table></figure><h2 id="查看镜像的元数据-inspect">查看镜像的元数据 inspect</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [容器<span class="built_in">id</span>]</span><br><span class="line">    -f             <span class="comment"># 指定返回值的模板文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器ip</span></span><br><span class="line">[root@layman ~]<span class="comment"># docker inspect -f  &#x27;&#123;&#123;.NetworkSettings.Networks.redis.IPAMConfig.IPv4Address&#125;&#125;&#x27; 0233</span></span><br><span class="line">172.31.38.16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器环境变量</span></span><br><span class="line">[root@layman ~]<span class="comment"># docker inspect -f &#x27;&#123;&#123;.Config.Env&#125;&#125;&#x27; 0233</span></span><br><span class="line">[PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin REDIS_VERSION=5.0.9 REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-5.0.9.tar.gz REDIS_DOWNLOAD_SHA=53d0ae164cd33</span><br><span class="line">536c3d4b720ae9a128ea6166ebf04ff1add3b85f1242090cb85]</span><br></pre></td></tr></table></figure><h2 id="进入容器-exec-attach">进入容器 exec attach</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash        <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line">docker attach 容器<span class="built_in">id</span>                    <span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure><h1>其他相关命令</h1><h2 id="docker-run-与-docker-start区别">docker run 与 docker start区别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run 只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令docker start 即可；</span><br><span class="line">docker run相当于执行两步操作：将镜像放入容器（docker create）,然后将容器启动，变成运行时容器（docker start）；</span><br><span class="line">docker start的作用是，重新启动已存在的镜像。</span><br></pre></td></tr></table></figure><h2 id="Docker-run的基本流程">Docker run的基本流程</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621155307829.png" alt="image-20250621155307829"></p><h2 id="挂载卷-v">挂载卷 -v</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span>                      <span class="comment"># 查看所有的volume的情况</span></span><br><span class="line">-v 容器内路径                           <span class="comment"># 匿名挂载</span></span><br><span class="line">-v 卷名：容器内路径                       <span class="comment"># 具名挂载</span></span><br><span class="line">-v /宿主机路径：容器内路径               <span class="comment"># 指定路径挂载</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx     <span class="comment"># 只读权限</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx     <span class="comment"># 可读可写</span></span><br><span class="line"><span class="comment"># 没有指定目录的情况下都是在“/var/lib/docker/volumes/xxxx/_data&quot;下</span></span><br><span class="line"></span><br><span class="line">构建 build</span><br><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t layman/dockerfile .</span><br><span class="line">-f     <span class="comment"># 指定要使用的Dockerfile路径</span></span><br><span class="line">-t     <span class="comment"># 镜像的名字及标签</span></span><br><span class="line"></span><br><span class="line">查看docker网络 network</span><br><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span>                            <span class="comment"># 查看所有容器的网络状态</span></span><br><span class="line">docker network inspect [NETWORK ID]        <span class="comment"># 查看一个详细信息</span></span><br><span class="line">docker network <span class="built_in">rm</span> [NETWORK ID]            <span class="comment"># 可以移除一个网络</span></span><br><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">--driver bridge                自定义网络模式，使用桥接</span><br><span class="line">--subnet 192.168.0.0/16        设置子网地址</span><br><span class="line">--gateway 192.168.0.1        设置出口网关</span><br><span class="line">mynet                        自己定义的一个网络名字</span><br><span class="line"><span class="comment"># 查看网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line">加入网络 connect</span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建-build">构建 build</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t layman/dockerfile .</span><br><span class="line">-f     <span class="comment"># 指定要使用的Dockerfile路径</span></span><br><span class="line">-t     <span class="comment"># 镜像的名字及标签</span></span><br></pre></td></tr></table></figure><h2 id="查看docker网络-network">查看docker网络 network</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span>                            <span class="comment"># 查看所有容器的网络状态</span></span><br><span class="line">docker network inspect [NETWORK ID]        <span class="comment"># 查看一个详细信息</span></span><br><span class="line">docker network <span class="built_in">rm</span> [NETWORK ID]            <span class="comment"># 可以移除一个网络</span></span><br><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">--driver bridge                自定义网络模式，使用桥接</span><br><span class="line">--subnet 192.168.0.0/16        设置子网地址</span><br><span class="line">--gateway 192.168.0.1        设置出口网关</span><br><span class="line">mynet                        自己定义的一个网络名字</span><br><span class="line"><span class="comment"># 查看网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入网络 connect</span></span><br><span class="line">docker network connect mynet tomcat01</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker</summary>
    
    
    
    <category term="Containerization Platform" scheme="https://southernfish.github.io/categories/Containerization-Platform/"/>
    
    
    <category term="Docker" scheme="https://southernfish.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://southernfish.github.io/2025/06/21/front-end-javascript/"/>
    <id>https://southernfish.github.io/2025/06/21/front-end-javascript/</id>
    <published>2025-06-21T04:55:36.000Z</published>
    <updated>2025-06-21T08:05:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是一种轻量级、解释型或者说即时编译型的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131?fromModule=lemma_inlink">编程语言</a>， [20]广泛应用于网页开发中，主要用于增强网页的<a href="https://baike.baidu.com/item/%E4%BA%A4%E4%BA%92%E6%80%A7/10758528?fromModule=lemma_inlink">交互性</a>和<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E6%80%A7/53339475?fromModule=lemma_inlink">动态性</a>。作为Web开发的核心技术之一，它与<a href="https://baike.baidu.com/item/HTML/97049?fromModule=lemma_inlink">HTML</a>和<a href="https://baike.baidu.com/item/CSS/5457?fromModule=lemma_inlink">CSS</a>共同协作，HTML负责定义网页的内容结构，CSS处理样式和布局，而JavaScript则控制网页的行为和交互。</p><h2 id="js的事件循环机制">js的事件循环机制</h2><p><strong>js是单线程的，会出现阻塞问题。</strong><br>比如说网络请求和 <code>settimeout</code> ，它<strong>通过异步来做</strong>的，若都用异步则会放在队列里面，<strong>异步队列没有优先级</strong>，所以为了更灵活增加了事件循环<br><strong>事件循环：</strong><br>js是单线程，有同步任务和异步任务，一般是异步任务又分为微任务和宏任务<br><strong>先执行同步任务队列，再执行微任务队列，之后再执行宏任务</strong>，每执行一次宏任务时会<strong>时时检测微任务队列有没有任务</strong>，若有则会先清空微任务队列，执行完了，再去执行下一个宏任务。</p><p><strong>运行机制：</strong><br>单线程，从上到下按顺序执行代码。<strong>运行的两个阶段</strong>：</p><ol><li>**预解析：**把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前</li><li>**执行：**从上到下执行（按照js运行机制）</li></ol><h2 id="javascript的数据类型">javascript的数据类型</h2><p><code>Boolean</code>、<code>null</code>、<code>String</code>、<code>Number</code>、<code>Object</code>、<code>Undefined</code><br><strong>常见基本数据类型：</strong><code>Number</code>、<code>String</code> 、<code>Boolean</code>、<code>Null</code> 和 <code>Undefined</code>。<br>基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值<br><strong>引用类型：</strong><code>Objec</code>t 、<code>Array</code> 、<code>Function</code> 、<code>Data</code>等。</p><h2 id="怎样判断变量的类型">怎样判断变量的类型</h2><p><code>typeof</code> 能够区分<strong>除数组、对象和null外的所有类型</strong>，[] {} null 都返回object<br><code>instanceof</code> 及原理：<code>object.toString().call()</code></p><h2 id="Cookie（4kb）、-storage-（5MB）-localStorage（5-10MB）">Cookie（4kb）、 storage （5MB） localStorage（5-10MB）</h2><p>首先，<code>webstorage</code>中包含<code>sessionStorage</code>和<code>localStorage</code>。 <strong>cookie和webstorage的区别:</strong></p><ol><li><strong>出现的时间：</strong><code>cookie</code> 很早之前就有了，<code>webstorage</code> H5之后才有的</li><li><strong>跟随请求状态</strong>：cookie 会跟着前后台请求，webstorage 不跟随</li><li>**储存大小：**cookie 4K，storage 5M左右</li><li>**生命周期：**cookie 生命周期可以设置，webstorage 生命周期不可设置</li><li>**存在的位置：**cookie / sessionStorage / localStorage 在客户端，<strong>seesion 在服务端</strong>，较其他的安全</li></ol><h2 id="操作数组和对象的常见方法">操作数组和对象的常见方法</h2><p><strong><code>array</code>：</strong> <code>slice / splice / concat / filter / map / reduce</code><br><strong><code>obj</code> ：</strong> <code>keys / assign</code></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const fruits = [&#x27;Banana&#x27;, &#x27;Orange&#x27;, &#x27;Lemon&#x27;, &#x27;Apple&#x27;, &#x27;Mango&#x27;];</span><br><span class="line">const citrus = fruits.slice(1, 3);   // [&#x27;Orange&#x27;,&#x27;Lemon&#x27;]</span><br><span class="line">const removed = fruits.splice(2, 2, &#x27;Kiwi&#x27;, &#x27;Pineapple&#x27;); //替换了原数组[&#x27;Kiwi&#x27;, &#x27;Pineapple&#x27;, &#x27;Lemon&#x27;, &#x27;Apple&#x27;, &#x27;Mango&#x27;]</span><br><span class="line">//fruits.splice(2, 2)   // [&#x27;Lemon&#x27;, &#x27;Apple&#x27;]</span><br></pre></td></tr></table></figure><h2 id="new内部做了什么">new内部做了什么</h2><ol><li>创建了一个新对象 <code>var obj = &#123;&#125;</code>；</li><li><code>this</code>关键字指向obj；</li><li><code>prototype</code>原型指向<code>obj</code>原型；</li><li>执行构造函数</li></ol><h2 id="防抖、节流-函数节流的应用场景">防抖、节流 , 函数节流的应用场景</h2><p>js 中一些事件如浏览器的 <code>resize</code>、<code>scroll</code>，鼠标的 <code>mousemove</code>、<code>mouseover</code>，input 输入框的 <code>keypress</code> 等<strong>事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</strong>。为优化体验，需要对这类事件进行调用次数的限制。<br>**函数防抖：**在一段连续操作结束后，处理回调，利用 <code>clearTimeout</code> 和 <code>setTimeout</code>实现<br>**函数节流：**每隔一段时间，只执行一次函数。<br><strong>场景：</strong></p><ol><li>滚动加载，加载更多或滚到底部监听；</li><li>谷歌搜索框，搜索联想功能；</li><li>高频点击提交，表单重复提交</li></ol><h2 id="this指向">this指向</h2><ol><li><strong>普通函数调用</strong>，此时 this 指向 <code>window</code></li><li><strong>构造函数调用</strong>，此时 this 指向 <code>实例对象</code></li><li><strong>对象方法调用</strong>，此时 this 指向 <code>该方法所属的对象</code></li><li><strong>通过事件绑定的方法</strong>，此时 this 指向 <code>绑定事件的对象</code></li><li><strong>定时器函数</strong>，此时 this 指向 <code>window</code></li></ol><h2 id="let-const-var-的区别">let const var 的区别</h2><p><code>var</code>：作用域是<strong>全域的</strong>； var<strong>允许重复声明变量</strong><br><code>let</code>：作用域是<strong>块级</strong>；let<strong>不允许重复声明变量</strong><br><code>const</code>：声明的是<strong>常量</strong>，不可改变，<strong>必须初始化</strong>，作用于<strong>块级作用域</strong>，没有变量提升，不允许重复声明</p><h2 id="实现继承的几种方式">实现继承的几种方式</h2><p><strong>原型链</strong>继承、<strong>构造</strong>继承、<strong>实例</strong>继承、<strong>拷贝</strong>继承、<strong>组合</strong>继承</p><h2 id="promiss的理解">promiss的理解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><code>Promise</code> 是 JavaScript 中异步编程的一种解决方案，用于处理异步操作的结果<br>**特点：**Promise 对象的状态不受外界影响，只有异步操作的结果才能决定其状态<br><strong>优点：</strong></p><ul><li><strong>解决了回调地狱问题</strong>，使得代码结构更加清晰和可维护；</li><li>提供了<strong>统一的API</strong>，使得异步操作的控制更加容易</li><li>ES8 引入了 <code>async / await</code>，是基于 Promise 实现的，使得异步编程更加简洁和直观</li></ul><p>**回调地狱问题：**每个接口都依赖于前一个接口的返回,</p><h2 id="promiss为什么支持链式调用">promiss为什么支持链式调用</h2><p>在 then 方法中返回另一个 Promise，因此可将多个 then 方法串联起来，形成一个链式调用。每个 then 方法的返回值都会作为下一个 then 方法的输入，从而实现异步操作的顺序执行。如下示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getPromise(value) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; resolve(value), 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPromise(1).then((result) =&gt; &#123;</span><br><span class="line">    console.log(result); // 输出: 1</span><br><span class="line">    return getPromise(result * 2);</span><br><span class="line">&#125;).then((result) =&gt; &#123;</span><br><span class="line">    console.log(result); // 输出: 2</span><br><span class="line">    return getPromise(result * 3);</span><br><span class="line">&#125;).then((result) =&gt; &#123; </span><br><span class="line">    console.log(result); // 输出: 6</span><br><span class="line">&#125;).catch((error) =&gt; &#123;  </span><br><span class="line">     console.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="在-try，catch中-报错了在catch中会被检测到么">在 try，catch中 报错了在catch中会被检测到么</h2><p>如果在 <code>catch</code> 块中再次抛出错误，这个新的错误<strong>可以被外层的 <code>try…catch</code> 语句捕获</strong>，或者如果没有外层的 try…catch 语句，它会<strong>继续向上抛出，直到被捕获或导致程序终止</strong>。</p><h2 id="浏览器垃圾回收">浏览器垃圾回收</h2><p>当 <code>JavaScript</code> 代码运行时，需要分配内存空间来存储变量和值。<br>当<strong>变量不再参与运行时，就需要系统收回被占用的内存空间</strong>，这就是垃圾回收<br><strong>常见内存泄露的原因</strong></p><ul><li><strong>全局变量</strong>引起的内存泄露</li><li><strong>闭包</strong>引起的内存泄露：慎用闭包</li><li><strong>dom清空或删除时，事件未清除导致</strong>的内存泄漏</li><li><strong>循环引用</strong>带来的内存泄露</li></ul><p><strong>优化写法</strong></p><ul><li>在<strong>对象结束使用后 ，令obj = null</strong>；</li><li>js中开辟空间的操作有 new()，[ ]，{ }，function (){…}，最大限度的实现<strong>对象的重用</strong>；</li><li><strong>慎用闭包</strong>，闭包容易引起内存泄露</li></ul><h2 id="js重复的问题-作用域链、原型、原型链、闭包？-面向对象-继承">js重复的问题 作用域链、原型、原型链、闭包？ 面向对象 继承</h2><p><strong>面向对象：<strong>是一种编程思想，将现实世界的事物抽象为对象，并使用类和对象来创建各种功能<br><strong>作用域链</strong><br>内部环境可以通过作用域链来访问外部环境的属性和方法，但</strong>外部环境不能访问内部环境的任何属性和方法</strong>。注意，<strong>只能通过定义函数来延长作用域链条</strong>。<br><strong>闭包</strong><br><strong>概念：<strong>闭包就是</strong>能够读取其他函数内部变量的函数</strong>，<code>Javascript</code> 语言中，只有函数内部的子函数才能读取局部变量，因此简单理解闭包为<strong>定义在一个函数内部的函数</strong>。<em>本质上</em>，闭包就是<strong>将函数内部和函数外部连接起来</strong>的一座桥梁。<br>例子(如下代码所示)：函数 b 就是一个闭包函数，用于获取函数 a 内部的变量 i。当函数 a 的内部函数 b，被函数 a 外的一个变量 c 引用的时候，就创建了一个闭包。<br><strong>作用：<strong>可以</strong>读取函数内部的变量；让这些变量的值始终保持在内存中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    var i = 0;</span><br><span class="line">    function b()&#123;</span><br><span class="line">        alert(++i);</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">var c = a();</span><br><span class="line">c()</span><br></pre></td></tr></table></figure><p><strong>原型链</strong><br><strong>原型：<strong>所有函数都有一个特殊属性 <code>prototype</code>(原型)，<strong>prototype 属性是一个指针，指向的是一个对象(原型对象)，原型对象中的方法和属性都可以被函数的实例所共享</strong>。所谓<code>函数实例</code>是指</strong>以函数作为构造函数创建的对象</strong>，这些对象实例都可以共享构造函数的原型的方法。<br><strong>原型链：<strong>原型链是</strong>用于查找引用类型（对象）的属性</strong>，查找属性会沿着原型链依次进行，找到后停止搜索并做相应的操作，否则会<strong>沿着原型链依次查找直到结尾</strong>。常见的应用是用在<strong>创建对象和继承</strong>中。</p>]]></content>
    
    
    <summary type="html">JavaScript</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="JavaScript" scheme="https://southernfish.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>WebPack</title>
    <link href="https://southernfish.github.io/2025/06/21/front-end-webpack/"/>
    <id>https://southernfish.github.io/2025/06/21/front-end-webpack/</id>
    <published>2025-06-21T04:55:36.000Z</published>
    <updated>2025-06-21T08:05:35.151Z</updated>
    
    <content type="html"><![CDATA[<p>webpack 是代码编译工具，有入口、出口、loader 和<a href="https://baike.baidu.com/item/%E6%8F%92%E4%BB%B6/369160?fromModule=lemma_inlink">插件</a>。webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 <em>bundle</em>。</p><h2 id="什么是-webpack">什么是 webpack ?</h2><p><code>webpack</code> 是一个现代 JavaScript 应用程序的<strong>静态模块打包器</strong><br><code>webpack</code> 可以<strong>递归的打包项目中所有模块</strong>（递归：指定一个入口，分析模块的依赖，它会递归的查找所有相关的依赖）</p><h2 id="核心概念">核心概念</h2><p><code>Entry</code>：配置入口文件。webpack 会找出有哪些模块是入库的依赖 ， 相关的依赖会被处理，输出到 bundles 的文件中<br><code>Output</code>：output 属性会告诉 webpack 它<strong>所创建的bundles 如何命名，默认值为 ./dist</strong><br><code>module</code>：模块。Webpack 里一切皆模块，一个模块对应一个文件。Webpack 从配置的 Entry 开始递归找出所有依赖的模块。<br><code>Chunk</code>：代码块。一个 chunk 由多个模块组合而成，用于代码的合并和分割。<br><code>loader</code>：模块转换器。用于将模块的原内容按照需要转成你想要的内容<br><strong>babel 和 webpack的区别：</strong></p><ul><li><code>babel</code>：JS新语法编译工具，只关心语法，不关心模块化</li><li><code>webpack</code>：打包构建工具，是多个 Loader plugin 的集合</li></ul><h2 id="webpack与grunt、gulp的不同？">webpack与grunt、gulp的不同？</h2><p>Webpack 与 Gulp、Grunt 没有什么可比性。<br>Webpack 可以看作<strong>模块打包机</strong>，通过分析项目结构找到js模块及一些浏览器不能直接运行的语言（<code>scss typescript</code>）<br><strong><code>Grunt</code> 和 <code>Gulp</code> 的工作方式</strong>：在一个<strong>配置文件</strong>中，指明对某些文件进行类似编译，组合，压缩等<strong>任务的具体步骤，工具之后可以自动替你完成这些任务</strong>。<br><strong><code>Webpack</code> 的工作方式</strong>：把项目当做一个整体，通过一个<strong>给定主文件</strong>（如：index.js），Webpack 将这个文件<strong>开始找到你的项目的所有依赖文件，使用 <code>loaders</code> 处理它们，最后打包为一个（或多个）浏览器可识别的 <code>JavaScript</code> 文件</strong>。</p><h2 id="webpack有哪些优缺点">webpack有哪些优缺点</h2><p><strong>优点：</strong></p><ul><li>可通过 <code>plugin</code> 扩展</li><li>使用场景不局限于 <code>web</code> 开发</li><li>良好的开发体验</li></ul><p>**缺点：**只能用于采用模块化开发的项目</p><h2 id="webpack打包原理？">webpack打包原理？</h2><p><strong>把所有依赖打包成一个 bundle.js 文件，通过代码分割成单元片段并按需加载</strong>。<br>Webpack 是一个模块打包器，grunt 和 gulp 是执行任务的，<br>webpack 递归的打包项目中所有模块，最终生成几个打包后的文件，与其他工具最大的不同在于它<strong>支持 code-splitting（代码分割），模块化（AMD，ESM，CommonJS）开发，全局的分析工具（分析整个项目引入的模块）</strong></p><h2 id="什么是模块热跟新-？-有什么优点？">什么是模块热跟新 ？ 有什么优点？</h2><p><strong>模块热更新：<strong>是webpack的一个功能，可以使</strong>代码修改后不用刷新浏览器就可更新内容</strong>。 是高级版的自动刷新浏览器（将代码重新执行一遍而不是整体刷新浏览器）<br>**优点：**只更新变更内容，以节省开发时间。<strong>调整样式更加快速</strong>，几乎相当于在浏览器中更改样式</p><h2 id="如何利用webpack来优化前端性能？">如何利用webpack来优化前端性能？</h2><p><strong>代码压缩、按需加载、使用 <code>Dll</code> 进行分包</strong><br>正常情况下 <code>node_module</code> 会被打包成一个文件，使用 <code>dll</code> 技术，可<strong>将不常更新的框架和库进行单独打包，生成一个chunk</strong></p><h2 id="webpack-为什么启动速度慢">webpack 为什么启动速度慢</h2><p>它是将所有模块构建完了，再去启动项目的</p><h2 id="如何提高webpack的构建速度？">如何提高webpack的构建速度？</h2><ul><li>减少需要构建的文件或代码</li><li>多进程打包 <code>thread-loader</code>，将其放在费时的 <code>loader</code> 之前</li></ul>]]></content>
    
    
    <summary type="html">WebPack</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="WebPack" scheme="https://southernfish.github.io/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://southernfish.github.io/2025/06/21/docker/"/>
    <id>https://southernfish.github.io/2025/06/21/docker/</id>
    <published>2025-06-21T04:55:36.000Z</published>
    <updated>2025-06-21T08:05:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一组平台即服务（PaaS）的产品。它基于操作系统层级的虚拟化技术，将软件与其依赖项打包为容器。托管容器的软件称为Docker引擎。Docker能够帮助开发者在轻量级容器中自动部署应用程序，并使得不同容器中的应用程序彼此隔离，高效工作。</p><h1>Docker</h1><h2 id="参考文档链接">参考文档链接</h2><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p><p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="什么是Docker">什么是Docker</h2><p><code>Docker</code> 是基于Go语言开发的开源项目，是开源的容器化平台，旨在简化应用程序的开发、部署和运行过程。它提供了一种轻量级、可移植和自包含的容器化环境，使开发人员能够在不同的计算机上以一致的方式构建、打包和分发应用程序。<br><strong>核心概念：</strong></p><ul><li><strong>容器（<code>Container</code>）：<strong>容器是 Docker 的</strong>基本部署单元</strong>。它是一个轻量级的、独立的运行时环境，包含应用程序及其相关依赖。容器利用 Linux 内核的命名空间和控制组技术，实现了隔离性和资源管理，使得应用程序在不同的容器中运行不会相互影响。</li><li><strong>镜像（<code>Image</code>）：<strong>镜像是用于</strong>创建容器的模板</strong>。它包含了一个完整的文件系统，其中包括应用程序运行所需的所有文件、依赖和配置信息。镜像是不可变的，通过 Docker 镜像可以创建多个相同的容器实例。</li><li><strong>镜像仓库（<code>Image Registry</code>）：<strong>镜像仓库是用于</strong>存储和分发 Docker 镜像的地方</strong>。最常用的公共镜像仓库是 <code>Docker Hub</code>，上面有大量的官方和社区共享的镜像。也可以搭建私有的镜像仓库，用于存放自己的镜像。</li><li><strong><code>Dockerfile</code>：<strong>Dockerfile 是一种</strong>文本文件</strong>，用于<strong>定义 Docker 镜像的构建过程</strong>。它包含了一系列的指令，用于<strong>指定基础镜像、安装软件、拷贝文件、配置环境等</strong>。通过 Dockerfile，可以自动化地构建镜像，确保镜像的一致性和可重复性。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621152126465.png" alt="image-20250621152126465"></p><p><strong>Docker 的优势</strong>：<code>轻量性、可移植性和灵活性</code>。通过使用 Docker，开发人员可以更轻松地创建一个可靠的开发环境、快速部署应用程序、实现弹性扩展和服务编排等。同时，它也提供了<code>生态系统丰富的工具和服务</code>，例如容器编排工具 <code>Docker Compose</code> 和容器编排平台 <code>Kubernetes</code>，使得容器化应用的管理更加便捷和高效。</p><p><strong>Linux容器技术：</strong></p><ul><li>Docker是在Linuk容器(<code>Linux Containers</code>)技术的基础上发展起来的。</li><li>LUX把单个操作系统的资源划分到多个孤立的组里，在孤立的组里平衡有冲突的资源使用需求。与虚拟机相比，这种通过划分组来平衡资源冲突的方式代价更小，它不需要指令级别模拟也不需要即使编译。</li><li><strong>容器直接在本地CPU上运行</strong>。</li></ul><h3 id="为什么要使用Docker">为什么要使用Docker</h3><ul><li>**更快的交付和部署。**开发人员使用镜像构建标准开发环境，运维和测试人员使用镜像来获得和开发人员相同的运行环境。开发环境和测试运维环境无缝对接，节约开发、测试、部署时间。</li><li><strong>更高效的资源利用。<strong>相较于虚拟机Docker不需要额外的<code>Hypervisor</code>支持，Docker是</strong>内核级别的虚拟化</strong>，实现更高的性能。</li><li>**更简单的更新管理。**使用<code>Dockerfile</code>，通过简单的修改就可以代替大量的更新操作。</li></ul><h2 id="Docker与虚拟化">Docker与虚拟化</h2><p>**虚拟化：**虚拟化是对计算机资源的抽象，是为了更好的管理计算机资源。让同时运行在一个计算机上的多个进程以为自己能够独占当前操作系统资源。<br>**有三种类型的虚拟化：**仿真、半虚拟化、基于容器的虚拟化<br><strong>Docker虚拟化与虚拟机比较</strong></p><ul><li><strong>Docker不是虚拟化方法</strong>。它依赖于实际实现基于容器的虚拟化或操作系统级虚拟化的其他工具。</li><li><strong>Docker是操作系统级的虚拟化</strong>，内核通过创建多个虚拟操作系统实例来隔离进程。虚拟机是硬件辅助虚拟化，虚拟的是整个硬件。</li><li>虚拟机需要模拟一个独立的<code>OS Kernel</code>而Docker不需要，与虚拟机映像相比，容器状态(<code>Docker或LXC映像</code>)的<strong>大小很小</strong>，因此容器映像很容易分发</li><li>虚拟机需要一个虚拟机管理程序如<code>VMware</code>，而Docker只需要一个Docker引擎，<strong>后者的开销更小</strong>。</li><li><strong>Docker更快秒级，虚拟机分钟级别</strong></li><li>Docker<strong>对系统资源需求更少</strong>。<ul><li>主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求。容器中的资源管理是通过cgroup实现的。Cgroups不允许容器消耗比分配给它们更多的资源。</li></ul></li><li>Docker通过类似<code>Git</code>理念来方便用户获取、分发更新镜像</li><li>Docker通过<code>dockerfile</code>实现灵活的创建、部署机制</li></ul><p><strong>虚拟机和Docker本质的区别</strong>在于虚拟化的方式不同，虚拟机是一种硬件级别的虚拟化，通过软件去模拟硬件系统，并且虚拟机里需要虚拟OS Kernel。Docker是一种容器，是一种隔离机制，是软件级别的模拟。</p><p>虚拟机技术：资源占用十分多、冗余步骤多、启动慢；容器技术：不是模拟一个完整的OS</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151302533.png" alt="image-20250621151302533"></p><h2 id="Docker为什么比VM快">Docker为什么比VM快</h2><p>1、Docker比VM有更少的抽象层<br>2、Docker利用的是宿主机的内核，VM需要的是Guest OS<br>故新建一个容器的时候，docker无需像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而docker利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151312130.png" alt="image-20250621151312130"></p><table><thead><tr><th></th><th>Docker容器</th><th>LXC</th><th>VM</th></tr></thead><tbody><tr><td>虚拟化类型</td><td>OS虚拟化</td><td>OS虚拟化</td><td>硬件虚拟化</td></tr><tr><td>性能</td><td>=物理机性能</td><td>=物理机性能</td><td>5%-20%损耗</td></tr><tr><td>隔离性</td><td>NS隔离</td><td>NS隔离</td><td>强</td></tr><tr><td>QoS</td><td>Cgroup 弱</td><td>Cgroup 弱</td><td>强</td></tr><tr><td>安全性</td><td>中</td><td>差</td><td>强</td></tr><tr><td>GuestOS</td><td>只支持Linux&lt;</td><td>只支持Linux&lt;</td><td>全部</td></tr><tr><td>可迁移性</td><td>强</td><td>弱</td><td>强</td></tr></tbody></table><h2 id="docker是怎么工作的">docker是怎么工作的?</h2><p>一个完整的Docker由<code>DockerClient</code>客户端、<code>Docker Daemon</code>守护进程、<code>Docker Image</code>镜像、<code>DockerContainer</code>容器四部分组成<br>Docker是一个<code>Client-Server</code>结构的系统，，<strong>docker client负责处理用户输入的各种命令</strong>，比如docker build、docker run，真正工作的其实是server，也就是docker daemon，值得注意的是，<strong>docker client和docker daemon可以运行在同一台机器上</strong>。<br>Docker守护进程运行在主机上，然后通过<code>Socket</code>连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151356904.png" alt="image-20250621151356904"></p><h2 id="基本的Docker使用工作流程是怎样的？">基本的Docker使用工作流程是怎样的？</h2><ol><li>**构建镜像：**Dockerfile是镜像的源代码；用其创建镜像</li><li>**推送镜像到注册表：**将镜像上传到 <code>Docker Hub</code> 或<code>私有注册表</code>中。</li><li>**拉取镜像：**通过 <code>docker pull</code> 从注册表中拉取镜像。</li><li>**运行容器：**使用镜像创建并启动容器。</li><li>**管理容器：**使用 Docker 客户端命令管理正在运行的容器(例如查看日志、停止容器、查看资源使用情况等)。</li><li>**网络与存储：**容器之间通过 Docker 网络连接，数据通过 <code>Docker 卷</code>或<code>绑定挂载</code>进行持久化。</li></ol><h2 id="什么是docker-compose？">什么是docker-compose？</h2><p><code>docker-compose</code>就是一个编排同时管理多个容器的工具，与它配对使用的是一个<code>docker-compose.yaml</code>文件，<code>docker-compose</code>命令必须在一个包含<code>docker-compose.yaml</code>文件目录下才能使用。且当下docker-compose命令<strong>只能管理当前目录docker-compose文件中所涉及的容器，安装在机器上的其他容器无法干扰</strong>。</p><p>docker-compose的大部分命令基本和docker的命令重合，他们唯一的区别是docker命令能管理机器上所有的容器和镜像文件，而docker-compose只能管理当前docker-compose文件所涉及的容器。</p><h2 id="如何在生产中监控Docker？">如何在生产中监控Docker？</h2><p>Docker提供<code>docker status</code>和<code>docker事件</code>等工具来监控生产中的Docker。我们可以使用这些命令获取重要统计数据的报告。<br>**Docker统计数据：**当我们使用容器ID调用docker status时，我们获得容器的CPU、内存使用情况等。它类似于Linux中<code>top</code>命令。<br><strong>Docker事件：</strong> Docker事件是一个命令，用于查看Docker守护进程中整改再进行的活动流。一些常见的Docker事件是：<code>attach</code>、<code>commit</code>、<code>die</code>、<code>datach</code>、<code>rename</code>、<code>destroy</code>。</p><h2 id="Docker安全么？">Docker安全么？</h2><p>Docker<strong>利用了Linux内核中很多安全特性来保证不同容器之间的隔离，并且通过签名机制来对镜像进行验证</strong>。<br>Docker虽然隔离性无法与虚拟机相比，但仍然具有极高的安全性。</p><h2 id="Docker如何在非Linux系统中运行容器">Docker如何在非Linux系统中运行容器</h2><p>通过添加到Linux内核版本2.6.24的<strong>名称空间功能</strong>，可以实现容器的概念。容器将其<code>ID</code><strong>添加到每个进程</strong>，并向每个系统调用添加新的访问控制检查。它由<code>clone</code>系统调用访问，该调用允许创建先前全局命名空间的单独实例。</p><h1>Docker镜像</h1><h2 id="什么是Docker镜像">什么是Docker镜像</h2><p>Docker镜像是Docker容器的源代码。换句话说，Docker镜像用于创建容器。使用<code>build</code>创建镜像，用<code>run</code>启动时它们将生成容器。<br>镜像存储在Docker注册表（<code>docker hub</code>）中，<code>registry.hub.docker.com</code>因为它们可能变得非常大，镜像被设计为由其他镜像层组成，允许在通过网络传输镜像时发送最少量的数据。</p><h2 id="Docker镜像联合文件系统">Docker镜像联合文件系统</h2><p><strong><code>UnionFS</code>（联合文件系统）：<strong>是一种分成，轻量级并且高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统的Docker镜像可以</strong>通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像</strong>。<br><strong>特性：</strong><code>一次同时加载多个文件系统</code>，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统进行叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h2 id="镜像与-UnionFS区别">镜像与 UnionFS区别</h2><p>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。<br><code>Docker 镜像</code>其实<strong>本质就是一个压缩包</strong>，我们可以使用命令将一个 Docker 镜像中的文件导出，你可以看到这个镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说 Docker 镜像就是一个文件。</p><h2 id="什么是Docker-Hub">什么是Docker Hub</h2><p><code>Docker Hub</code>是一个基于云的在线存储库，Docker进行可以由其他用户发布和使用。<br><code>Docker hub</code>是一个基于云的注册表服务，允许链接到代码存储库，构建镜像并测试，存储手动推送的镜像以及指向Docker云的链接，以便将镜像部署到主机。它为整个开发流程中的容器镜像发现，分发和变更管理，用户和团队协作以及工作流自动化提供了集中资源。</p><h1>Docker容器</h1><h2 id="Docker容器可扩展到多远？">Docker容器可扩展到多远？</h2><p>诸如<code>Foogle</code>和<code>Twitter</code>之类的大型Web部署以及诸如<code>Heroku</code>和<code>dotCloud</code>之类的平台提供商都基于容器技术运行，并行运行的容器数以十万甚至至数八百计。</p><h2 id="Docker容器退出时是否丢失数据">Docker容器退出时是否丢失数据</h2><p>不、当Docker<strong>容器退出时，不会丢失数据</strong>。<br>应用程序写入磁盘的所有数据都会保留在其容器中<strong>直到明确删除该容器为止</strong>。即使在容器停止后，该容器的文件系统仍然存在。</p><h2 id="Docker容器有几种状态？">Docker容器有几种状态？</h2><p>有四种状态：运行、已暂停、重新启动、已退出。</p><h2 id="容器内部机制">容器内部机制</h2><p>每个容器都在自己的命名空间中运行，但使用与所有其他容器完全相同的内核。发生隔离是因为内核知道分配给进程的命名空间，并且在API调用期间确保进程只能访问其自己的命名空间中的资源。</p><h2 id="docker容器之间怎么隔离">docker容器之间怎么隔离?</h2><p>Linux中的<code>PID、IPC、网络</code>等资源是全局的，而<code>NameSpace机制</code>是一种资源隔离方案，在<strong>该机制下这些资源就不再是全局的</strong>了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰。<br>NameSpace技术可实现资源隔离，但进程仍可不受控的访问（CPU、内存、磁盘、网络等）系统资源，为了控制容器中进程对资源的访问，Docker采用<code>control groups</code>技术(也就是<code>cgroup</code>)<strong>控制容器中进程对系统资源的消耗</strong>，如限制某容器使用内存的上限、可在哪些CPU上运行等。这两项技术使容器像真正独立的操作系统。</p><h2 id="容器与主机之间的数据拷贝命令-docker-cp">容器与主机之间的数据拷贝命令 docker cp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主机到容器：docker cp /www 96f7f14e99ab:/www/</span><br><span class="line">容器到主机：docker cp 96f7f14e99ab:/www /tmp</span><br></pre></td></tr></table></figure><h2 id="进入容器的方法">进入容器的方法</h2><ol><li><code>docker attach</code>，用于附加到正在运行的容器的标准输入、输出和错误流。<strong>不会启动新的进程</strong>。</li><li><code>docker exec</code>，如<code>docker exec -it 容器id /bin/bash</code>，此命令将以<strong>交互模式（-i）和终端（-t）的方式进入指定容器，并开启起一个新的终端</strong>。</li><li>通过 <code>docker run</code> 命令来进入容器。这种方式<strong>适用于需要在容器内执行命令而不是交互式操作的情况</strong>，使用 docker run 命令指定容器镜像和执行的命令，类似于直接进入容器</li></ol><h2 id="无状态或有状态应用程序谁更适合Docker容器">无状态或有状态应用程序谁更适合Docker容器</h2><p>最好为<code>Docker Container</code>创建<strong>无状态应用程序</strong>。我们可以从应用程序中创建一个容器，并<strong>从应用程序中取出可配置的状态参数</strong>。现在我们可以<strong>在生产环境和具有不同参数的QA环境中运行相同的容器</strong>。这有助于在不同场景中重用相同的镜像。另外，无状态应用程序比有状态应用程序<strong>更容易使用Docker容器进行扩展</strong>。</p><h1>Dockerfile</h1><h2 id="Dockerfile中最常见的指令是什么">Dockerfile中最常见的指令是什么</h2><ul><li><code>FROM</code>：指定基础镜像；</li><li><code>LABEL</code>：功能是为镜像指定标签；</li><li><code>RUN</code>：运行指定的命令；</li><li><code>CMD</code>：容器启动时要运行的命令。</li></ul><h2 id="Dockerfile中的命令COPY和ADD命令区别">Dockerfile中的命令COPY和ADD命令区别</h2><p>一般而言，<code>ADD</code>和<code>COPY</code>在功能上类似，但是首选COPY。因为COPY比ADD更易懂。<strong>COPY仅支持将本地文件复制到容器中</strong>，而ADD具有一些功能（如仅限本地的tar提取和远程URL支持），这些功能并不是很明显。<br>因此，<strong>ADD最佳用途是将本地tar文件自动提取到镜像中</strong>，如<code>ADD rootfs.tar.xz /</code>。</p><h2 id="使用dockerfile构建apache容器服务">使用dockerfile构建apache容器服务</h2><ol><li><p>基础镜像目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir apache</span><br><span class="line"># cd apache</span><br></pre></td></tr></table></figure></li><li><p>编辑镜像dockerfile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># vim Dockerfile</span><br><span class="line"> </span><br><span class="line">FROM centos:7 # 基于的基础镜像</span><br><span class="line">MAINTAINER The porject &lt;cloud-ops@centos.org&gt; # 维护镜像的用户信息</span><br><span class="line"></span><br><span class="line"># 镜像操作指令安装apache软件</span><br><span class="line">RUN yum -y update    #更新yum</span><br><span class="line">RUN yum -y install httpd</span><br><span class="line"></span><br><span class="line">EXPOSE 80 # 开启80端口</span><br><span class="line">ADD index.html /var/www/html/index.html # 复制网站首页文件</span><br><span class="line">ADD run.sh /run.sh # 将执行脚本复制到镜像中</span><br><span class="line">RUN chmod 755 /run.sh # 启动容器时执行脚本</span><br><span class="line"></span><br><span class="line">CMD [&quot;/run.sh&quot;]</span><br></pre></td></tr></table></figure></li><li><p>编辑启动脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim run.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">rm -rf /run/httpd/*</span><br><span class="line">exec /usr/sbin/apachectl -D FOREGROUND</span><br><span class="line"> </span><br><span class="line">echo &quot;web test&quot; &gt; index.html</span><br></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker build -t httpd:centos . (注意别忘 了末尾有&quot;.&quot;，且.前面有空格)</span><br></pre></td></tr></table></figure></li><li><p>镜像容器启动运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d -p 1216:80 httpd:centos</span><br></pre></td></tr></table></figure></li><li><p>测试验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl http://192.168.40.30:1216</span><br></pre></td></tr></table></figure></li></ol><p>参考链接：<a href="https://blog.csdn.net/ygq13572549874/article/details/136558153">Docker镜像及Dockerfile详解</a></p><h2 id="docker-构建一个服务的过程-node-js">docker 构建一个服务的过程(node.js)</h2><ol><li><p>编写应用代码。首先，你需要有一个应用代码。例如，一个简单的 Node.js 应用</p></li><li><p>创建 Dockerfile<br>在应用的根目录下创建一个名为 Dockerfile 的文件。Dockerfile 包含了一系列的指令，用于告诉 Docker 如何构建镜像。例如，对于 Node.js 应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方 Node.js 镜像作为基础镜像</span></span><br><span class="line">FROM node:14</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"><span class="comment"># 复制 package.json 和 package-lock.json (如果有) 到工作目录</span></span><br><span class="line">COPY package*.json ./</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">RUN npm install</span><br><span class="line"><span class="comment"># 复制项目文件到工作目录</span></span><br><span class="line">COPY . .</span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">EXPOSE 3000</span><br><span class="line"><span class="comment"># 定义容器启动时执行的命令</span></span><br><span class="line">CMD [ <span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span> ]</span><br></pre></td></tr></table></figure></li><li><p>构建 Docker 镜像<br>打开终端或命令行工具，导航到包含 Dockerfile 的目录，然后运行以下命令来构建 Docker 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-nodejs-app .</span><br><span class="line"><span class="comment"># 这里，-t 参数用于标记你的镜像，my-nodejs-app 是你的镜像名称，. 表示 Dockerfile 所在的当前目录。</span></span><br></pre></td></tr></table></figure></li><li><p>运行 Docker 容器<br>构建完成后，你可以使用以下命令来运行你的 Docker 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:3000 my-nodejs-app</span><br><span class="line"><span class="comment"># 这里，-p 参数将容器的 3000 端口映射到主机的 4000 端口。现在，如果你的机器上的任何程序访问 localhost:4000，它们将会看到你的 Node.js 应用运行。</span></span><br></pre></td></tr></table></figure></li><li><p>检查运行状态（可选）<br>你可以使用以下命令来查看正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>停止并删除容器（可选）<br>当你完成测试后，可以停止并删除容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;container_id&gt;  <span class="comment"># 使用 docker ps 获取 container_id</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;container_id&gt;    <span class="comment"># 使用 docker ps 获取 container_id 或 docker rm $(docker ps -aq) 来删除所有容器</span></span><br></pre></td></tr></table></figure></li></ol><h1>部署相关</h1><h2 id="CI-CD聚焦代码集成与交付的自动化流程（Jenkins）">CI/CD聚焦代码集成与交付的自动化流程（Jenkins）</h2><p>CI/CD 是指持续集成(<code>Continuous Integration</code>)和持续部署(<code>Continuous Deployment</code>)或持续交付(<code>Continuous Delivery</code>)<br><strong>持续集成(Continuous Integration)</strong><br>持续集成是一种软件开发实践，团队成员频繁地将他们的工作集成到共享的代码仓库中。<strong>其主要特点包括</strong>:</p><ol><li><code>频繁提交代码</code>：开发人员可以每天多次提交代码，确保代码库始终保持最新状态。</li><li><code>自动化构建</code>：每次提交后，自动触发构建过程，包括编译、测试、静态分析等</li><li><code>快速反馈</code>：如果构建失败或测试不通过，能够快速地向开发人员提供反馈，以便及时修复问题。</li></ol><p><strong>持续部署(Continuous Deployment)</strong><br>持续部署是在持续集成的基础上，将通过所有测试的代码自动部署到生产环境中。其<strong>特点如下</strong>:</p><ol><li><code>自动化流程</code>：从代码提交到生产环境的部署完全自动化，无需人工干预。</li><li><code>高频率部署</code>：可以实现频繁的部署，使得新功能能够快速地提供给用户,</li><li><code>风险控制</code>：需要有强大的测试和监控体系来确保部署的稳定性和可靠性。</li></ol><p><strong>持续交付(continuous Delivery)</strong><br>持续交付与持续部署类似，但不一定自动部署到生产环境，而是随时可以部署。重点在于确保软件随时处于可发布状态。</p><p><strong>CI/CD 好处包括:</strong></p><ol><li><code>提高开发效率</code>：减少手动操作和等待时间，加快开发周期。</li><li><code>尽早发现问题</code>：通过频繁的集成和测试，问题能够在早期被发现和解决。</li><li><code>降低风险</code>：减少了大规模部署时可能出现的问题，提高了软件的质量和稳定性。</li><li><code>增强团队协作</code>：促进团队成员之间的沟通和协作，提高团队的整体效率，</li></ol><h2 id="DevOps？">DevOps？</h2><p>DevOps是涵盖开发与运维全生命周期协作的文化与实践体系。<br>DevOps是一种文化与方法论，旨在打破开发与运维的壁垒，通过自动化工具链、协作流程和共享责任，加速软件全生命周期交付。<br>DevOps覆盖更广包括需求规划、基础设施管理、监控反馈等全流程，强调团队协作、文化变革及工具整合。更强调“人+流程+工具”的系统性优化。<br>**技术优势：**更快地解决问题<br>**商业利益：**有更多时间可以增加价值（而不是修复/维护）</p>]]></content>
    
    
    <summary type="html">Docker</summary>
    
    
    
    <category term="Containerization Platform" scheme="https://southernfish.github.io/categories/Containerization-Platform/"/>
    
    
    <category term="Docker" scheme="https://southernfish.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>VUE</title>
    <link href="https://southernfish.github.io/2025/06/20/front-end-vue/"/>
    <id>https://southernfish.github.io/2025/06/20/front-end-vue/</id>
    <published>2025-06-20T14:15:36.000Z</published>
    <updated>2025-06-21T08:05:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>款用于构建用户界面的JavaScript框架。它基于标准<a href="https://baike.baidu.com/item/HTML/97049?fromModule=lemma_inlink">HTML</a>、CSS和<a href="https://baike.baidu.com/item/JavaScript/321142?fromModule=lemma_inlink">JavaScript</a>构建，并提供了一套声明式的、<a href="https://baike.baidu.com/item/%E7%BB%84%E4%BB%B6/6902128?fromModule=lemma_inlink">组件</a>化的编程模型，可以高效地开发<a href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/6582461?fromModule=lemma_inlink">用户界面</a>。无论是简单还是复杂的界面，Vue都可以胜任。</p><h1>基础</h1><h2 id="对于MVVM的理解？">对于MVVM的理解？</h2><ul><li><code>MVVM</code> 是 <code>Model-View-ViewModel</code> 的缩写</li><li>MVVM 的设计原理是<strong>基于 MVC</strong> 的</li><li><strong>Model代表数据模型 ；View 代表UI 组件视图；<strong>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是</strong>一个同步 View 和 Model 的对象，连接 Model 和 View</strong></li></ul><p><strong>优势：</strong><code>vue</code> 和 <code>mode</code> 之间是双向数据传递的，视图改变数据就可以改变，数据改变了视图也跟着改变</p><h2 id="Vue的生命周期">Vue的生命周期</h2><p><strong>生命周期：<strong>Vue 实例</strong>从创建到销毁的过程</strong>，就是生命周期。从<strong>开始创建、初始化数据、编译模板、挂载 Dom →渲染、更新→渲染、销毁</strong>等一系列过程，称之为 Vue 的生命周期。<br><strong>vue 生命周期的作用：<strong>它的生命周期中</strong>有多个事件钩子，在控制整个 Vue 实例的过程时更容易形成好的逻辑</strong>。<br><strong>vue 生命周期总共有 8 个阶段：</strong><code>创建前/后， 载入前/后，更新前/后，销毁前/销毁后</code>。<br>第一次页面加载会触发以下几个钩子：<code>beforeCreate, created, beforeMount, mounted</code> 。<br>DOM 渲染在 <code>mounted</code> 周期中就已经完成</p><h2 id="Vue的生命周期-2">Vue的生命周期</h2><p><code>beforeCreate</code>：在实例创建之间执行，数据是未加载状态。<br><code>created</code>：在实例创建、数据加载后，能初始化数据，DOM 渲染之前执行。<br><code>beforeMount</code>：虚拟 DOM 已创建完成，在数据渲染前最后一次更改数据。el 未挂载。<br><code>mounted</code>：页面、数据渲染完成。el 挂载完毕。可以访问 DOM 节点。<br><code>beforeUpdate</code>：重新渲染之前触发。不会造成重渲染。<br><code>Updated</code>：数据已经更新完成，DOM 也重新 render 完成，更改数据会陷入死循环。<br><code>beforeDestroy</code>：实例销毁前执行，实例仍然完全可用。<br><code>destroyed</code>：实例销毁后执行，这时候只剩下 DOM 空壳。</p><h2 id="Vue3的生命周期？">Vue3的生命周期？</h2><p><strong>创建期setup()</strong><br><strong>挂载期：</strong></p><ul><li><code>onBeforeMount()</code>：<strong>组件挂载到节点上之前</strong>执行的函数</li><li><code>onMounted()</code>：<strong>组件挂载完成后</strong>执行的函数，<strong>此时可以访问和操作DOM</strong></li></ul><p><strong>更新期：</strong></p><ul><li><code>onBeforeUpdate()</code>：<strong>组件更新之前</strong>执行的函数</li><li><code>onUpdated()</code>：<strong>组件更新完成之后</strong>执行的函数</li></ul><p><strong>销毁期：</strong></p><ul><li><code>onBeforeUnmount()</code>：<strong>组件卸载之前</strong>执行的函数，可以进行一些<strong>善后的工作</strong>，例如清理定时器等</li><li><code>onUnmounted()</code>：<strong>组件卸载完成后</strong>执行的函数，表示组件已经被完全销毁</li></ul><h2 id="vue获取数据在哪个周期函数">vue获取数据在哪个周期函数?</h2><p>一般 <code>created</code> / <code>beforeMount</code> / <code>mounted</code> 皆可， 比如如果你要操作 DOM , 那肯定 mounted 时候才能操作</p><h2 id="Vue实现数据双向绑定的原理">Vue实现数据双向绑定的原理</h2><p><strong>Vue2 实现数据双向绑定的原理：</strong><code>Object.defineProperty()</code><br>采用<strong>数据劫持结合发布者-订阅者模式的方式</strong>，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，<strong>触发相应监听回调</strong></p><p><strong>Vue3 实现数据双向绑定的原理：</strong><code>Proxy</code><br>当<strong>属性被修改时，Proxy 对象的 set 陷阱会被触发</strong>。此时，<strong>Vue3会通知所有依赖该属性的 Watcher 对象进行更新</strong>。Watcher 对象会调用对应的更新函数，从而触发视图的重新渲染</p><h2 id="Vue的路由实现：hash模式-和-history模式区别，上线有什么区别。">Vue的路由实现：hash模式 和 history模式区别，上线有什么区别。</h2><p>**hash模式：**在浏览器中符号<code>“#”</code>， 用<code>window.location.hash</code>读取<br><strong>history模式：<strong>采用HTML5新特性；<strong>方法 <code>pushState()，replaceState()</code> 可修改浏览器历史记录栈</strong>，<code>popState</code> 事件监听状态变更。<br>上线区别<br><strong>hash模式：<strong>URL 形式：<a href="http://example.com/">http://example.com/</a></strong>#/path</strong>，</strong># 后面的部分来模拟一个完整的 URL</strong>，不会引起页面的重新加载。<br><strong>history 模式：<strong>URL 形式：<a href="http://example.com">http://example.com</a></strong>/path</strong>，<strong>需配置服务器</strong>，否则会当成真正的路径要后端配置重定向，不然访问不到。</p><h2 id="Vue组件间的参数传递-和父子组件方法调用（组件通信）">Vue组件间的参数传递 和父子组件方法调用（组件通信）</h2><ul><li><strong>父组件与子组件传值</strong><ul><li>父组件传给子组件：<strong>子组件通过<code>props</code>方法接受数据；</strong></li><li>子组件传给父组件：<strong><code>$emit</code> 方法传递参数</strong></li></ul></li><li><strong>非父子组件间的数据传递，兄弟组件传值</strong><ul><li><code>eventBus</code>，就是<strong>创建一个事件中心</strong>，相当于中转站，<strong>可用它传递事件和接收事件</strong>。比较适合项目较小时。</li><li>事件总线： <code>Vue.prototype.$bus = new Vue()；</code>使用 <code>Vuex</code></li></ul></li><li>provide 和 inject</li><li>父组件调用子组件方法：<code>this.$refs.mychildren.function()</code></li><li>子组件调用父组件方法： <code>this.$parent.function()</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">params传值</span><br><span class="line">&#123;path:/user/:id&#125; // 路由里:id</span><br><span class="line">&lt;router-link to =&quot;/user/123&quot;&gt;&lt;/router-link&gt; // 组件传值 用/id</span><br><span class="line">this.$router.params.id // js代码中获取路由传递的id值</span><br><span class="line"></span><br><span class="line">query传值</span><br><span class="line">&#123;path:&#x27;/user&#x27;&#125; // 路由</span><br><span class="line">// 组件传值 使用?拼接 参数之间用&amp;</span><br><span class="line">&lt;router-link to =&quot;/user? id=123&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to =&quot;/user?id=123&amp;name=zs&quot;&gt;&lt;/router-link&gt; //组件传值</span><br><span class="line">this.$router.query.id //取值</span><br><span class="line">this.$router.query.name //取值</span><br></pre></td></tr></table></figure><h2 id="params和query的区别">params和query的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>**用法：**query 用 path 引入，params 用 name 引入，接收参数类似，分别是 <code>this.$route.query.name</code> , <code>this.$route.params.name</code><br>**url地址显示：**query 类似于 ajax 中 get 传参，params 类似于 post，或者说 query 在浏览器地址栏中显示参数，params 不显示</p><h1>vuex是什么？怎么使用？哪种功能场景使用它？</h1><p><code>vuex</code> 是一种集中式状态管理模式，它按照一定的规则管理状态，保证状态的变化是可预测的。<br>vuex 可以理解为一种开发模式或框架，<strong>通过状态集中管理驱动组件的变化，应用级的状态集中放在store中，改变状态的方式是提交 mutations，异步逻辑封装在 action 中</strong>。</p><p><strong>使用方式：</strong><br>在 main.js 引入 store，注入。只用来读取的状态集中放在 store 中；<br>改变状态的方式是提交 mutations ，这是个同步的事物； 异步逻辑应该封装在 action 中。</p><p><strong>场景：单页应用中</strong>，组件之间的状态、音乐播放、登录状态、加入购物车<br><code>state</code>：定义初始化状态<br><code>getters</code>：获取状态<br><code>mutations</code>：设置状态<br><code>actions</code>：异步提交 mutations<br><code>modules</code>：把状态管理模块化，各自的组件构成各自的模块</p><h2 id="css只在当前组件起作用">css只在当前组件起作用</h2><p>在 style 标签中写入 <code>scoped</code> 即可 例如：<code>&lt;style scoped&gt;&lt;/style&gt;</code></p><h2 id="v-if-和-v-show-区别">v-if 和 v-show 区别</h2><p><strong>相同点：<strong>v-if 与 v-show 都可以</strong>动态控制 dom 元素显示隐藏</strong><br>**不同点：**v-if 将 dom 元素整个添加或删除 ，<strong>v-show 隐藏是为该元素添加 css–display:none，dom 元素还在</strong>。</p><h2 id="route和router的区别"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>和</mtext></mrow><annotation encoding="application/x-tex">route和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">和</span></span></span></span>router的区别</h2><p><code>$route</code> 是<strong>路由信息对象</strong>，包括 path，params，hash，query，fullPath，matched，name等路由信息参数。 而$router 是<code>VueRouter</code> <strong>路由实例</strong> 对象包括了路由的跳转方法，钩子函数等。</p><h2 id="vue-js的两个核心是什么？">vue.js的两个核心是什么？</h2><p>数据驱动、组件系统</p><h2 id="computed、watch、methods的区别">computed、watch、methods的区别</h2><p><code>computed</code> 要有返回值，支持缓存。watch 不支持缓存。methods 不支持缓存。<br>**<code>watch</code> 项目用处：**搜索框输入框的监听；监听路由地址的改变</p><h2 id="vue几种常用的指令">vue几种常用的指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v-for (循环指令，可以循环数组或对象)</span><br><span class="line">v-if (是否渲染元素，会销毁并重建)</span><br><span class="line">v-bind (动态绑定数据)</span><br><span class="line">v-on (绑定事件监听器)</span><br><span class="line">v-show (显示隐藏元素，修改元素的 display 属性)</span><br><span class="line">v-else(与 v-if 配合使用)</span><br><span class="line">v-model (实现双向绑定)</span><br></pre></td></tr></table></figure><h2 id="v-for与v-if-一起使用">v-for与v-if 一起使用</h2><p>由于<strong>v-for会先执行，v-if 将分别重复运行于每个 v-for 循环中</strong>。这可能会导致不必要的计算，性能下降，特别是在处理大型数据集时，可能会使代码的逻辑变得不清晰。<br>在<code>Vue 2</code>中在同一个元素上同时使用这两个指令时 <strong>v-for 的优先级高于 v-if</strong> ，<br>在<code>Vue 3</code>中，<strong>v-if 的优先级高于 v-for</strong>。不推荐一起使用 在外层包装一个 template 标签</p><h2 id="v-on-可以绑定多个方法吗？">v-on 可以绑定多个方法吗？</h2><p>可以 … 例：<code> &lt;p @click=“one(),two()”&gt;</code>点击</p><h2 id="vue中key-值的作用">vue中key 值的作用</h2><p>原理是vue 在**<code>pacth</code>过程中<strong>通过 key 可以精准判断两个节点是否是同一个， 从而避免平凡更新不同元素，减少dom操作，提升性能<br>key值</strong>对数据改变之后的diff更新比较有很大的性能提升**，或者说有了key和没有key是两种比较和更新机制<br>作用主要是为了<strong>高效的更新虚拟DOM</strong>。另外vue中在<strong>使用相同标签名元素的过渡切换时</strong>，也会使用到key属性，目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果，就不会达到最小更新<br><strong>index值不是一定不变的</strong>，若不加key值，删除前面的项。后面的index可能变也可能不变，如加个定时器时会变，不加定时器不变</p><h2 id="nextTick的使用">$nextTick的使用</h2><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新的 DOM。</p><h2 id="nextTick能获取到最新dom是什么原理">$nextTick能获取到最新dom是什么原理</h2><p>当修改了数据，Vue 会将这些变更放入一个异步任务队列，而不是立即更新 DOM。<br><code>$nextTick</code> 的<strong>回调函数是在任务队列中的所有任务执行完毕后调用的</strong>，这意味着 DOM 更新已经完成。</p><h2 id="项目初始化页面闪动问题">项目初始化页面闪动问题</h2><p>vue 页面在加载的时候闪烁花括号{}，v-cloak 指令和 css 规则如 [v-cloak]{ display:none }一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。<br>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*css样式*/</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--html代码--&gt;</span><br><span class="line">&lt;div id=&quot;app&quot; v-cloak&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;item in tabs&quot;&gt;&#123;&#123;item.text&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="怎么理解vue中的-diff-算法？">怎么理解vue中的 diff 算法？</h2><p><code>diff</code> 算法是<strong>虚拟DOM的产物</strong>，通过新旧虚拟 dom 对比， 将变化的地方更新在真实的 dom 上<br><code>diff</code> 算法<strong>能精准找到发生的变化的地方</strong></p><h2 id="vue-怎么缓存-keep-alive">vue 怎么缓存 keep-alive</h2><p><code>keep-alive</code> 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染；可以实现组件缓存，当组件切换时不会对当前组件进行卸载；有 <code>include</code>、<code>exclude</code> 两个属性，可以有条件的进行组件缓存<br><code>keep-alive</code>功能：当组件切换为非激活状态时，不会触发销毁流程，而是将组件实例及其状态完整封存。这一特性使其成为保留组件状态、优化渲染性能的核心工具。<br>生命周期钩子联动。当组件在 keep-alive 内切换时，会触发专属生命周期钩子：</p><ul><li><code>activated</code>：组件激活时调用（首次渲染或从缓存中恢复）</li><li><code>deactivated</code>：组件失活时调用（被切换出但未销毁）</li></ul><p>应用场景1：路由页面状态持久化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 缓存所有路由组件 --&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;!-- 精准缓存指定路由组件 --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;[&#x27;Home&#x27;, &#x27;Profile&#x27;]&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>应用场景2：动态组件状态保留</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;keep-alive&gt;</span><br><span class="line">    &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/keep-alive&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123; currentComponent: &#x27;Login&#x27; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="vue组件中data为什么必须是一个函数？">vue组件中data为什么必须是一个函数？</h2><p>由 <code>JavaScript</code> 的特性所导致，在 <code>component</code> 中，data 必须以函数的形式存在，不可以是对象。组建中的 data 写成一个函数，数据以函数返回值的形式定义，这样<strong>每次复用组件的时候，都会返回一份新的 data ，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱</strong>。而单纯的写成对象形式，就是所有的组件实例共用了一个 data ，这样改一个全都改了。</p><h2 id="assets和static的区别">assets和static的区别?</h2><p>这两个都是用来<strong>存放项目中所使用的静态资源文件</strong>。<br><strong>两者的区别：</strong><br><code>assets</code> 中的文件在运行 <code>npm run build</code> 的时候会打包，也就是会被<strong>压缩体积，代码格式化</strong>之类的。<strong>打包之后也会放到 static 中</strong>。<br><code>static </code>中的文件则<strong>不会被打包</strong>。<br>**建议：**将图片等未处理的文件放在 assets 中，打包减少体积。而对于第三方引入的资源文件（如：iconfont.css等）可以放在static 中，因为这些文件已经经过处理了。</p><h2 id="vue的常用修饰符">vue的常用修饰符</h2><p><code>.prevent</code>：提交事件不再重载页面；等同于 JavaScript 中的 event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）<br><code>.stop</code>：阻止单击事件冒泡；等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡。<br><code>.self</code>：只会触发自己范围内的事件，不包含子元素；<br><code>.capture</code>：事件侦听，事件发生的时候会调用；与事件冒泡的方向相反，事件捕获由外到内<br><code>.once</code>：只会触发一次<br><code>.passive</code>：提升移动端的性能。</p><h2 id="vue其他修饰符？">vue其他修饰符？</h2><p><strong>按键修饰符：</strong><code>.enter</code>、<code>.delete</code>、<code>.space</code>、<code>.esc</code>、<code>.up</code>、<code>.down</code>等<br><strong>系统修饰键：</strong><code>.ctrl</code>、<code>.alt</code><br><strong>鼠标按钮修饰符：</strong><code>.left</code>、<code>.right</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 阻止单击事件继续传播</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">// 提交事件不再重载页面</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line">// 修饰符可以串联</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line">// 只有修饰符</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line">// 添加事件监听器时使用事件捕获模式 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line">// 只当在 event.target 是当前元素自身时触发处理函数  即事件不是从内部元素触发的</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class="line">// 点击事件将只会触发一次</span><br><span class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">// 滚动事件的默认行为 (即滚动行为) 将会立即触发, 不会等待onScroll完成,这其中包含 `event.preventDefault()` 的情况</span><br><span class="line">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="vue深度监听（watch）">vue深度监听（watch）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">watch:</span><br><span class="line">// 第一种</span><br><span class="line">&quot;a.b.c&quot;:function(newValue, oldValue)&#123;</span><br><span class="line">    console.log(newValue, oldValue);</span><br><span class="line">&#125;</span><br><span class="line">// 第二种</span><br><span class="line">a: &#123;</span><br><span class="line">    deep: true, // deep为ture 意味着开启了深度监听a对象里面任何数据变化都会触发</span><br><span class="line">    handler(newValue, oldvalue)&#123;</span><br><span class="line">        //这个函数是固定写法</span><br><span class="line">        console.log(newValue, oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Vue-router</h1><h2 id="vue路由的钩子函数-路由守卫">vue路由的钩子函数 (路由守卫)</h2><p>首页可控制导航跳转，beforeEach，afterEach等，一般用于页面title修改。一些需要登录才能调整页面的重定向功能。<br><strong>beforeEach((to,from,next)=&gt;{});</strong></p><ul><li><code>to</code>：route 即将进入的目标路由对象，</li><li><code>from</code>：route 当前导航正要离开的路由</li><li><code>next</code>：function一定要调用该方法resolve这个钩子。执行效果依赖 next 方法的调用参数。可控制网页跳转。</li></ul><p><strong>router.afterEach((to,from)=&gt;{});</strong></p><ul><li><code>to</code>：已进入的目标路由对象</li><li><code>from</code>：已离开的路由对象</li></ul><h2 id="vue-router有哪几种导航钩子？以及它的参数？">vue-router有哪几种导航钩子？以及它的参数？</h2><p><strong>第一种：全局导航</strong>钩子：<code>router.beforeEach(to,from,next)</code>，**作用：**跳转前进行判断拦截。<br><strong>第二种：组件内</strong>的钩子<br><strong>第三种：单独路由独享组件</strong><br>beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave<br>**参数：**to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，不用就拦截）</p><h2 id="Vue-router的跳转原理">Vue-router的跳转原理</h2><p><strong>Vue-router的跳转原理:</strong> 通过不同的模式来实现页面的无刷新跳转，主要包括 hash 模式、history 模式和 abstract 模式。</p><ul><li><code>hash</code>：使用 <code>URL hash</code> 值来作路由。默认模式。</li><li><code>history</code>：依赖 <code>HTML5 History API</code> 和服务器配置。查看 HTML5 History 模式。</li><li><code>abstract</code>：支持所有 JavaScript 运行环境，如 Node.js 服务器端</li></ul><p><strong>路由之间的跳转:</strong></p><ul><li>声明式（标签跳转）<ul><li><code>&lt;router-view&gt;</code>标签用于展示路由组件，DOM节点中使用 <code>v-link</code> 进行跳转，或使用 <code>router-link</code> 标签</li></ul></li><li>编程式（js跳转）</li></ul><h2 id="怎么定义vue-router的动态路由及如何获取传过来的动态参数？">怎么定义vue-router的动态路由及如何获取传过来的动态参数？</h2><p>在 router 目录下的 index.js 文件中，对 path 属性加上/：id<br>使用 router 对象的 params id<br>**用 watch 去监听 router 变化：**当路由发生变化的时候，在 watch 中写具体的业务逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    $router(to, from)&#123;</span><br><span class="line">        console.log(to.path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue的路由实现-hash模式和history模式-Vue的两种状态">Vue的路由实现: hash模式和history模式(Vue的两种状态)</h2><p>**hash模式：**即地址栏URL的#符号<br>通过<code> window.onhashchange</code> <strong>监听，匹配不同的 url 路径，进行解析，加载不同的组件，然后动态的渲染出区域内的html 内容</strong>，不会被包含在HTTP请求中，对后端完全没有影响<br><strong>HashHistory 有两个方法：</strong></p><ul><li>HashHistory.push() 是将路由添加到浏览器访问历史的栈顶</li><li>hashHistory.replace() 是替换掉当前栈顶的路由</li></ul><p>因为<strong>hash发生变化的url都会被浏览器历史访问栈记录下来</strong>，因此尽管浏览器没有请求服务器，但页面状态是和url关联起来的，浏览器还是可以进行前进后退的</p><p><strong>history模式</strong><br>利用 HTML5 History Interface 中新增的 <strong>pushState()</strong> 和 <strong>replaceState()</strong> 方法。这两个方式应用于浏览器的历史记录栈，<strong>提供了对历史记录的修改功能</strong>。history模式不怕页面的前进和后腿，就怕刷新，当<strong>刷新时，若服务器没有相应的响应或者资源，就会刷出404</strong>，而hash模式不会<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>从当前</mtext><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext>跳转对象里面可以获取</mtext><mi mathvariant="normal">‘</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext>、</mtext><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mtext>、</mtext><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mtext>、</mtext><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">‘</mi><mtext>等（</mtext><mi mathvariant="normal">‘</mi><mo>&lt;</mo><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo>−</mo><mi>l</mi><mi>i</mi><mi>n</mi><mi>k</mi><mo>&gt;</mo><mi mathvariant="normal">‘</mi><mtext>传的参数有</mtext><mi mathvariant="normal">‘</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">route 从当前 router 跳转对象里面可以获取 `name、path、query、params` 等（`&lt;router-link&gt;`传的参数有`this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">从当前</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord cjk_fallback">跳转对象里面可以获取</span><span class="mord">‘</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">ery</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">am</span><span class="mord mathnormal">s</span><span class="mord">‘</span><span class="mord cjk_fallback">等（</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03148em;">ink</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">‘</span><span class="mord cjk_fallback">传的参数有</span><span class="mord">‘</span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span>route.query<code>或者</code>this.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">‘</mi><mtext>接收）导航到不同</mtext><mi>U</mi><mi>R</mi><mi>L</mi><mtext>，则使用</mtext><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">route.params` 接收）导航到不同URL，则使用 `</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">am</span><span class="mord mathnormal">s</span><span class="mord">‘</span><span class="mord cjk_fallback">接收）导航到不同</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">L</span><span class="mord cjk_fallback">，则使用</span><span class="mord">‘</span></span></span></span>router.push<code>方式，返回上一个history也是使用</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>g</mi><mi>o</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">router.go/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">o</span><span class="mord">/</span></span></span></span>router.back` 方法</p>]]></content>
    
    
    <summary type="html">VUE</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="VUE" scheme="https://southernfish.github.io/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="https://southernfish.github.io/2025/06/20/front-end-base/"/>
    <id>https://southernfish.github.io/2025/06/20/front-end-base/</id>
    <published>2025-06-20T13:15:36.000Z</published>
    <updated>2025-06-21T08:05:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>前端技术是Web应用开发中基于浏览器的程序开发，涵盖HTML、CSS和JavaScript等基础技术，并通过BOM、DOM实现用户交互。该技术以HTML、CSS、JavaScript为核心基础，通过DOM与BOM实现动态页面控制。</p><h2 id="HTML5的新特性和CSS3的新特性">HTML5的新特性和CSS3的新特性</h2><p><strong>HTML5的新特性</strong></p><ul><li><strong>语义化标签 ：</strong><code>header</code>、<code>nav</code>、 <code>aside</code>、<code>footer</code>、<code>article</code>、<code>section</code> 等。可以更清晰地描述网页的结构和内容，提高网页的可读性和可访问性，利于搜索引擎优化（SEO）。</li><li>**表单控件验证功能：**如日期选择器、颜色选择器、滑块等，表单更加易用，同时内置表单验证功能，减少了验证代码的编写量。</li><li><strong>多媒体支持：</strong> video audio等</li></ul><p><strong>CSS3的新特性</strong></p><ul><li><strong>改善布局和样式：</strong> 如边框圆角、边框阴影、渐变、文本装饰</li><li><strong>动画和过渡：</strong> <code>transition</code> 属性和 <code>@keyframes</code> 规则制定动画效果</li><li>多列布局和弹性盒子布局</li><li><strong>媒体查询:</strong> 不同屏幕的尺寸使用不同的<code>css</code></li><li>自定义字体和背景</li><li>**网格布局 ：*<em>上下居中水平对齐方式<code>display: grid; place-items: center; </code>/</em> 水平和垂直都居中 */</li></ul><h3 id="css-选择器的优先级排序">css 选择器的优先级排序</h3><p>优先级排序从高到低：<code>!important</code> 、<code>行内样式</code>、<code>ID选择器</code>、<code>类选择器</code></p><h2 id="link和a标签区别">link和a标签区别</h2><p><code>link</code>是一个组件，用处也是页面内跳转。<code>a</code>是基础的标签，也是用来跳的。</p><h2 id="什么是CSS盒模型-IE盒模型和W3C盒模型">什么是CSS盒模型 &gt;&gt;&gt; -IE盒模型和W3C盒模型</h2><p><strong>标准模式</strong>下，一个块的宽度 = width + padding(内边距) + border(边框) + margin(外边距)；<br><strong>怪异模式</strong>下，一个块的宽度 = width + margin(外边距) （即怪异模式下，width包含了border以及padding）;</p><h3 id="div-上下居中对齐的几种方式">div 上下居中对齐的几种方式</h3><p>第一种：flex布局</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center; // 水平居中 </span><br><span class="line">    align-items: center; // 垂直居中 </span><br><span class="line">    height: 100vh; // 或其他高度 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：grid网格布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    place-items: center; // 水平和垂直都居中 </span><br><span class="line">    height: 100vh; // 或者其他需要的高度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种：相对定位和绝对定位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123; position: relative; height: 100vh; &#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform:translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四种：line-height 适用于单行文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    line-height: 100vh;</span><br><span class="line">    text-align: cente</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪类和伪元素的区别">伪类和伪元素的区别</h3><p><strong>伪类：<strong>伪类</strong>用于选择DOM树之外的信息</strong>。<code>:hover</code> 伪类用于选择鼠标悬停在其上的元素，<code>:visited</code> 用于选择已访问的链接等<br><strong>伪元素：<strong>伪元素为</strong>DOM树没有定义的虚拟元素</strong>。 例如，<code>::before</code> 和 <code>::after </code>伪元素允许在元素内容之前或之后插入内容</p><h2 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h2><p><strong>浅拷贝</strong><br>在栈内存中重新开辟一块内存空间，并将拷贝对象储存在栈内存中的数据存放到其中。<br>**存在问题：**浅拷贝只复制了引用，所以修改新对象会影响到原对象<br><strong>实现方法：</strong> 使用<code>赋值运算符（=）</code>或者<code>Object.assign()</code>函数进行拷贝</p><p><strong>深拷贝</strong><br>另外创造一个一模一样的对象<br>**优点：**修改新对象不会影响到原对象<br>**实现方法：**递归拷贝 <code>JSON.parse(JSON.stringify(obj))</code>，<code> …扩展运算符</code><br><code>const b = […a]; </code>// 这只适用于一层深拷贝<br><code>const c = JSON.parse(JSON.stringify(a)); </code>// 深拷贝<br>// 如果是个对象有函数或者空值，<code>undefind</code>时会有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 对象的深拷贝</span><br><span class="line">JSON.parse(JSON.stringify())</span><br><span class="line">// 递归的实现复制一个对象或者数组</span><br><span class="line">function clone(obj)&#123;</span><br><span class="line">  if(obj === null &amp;&amp; typeof obj !=== &#x27;object&#x27;) &#123;</span><br><span class="line">    return obj</span><br><span class="line">  &#125;</span><br><span class="line">  const cloneObj= Array.isArray(obj) ? []:&#123;&#125;</span><br><span class="line">  for(const key in obj)&#123;</span><br><span class="line">    cloneObj[key]= clone(obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">  return cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装axios">封装axios</h2><p>例如一次发出两个一模一样的请求如何清除一个，通过使用 <code>Axios</code> 的 <code>CancelToken</code> 和请求拦截器，如果已经有相同的请求在进行中，取消之前的请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//axios封装</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line">const instance = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;https://api.example.com&#x27;,</span><br><span class="line">  timeout: 10000,</span><br><span class="line">&#125;);</span><br><span class="line">// 封装 GET 请求</span><br><span class="line">const get = (url, params, cancelToken)=&gt;&#123;</span><br><span class="line">  return instance.get(url, &#123;params, cancelToken &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">// 封装 POST 请求</span><br><span class="line">const post = (url, data, cancelToken)=&gt;&#123;</span><br><span class="line">  return instance.post(url, data, &#123; cancelToken &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">export default &#123;get,post,&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//使用 CancelToken 取消重复请求</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line">import api from &#x27;./api&#x27;; // 上面封装的 Axios 实例</span><br><span class="line"></span><br><span class="line">const pendingRequests = new Map();</span><br><span class="line">const CancelToken = axios.CancelToken;</span><br><span class="line"></span><br><span class="line">const requestInterceptor = (config) =&gt; &#123;</span><br><span class="line">  const &#123; url, method, params, data &#125; = config;</span><br><span class="line">  // 生成唯一标识符</span><br><span class="line">  const key = `$&#123;method&#125;-$&#123;url&#125;-$&#123;JSON.stringify(params)&#125;-$&#123;JSON.stringify(data)&#125;`;</span><br><span class="line">  if (pendingRequests.has(key)) &#123;</span><br><span class="line">    // 如果已经有相同的请求在进行中，取消之前的请求</span><br><span class="line">    const cancelToken = pendingRequests.get(key);</span><br><span class="line">    cancelToken(&#x27;Request canceled due to duplicate request&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 创建新的取消令牌</span><br><span class="line">  const source = CancelToken.source();</span><br><span class="line">  config.cancelToken = source.token;</span><br><span class="line">  // 将新的请求加入到 pendingRequests 中</span><br><span class="line">  pendingRequests.set(key, source.cancel);</span><br><span class="line">  // 在请求完成后删除该请求</span><br><span class="line">  config.interceptors.response.use(</span><br><span class="line">    (response) =&gt; &#123;</span><br><span class="line">      pendingRequests.delete(key);</span><br><span class="line">      return response;</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      pendingRequests.delete(key);</span><br><span class="line">      return Promise.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  return config;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 添加请求拦截器</span><br><span class="line">instance.interceptors.request.use(requestInterceptor);</span><br><span class="line"></span><br><span class="line">// 示例请求</span><br><span class="line">const fetchUserData = async (userId) =&gt; &#123;</span><br><span class="line">  try &#123; &#125; catch (error) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 发起两个相同的请求</span><br><span class="line">fetchUserData(1);</span><br><span class="line">fetchUserData(1);</span><br></pre></td></tr></table></figure><h2 id="HTTPS的工作流程，HTTPS证书的验证">HTTPS的工作流程，HTTPS证书的验证</h2><p>**客户端发起<code>HTTPS</code>请求：**客户端向服务器发起HTTPS请求，并指定要访问的HTTPS资源的URL。<br>**服务器返回公钥证书：**服务器将包含公钥的证书发送给客户端。<br><strong>客户端验证证书：<strong>客户端验证证书的合法性，包括证书</strong>是否由受信任的CA（证书颁发机构）签发、证书是否过期等</strong>。<br>**生成并发送对称加密密钥：**如果证书验证通过，客户端将生成一个对称加密密钥，并使用服务器公钥对该密钥进行加密后发送给服务器。<br>**服务器解密对称加密密钥：**服务器使用自己的私钥解密得到对称加密密钥。<br>**加密传输数据：**双方使用协商好的对称加密密钥对传输的数据进行加密和解密。</p><h2 id="JSONP原理">JSONP原理</h2><p>利用script标签 的 src 没有跨域限制的“漏洞” 来达到与第三方通讯的目的。只能处理get请求<br><strong>CORS：<strong>服务器端支持CORS主要通过设置</strong>Access-Control-Allow-Origin</strong>进行。浏览器检测到相应设置则允许Ajax跨域访问。</p><p><strong>vue中的跨域问题：</strong><br>找到配置文件config.js   <strong>修改<code>proxyTable</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proxyTable:</span><br><span class="line">&#x27;/api&#x27;: &#123;</span><br><span class="line">  target: &#x27;http://www.xxxxxx.com/api&#x27;，//指定代理的地址</span><br><span class="line">  changeOrigin: true，//是否允许跨越, 改变源到url，在虚拟主机上很有用</span><br><span class="line">  pathRewrite: &#123;</span><br><span class="line">    &#x27;^/api&#x27;: &#x27;/&#x27;, // 重写</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 若后端地址不带路径’/api’, ‘http://www.xxxxxx.com/api’ 改为‘http://www.xxxxxx.com’</span><br></pre></td></tr></table></figure><h2 id="cookie、sessionStorage、localStorage的区别">cookie、sessionStorage、localStorage的区别</h2><p>它们的区别在于存储的<strong>有效期和作用域的不同</strong><br>**<code>cookie</code>：**默认的，<strong>有效期很短，一旦用户关闭浏览器，Cookie保持的数据就会丢失；cookie存储空间比较小（ 4KB左右）</strong>。<br>为解决 HTTP 无状态的问题，常使用 Cookie 和 Session 等机制来在客户端和服务器之间保持状态。Cookie 是一种<em>在客户端存储少量数据并在每个请求中发送给服务器的机制，而 Session 则是在服务器端存储用户状态信息，并通过在客户端和服务器之间传递 Session ID 来保持会话状态</em>。<br><strong><code>localStorage</code>：存储的数据是永久性的， 除非手动删除；存储大小通常为5-10MB；作用域限制在文档源级别</strong>，同源的文档间共享同样的localStorage数据<br><strong><code>sessionStorage</code>：存储的数据存在会话期 ； 通常可以达到5MB左右；一旦窗口或者浏览器标签页关闭存储的数据也会被删除； 作用域也是限定在文档源中。</strong></p><h2 id="浏览器与服务器的交互原理">浏览器与服务器的交互原理</h2><ol><li>输入网址</li><li>浏览器发送 http 请求</li><li>与dns 建立tcp/ip 3次握手</li><li>服务器 解析 并查找对应的域名</li><li>服务器相应数据返回</li><li>浏览器 下载 解析 服务器的响应数据</li><li>创建dom树 并解析css 与js 直到页面渲染完毕</li></ol><h2 id="A解释一下闭包，B为什么要使用闭包？-缺点">A解释一下闭包，B为什么要使用闭包？ 缺点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">  var n =0;</span><br><span class="line">  function b()&#123; </span><br><span class="line">    n++;</span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**闭包：**以上代码中，b 函数访问了构造函数 a 里面的变量，所以形成了一个闭包<br>**使用闭包的原因：**想要持续的使用一个变量，放在全局中会造成全局污染，放在函数中，函数执行完后会销毁，变量也随之销毁，因此需要使用闭包。<br><strong>拓展：</strong> 闭包函数是在<code>window</code>作用域下执行的，也就是说，<code>this</code>指向windows<br>**缺点 ：**内存泄露问题， 所以不能滥用闭包</p><h2 id="解释一下作用域链">解释一下作用域链</h2><p>函数A 嵌套函数B， 函数B嵌套函数C ：函数C里访问一个变量，先去C的作用域找 ，再往上一级找，直到window</p><h2 id="如何处理不让别人盗用你的图片，访问你的服务器资源？">如何处理不让别人盗用你的图片，访问你的服务器资源？</h2><ul><li>对于 nginx，可考虑用 location 通配你的图片后缀，根据 refer，再决定是否返回图片资源。</li><li><strong>又拍云、七牛云</strong>都有<strong>防盗链配置</strong></li><li>若未使用 cdn，即需要自己做防盗链。<ul><li><strong>一是</strong>判断 <code>refer</code>，看来源是不是自己的网站，不是就拒绝。适用范围最大，也<strong>容易破解， 因为 refer 可以伪造</strong>。</li><li><strong>二是</strong> <code>session 校验</code>，若不通过特定服务生成 cookie 和 session 就不能请求得到资源。最保险，因为 session 在后端。</li></ul></li><li>给图片加水印</li></ul><h2 id="如何优化网站性能">如何优化网站性能</h2><ul><li>许多<strong>小图片整合到一张大图片中</strong>（精灵图）减少网页http请求，以提升网页加载速度。对于小图标，可使用 base64 位编码，以减少网络请求。但不建议大图使用，比较耗费CPU； <strong>小图标优势</strong>在于：<strong>减少 HTTP 请求； 避免文件跨域； 修改及时生效</strong>。</li><li><strong>代码压缩</strong>，应用第三方资源库，cdn 托管</li><li><strong>控制资源文件加载优先级</strong>，css 优先，一般情况下都是CSS在头部，JS在底部。</li><li>利用浏览器<strong>缓存</strong></li><li><strong>减少页面重排</strong>，使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）；</li><li><strong>图片<code>lazyload</code> 懒加载</strong>，提高用户体验</li><li><strong>禁止使用gif图片实现loading效果</strong>（降低CPU消耗，提升渲染性能）；</li><li><strong>减少dom 操作，优化js</strong></li></ul>]]></content>
    
    
    <summary type="html">涵盖HTML、CSS和JavaScript等基础技术，通过DOM与BOM实现动态页面控制。</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="front end" scheme="https://southernfish.github.io/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://southernfish.github.io/2025/06/20/java-jvm/"/>
    <id>https://southernfish.github.io/2025/06/20/java-jvm/</id>
    <published>2025-06-20T04:58:36.000Z</published>
    <updated>2025-06-21T08:05:35.151Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%9C%BA/104440?fromModule=lemma_inlink">虚拟机</a>是一种抽象化的计算机，通过在实际的计算机上<a href="https://baike.baidu.com/item/%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F/407213?fromModule=lemma_inlink">仿真模拟</a>各种计算机功能来实现的。<a href="https://baike.baidu.com/item/Java/85979?fromModule=lemma_inlink">Java</a>虚拟机有自己完善的<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BD%93/1298863?fromModule=lemma_inlink">硬体</a>架构，如处理器、<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032?fromModule=lemma_inlink">堆栈</a>、<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682?fromModule=lemma_inlink">寄存器</a>等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的<a href="https://baike.baidu.com/item/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81/9407934?fromModule=lemma_inlink">目标代码</a>（<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683?fromModule=lemma_inlink">字节码</a>），就可以在多种平台上不加修改地运行。本文简单记录一些关于JVM的问题。</p><h1>基础部分</h1><h2 id="JVM-的主要组成部分？及其作用？">JVM 的主要组成部分？及其作用？</h2><p>类加载器（<code>ClassLoader</code>）、运行时数据区（<code>Runtime Data Area</code>）、执行引擎（<code>Execution Engine</code>）、本地库接口（<code>Native Interface</code>）<br><strong>组件的作用：</strong> 首先通过类加载器（<code>ClassLoader</code>）<strong>把 Java 代码转换成字节码</strong>，然后运行时数据区（<code>Runtime Data Area</code>）再<strong>把字节码加载到内存</strong>中，而字节码文件只是 JVM 的一套指令集规范，不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（<code>Execution Engine</code>），<strong>将字节码翻译成底层系统指令</strong>，再<strong>交由 CPU 执行</strong>，而这个<strong>过程中需要调用其他语言的本地库接口</strong>（<code>Native Interface</code>）来实现整个程序的功能。</p><h2 id="JVM-运行时数据区？">JVM 运行时数据区？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不同虚拟机运行时数据区可能略微有所不同，但都会遵从Java 虚拟机规范，Java 虚拟机规范规定区域分为以下 5 个部分：</span><br><span class="line">程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</span><br><span class="line">Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</span><br><span class="line">本地方法栈（Native Method Stack）：与虚拟机栈的作用一样，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</span><br><span class="line">Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，被所有线程共享，几乎所有的对象实例都在这里分配内存；</span><br><span class="line">方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不同虚拟机运行时数据区可能略微有所不同，但都会遵从Java 虚拟机规范，Java 虚拟机规范规定区域分为以下 5 个部分：<br>**程序计数器（<code>Program Counter Register</code>）：**当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，<strong>分支、循环、跳转、异常处理、线程恢复等基础功能</strong>，都需要依赖这个计数器来完成；<br><strong>Java 虚拟机栈（<code>Java Virtual Machine Stacks</code>）：<strong>用于</strong>存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>；<br><strong>本地方法栈（<code>Native Method Stack</code>）：<strong>与虚拟机栈的作用一样，只不过虚拟机栈是服务 Java 方法的，而本地方法栈</strong>为虚拟机调用 Native 方法服务</strong>；<br><strong>Java 堆（<code>Java Heap</code>）：<strong>Java 虚拟机中</strong>内存最大的一块，被所有线程共享，几乎所有的对象实例都在这里分配内存</strong>；<br><strong>方法区（<code>Methed Area</code>）：<strong>用于</strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</strong>。</p><h2 id="堆栈的区别？">堆栈的区别？</h2><p><strong>功能方面：堆是用来存放对象的，栈是用来执行程序的</strong>。<br>**共享性：**堆是线程共享的，<strong>栈是线程私有</strong>的。<br>**空间大小：**堆大小远远大于栈。</p><h2 id="队列和栈是什么？有什么区别？">队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的。<br><strong>队列</strong>允许<strong>先进先出检索元素</strong>，但也有例外的情况，Deque 接口<strong>允许从两端检索元素</strong>。<br><strong>栈</strong>和队列很相似，但它运行对元素进行<strong>后进先出进行检索</strong>。</p><h2 id="Java-中都有哪些引用类型？">Java 中都有哪些引用类型？</h2><p>**强引用：**发生 <em><code>gc</code> 的时候不会被回收</em>。<br><strong>软引用：<strong>有用但不是必须的对象，在发生</strong>内存溢出之前被回收</strong>。<br><strong>弱引用：<strong>有用但不是必须的对象，在</strong>下一次GC时被回收</strong>。<br>**虚引用(幽灵引用/幻影引用)：**无法通过虚引用获得对象，用 <code>PhantomReference</code> 实现虚引用，虚引用的用途是在 <strong>gc 时返回一个通知</strong>。</p><h2 id="JVM-调优的工具？">JVM 调优的工具？</h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 <code>jconsole</code> 和 <code>jvisualvm</code> 这两款视图监控工具。<br><strong><code>jconsole</code>：<strong>对 JVM 中的</strong>内存、线程和类等进行监控</strong>；<br>**<code>jvisualvm</code>：**JDK 自带的全能分析工具，可以分析：<strong>内存快照、线程快照、程序死锁、监控内存的变化、gc 变化</strong>等。</p><h2 id="常用的-JVM-调优的参数都有哪些？">常用的 JVM 调优的参数都有哪些？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g：初始化推大小为 2g；</span><br><span class="line">-Xmx2g：堆最大内存为 2g；</span><br><span class="line">-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</span><br><span class="line">-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</span><br><span class="line">–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+PrintGC：开启打印 gc 信息；</span><br><span class="line">-XX:+PrintGCDetails：打印 gc 详细信息。</span><br></pre></td></tr></table></figure><h2 id="内存溢出的情况？">内存溢出的情况？</h2><ul><li><strong><code>JVM Heap</code>（堆）溢出：</strong><code>java.lang.OutOfMemoryError: Java heap space</code><ul><li>JVM在启动的时候会自动设置 JVM Heap 的值， 可以利用JVM提供的<code>-Xmn -Xms -Xmx</code>等选项可进行设置。</li><li>Heap的大小是<code>Young Generation</code> 和<code>Tenured Generaion</code> 之和。</li><li>在JVM中如果98%的时间是用于GC，且可用的<code>Heap size</code> <strong>不足2%时</strong>将抛出此异常信息。</li></ul></li><li>**解决方法：**手动设置JVM Heap（堆）的大小。</li><li><strong><code>Permanent Generation space</code>（内存的永久保存区域）溢出：</strong> <code>java.lang.OutOfMemoryError: PermGen space</code><ul><li>这块内存主要是被 JVM 存放 Class 和 Meta 信息的，Class在被Load的时候被放入 PermGen space 区域，它和存放 Instance 的Heap区域不同，sun 的 GC 不会在主程序运行期对<code>PermGen space</code>进行清理，所以如果你的 APP 会载入很多 CLASS 的话，就很可能出现 PermGen space 溢出。<strong>一般发生在程序的启动阶段</strong>。</li></ul></li><li><strong>解决方法</strong>： 通过<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>设置永久代大小。</li><li><strong>栈溢出：</strong> <code>java.lang.StackOverflowError : Thread Stack space</code><ul><li>栈溢出了，JVM是采用栈式的虚拟机，这个和C和Pascal一样。<em>函数的调用过程都体现在堆栈和退栈上了。调用构造函数的 “层”太多以致于把栈区溢出了</em>。 一般栈区远远小于堆区，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间（这大约相当于在一个C函数内声明了256个int变量），那么栈区也不过是需要1MB的空间。</li><li><strong>通常栈的大小是1-2MB</strong>。通俗点讲就是单线程的程序所需内存太大了。 通常<strong>递归也不要递归的层次过多</strong>，很容易溢出。</li></ul></li><li><strong>解决方法：</strong><ul><li><strong>修改程序</strong>。</li><li>通过 <strong><code>-Xss: </code>来设置每个线程的Stack大小</strong>。</li></ul></li></ul><h1>类加载</h1><h2 id="类加载器？">类加载器？</h2><p><strong>类加载器：</strong><br>对于任意一个类，都需要<strong>由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性</strong>，每一个类加载器都有一个独立的类名称空间。类加载器根据指定<strong>全限定名称</strong>将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br><strong>类加载器分类：</strong></p><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：是虚拟机自身的一部分，用来<strong>加载<code>Java_HOME/lib/目录</code>中的，或者被<code> -Xbootclasspath</code> 参数所指定的路径中并且被虚拟机识别的类库</strong>；</li><li>扩展类加载器（<code>Extension ClassLoader</code>）：负责加载<code>&lt;java_home style=”box-sizing: border-box; outline: 0px !important;”&gt;libext目录</code>或<code>Java. ext.dirs</code><strong>系统变量指定的路径中的所有类库</strong>；</li><li>应用程序类加载器（<code>Application ClassLoader</code>）：负责<strong>加载用户类路径（<code>classpath</code>）上的指定类库</strong>，我们可以直接使用这个类加载器。一般情况，如果没有自定义类加载器默认就是用这个加载器。</li></ul><p><strong>双亲委派模型：</strong><br>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是<strong>先把这个请求委派给父类加载器去完成</strong>，每一层的类加载器都是如此，这样所有的<strong>加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求</strong>（它的搜索范围中没找到所需的类）时，<strong>子加载器才会尝试去加载类</strong>。</p><h2 id="类装载的执行过程？">类装载的执行过程？</h2><p>类装载分为以下 5 个步骤：</p><ul><li><strong>加载：<strong>根据查找路径</strong>找到相应的 class 文件然后导入</strong>；</li><li><strong>检查：<strong>检查加载的 class 文件的</strong>正确性</strong>；</li><li><strong>准备：<strong>给类中的</strong>静态变量分配内存空间</strong>；</li><li><strong>解析：<strong>虚拟机将</strong>常量池中的符号引用替换成直接引用</strong>的过程。<ul><li>符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li></ul></li><li><strong>初始化：<strong>对</strong>静态变量和静态代码块执行初始化工作</strong>。</li></ul><h1>垃圾回收</h1><h2 id="怎么判断对象是否可以被回收？">怎么判断对象是否可以被回收？</h2><p>一般有两种方法来判断：<br><strong>引用计数器：<strong>为每个对象创建一个引用计数，<strong>有对象引用时计数器 +1</strong>，引用被释放时计数 -1，当</strong>计数器为 0 时</strong>就可被回收。它有一个缺点不能解决循环引用问题；<br><strong>可达性分析：<strong>从 <code>GC Roots</code> 开始向下搜索，<strong>搜索所走过的路径</strong>称为<code>引用链</code>。当一个</strong>对象到 GC Roots 没有任何引用链相连时</strong>，则证明此对象是可以被回收的。</p><h2 id="JVM-有哪些垃圾回收算法？">JVM 有哪些垃圾回收算法？</h2><p><strong>标记-清除算法：<strong>标记无用对象，然后进行清除回收。<strong>缺点：<strong>效率不高，<strong>无法清除垃圾碎片</strong>。<br><strong>标记-整理算法：<strong>标记无用对象，让所有</strong>存活的对象都向一端移动</strong>，然后直接</strong>清除端边界以外的内存</strong>。<br><strong>复制算法：<strong>按照容量划分两个大小相等的内存区域，当一块用完的时候</strong>将活着的对象复制到另一块</strong>上，然后再把</strong>已使用的内存空间一次清理掉</strong>。*缺点：*内存使用率不高，只有原来的一半。<br><strong>分代算法：<strong>根</strong>据对象存活周期的不同将内存划分为几块</strong>，一般是新生代和老年代，<strong>新生代基本采用复制算法，老年代采用标记整理算法</strong>。</p><h2 id="JVM-有哪些垃圾回收器？">JVM 有哪些垃圾回收器？</h2><p><code>Serial</code>：最早的<strong>单线程串行</strong>垃圾回收器。<br><code>Serial Old</code>：Serial 垃圾回收器的老年版本，同样也是<strong>单线程</strong>的，可以作为 CMS 垃圾回收器的备选预案。<br><code>ParNew</code>：是 Serial 的<strong>多线程</strong>版本。<br><code>Parallel</code> ： <strong>多线程</strong>的， 使用<strong>复制的内存回收算法</strong>。但 Parallel 是<strong>吞吐量优先</strong>的收集器，可以牺牲等待时间换取系统的吞吐量。<br><code>Parallel Old</code>：是 Parallel 老生代版本，Parallel Old 使用<strong>标记-整理的内存回收算法</strong>。<br><code>CMS</code>：一种<strong>以获得最短停顿时间为目标</strong>的收集器，非常适用 B/S 系统。<br><code>G1</code>：一种<strong>兼顾吞吐量和停顿时间</strong>的 GC 实现，是 <strong>JDK 9 以后的默认 GC 选项</strong>。</p><h2 id="CMS-垃圾回收器？">CMS 垃圾回收器？</h2><p>CMS 是英文 <code>Concurrent Mark-Sweep</code> 的简称，是<strong>以牺牲吞吐量为代价来获得最短回收停顿时间</strong>的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上<code>“-XX:+UseConcMarkSweepGC”</code>来指定使用 CMS 垃圾回收器。<br>CMS 使用的是<strong>标记-清除的算法</strong>实现的，所以在 gc 的时候<strong>会产生大量的内存碎片</strong>，当剩余内存不能满足程序运行要求时，系统将会出现 <code>Concurrent Mode Failure</code>，<strong>临时 CMS 会采用 Serial Old 回收器进行垃圾清除</strong>，此时的性能将会被降低。</p><h2 id="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？">新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h2><p><strong>新生代回收器：</strong><code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code><br><strong>老年代回收器：</strong><code>Serial Old</code>、<code>Parallel Old</code>、<code>CMS</code><br><strong>整堆回收器：<strong>G1<br>新生代垃圾回收器一般采用的是</strong>复制</strong>算法，复制算法的优点是<strong>效率高</strong>，缺点是<strong>内存利用率低</strong>；<br>老年代回收器一般采用的是<strong>标记-整理</strong>的算法进行垃圾回收。</p><h2 id="分代垃圾回收器是怎么工作的？">分代垃圾回收器是怎么工作的？</h2><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。<br>新生代使用的是复制算法，新生代里有 3 个分区：<code>Eden</code>、<code>To Survivor</code>、<code>From Survivor</code>，它们的<strong>默认占比是 8:1:1</strong>。<br><strong>它的执行流程如下：</strong></p><ul><li>把 <code>Eden + From Survivor</code> 存活的对象放入 <code>To Survivor</code> 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor <strong>分区交换</strong>（From Survivor 变 To Survivor，To Survivor 变 From Survivor）</li><li>每次在 From Survivor 到 To Survivor <strong>移动时</strong>都存活的对象，<strong>年龄 +1</strong>，当<strong>年龄到达 15（默认配置是 15）时，升级为老生代</strong>。大对象也会直接进入老生代。</li><li>老生代空间占用到达某个值后就<strong>触发全局垃圾收回</strong>，一般使用<strong>标记整理</strong>执行算法。</li></ul><p>以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>]]></content>
    
    
    <summary type="html">本文简单记录一些关于JVM的问题。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="JVM" scheme="https://southernfish.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://southernfish.github.io/2025/06/20/database-redis/"/>
    <id>https://southernfish.github.io/2025/06/20/database-redis/</id>
    <published>2025-06-20T02:15:36.000Z</published>
    <updated>2025-06-21T08:05:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>Redis（Remote Dictionary Server ），即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</p><h2 id="Redis-是什么？都有哪些使用场景？">Redis 是什么？都有哪些使用场景？</h2><p>Redis 是一个使<strong>用 C 语言开发的高速缓存数据库</strong>。Redis 使用场景如下：</p><ul><li>记录帖子点赞数、点击数、评论数</li><li>缓存近期热帖</li><li>缓存文章详情信息</li><li>记录用户会话信息</li></ul><h2 id="Redis-有哪些功能？">Redis 有哪些功能？</h2><p>数据缓存功能、分布式锁的功能、支持数据持久化、支持事务、支持消息队列</p><h2 id="Redis-和-memcache-有什么区别？">Redis 和 memcache 有什么区别？</h2><ul><li><strong>存储方式不同：</strong><code>memcache</code> 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；<code>Redis</code> 有<strong>部份存在硬盘上，这样能保证数据的持久性</strong>。</li><li><strong>数据支持类型：<strong>memcache 对数据类型支持相对简单；Redis 有</strong>复杂的数据类型</strong>。</li><li>**使用底层模型不同：**它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，<strong>Redis 自己构建了 vm 机制</strong>，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>**value 值大小不同：Redis 最大可以达到 512mb；**memcache 只有 1mb。</li></ul><h2 id="Redis-为什么是单线程的？">Redis 为什么是单线程的？</h2><p>因为 <strong>cpu 不是 Redis 的瓶颈</strong>，Redis 的瓶颈<strong>最有可能是机器内存或者网络带宽</strong>。既然<strong>单线程容易实现</strong>，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>关于 <code>Redis</code> 的性能，官方网站也有，普通笔记本轻松处理<strong>每秒几十万的请求</strong>。<br>而且单线程并不代表就慢，<code>nginx</code> 和 <code>nodejs</code> 也都是高性能单线程的代表。</p><h2 id="Redis-支持的数据类型有哪些？">Redis 支持的数据类型有哪些？</h2><p><code>string</code>（字符串）、<code>list</code>（列表）、<code>hash</code>（字典）、<code>set</code>（集合）、<code>zset</code>（有序集合）。</p><h2 id="哨兵和集群机制？">哨兵和集群机制？</h2><p><code>Redis哨兵（Sentinel）</code>是一个高可用性解决方案。哨兵系统可以<strong>监测Redis主从服务器的健康状态，自动执行故障转移，选举新的主服务器，并通知应用程序新主服务器的地址</strong>。哨兵还负责通知管理员，发送警报，并执行自定义脚本响应各种事件。<br><code>Redis集群（Cluster）</code>提供了一个<strong>数据分区（sharding）和自动管理的环境，支持在多个节点间进行数据共享</strong>。它能够在<strong>节点间自动分配数据，并在节点故障时提供自动的故障转移功能</strong>。集群通过分片来提高数据库的可扩展性，并能在不中断服务的情况下，动态地添加或移除节点。</p><h2 id="jedis-和-Redisson-有哪些区别？">jedis 和 Redisson 有哪些区别？</h2><p><code>jedis</code>：提供了比较全面的 Redis 命令的支持。<br><code>Redisson</code>：实现了<strong>分布式和可扩展的 Java 数据结构</strong>，与 jedis 相比 Redisson 的<strong>功能相对简单，不支持排序、事务、管道、分区等 Redis 特性</strong>。</p><h2 id="怎么保证缓存和数据库数据的一致性？">怎么保证缓存和数据库数据的一致性？</h2><p><strong>合理设置缓存的过期时间</strong>。<br>新增、更改、删除数据库操作时<strong>同步更新 Redis</strong>，可以使<strong>用事务机制来保证数据的一致性</strong>。</p><h2 id="Redis-持久化有几种方式？">Redis 持久化有几种方式？</h2><p><code>Redis 的持久化</code>有两种策略：<br><code>RDB（Redis Database）</code>：指定的时间间隔能对你的数据进行快照存储。<br><code>AOF（Append Only File）</code>：每一个收到的写命令都<strong>通过write函数追加到文件中</strong>。</p><h2 id="Redis-支持的-Java-客户端都有哪些？">Redis 支持的 Java 客户端都有哪些？</h2><p>支持的 Java 客户端有 <code>Redisson</code>、<code>jedis</code>、<code>lettuce</code> 等。</p><h2 id="Redis-如何做内存优化？">Redis 如何做内存优化？</h2><p><strong>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储</strong>，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p><h2 id="Redis-常见的性能问题有哪些？该如何解决">Redis 常见的性能问题有哪些？该如何解决</h2><p><strong>主服务器写内存快照，会阻塞主线程的工作</strong>，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以<strong>主服务器最好不要写内存快照</strong>。<br><code>Redis 主从复制</code>的性能问题，为了主从复制的速度和连接的稳定性，<strong>主从库最好在同一个局域网内</strong>。</p><h2 id="Redis-淘汰策略有哪些？">Redis 淘汰策略有哪些？</h2><p><code>volatile-lru</code>：从已<strong>设置过期时间的数据集</strong>（<code>server.db[i].expires</code>）中挑选<strong>最近最少使用的数据</strong>淘汰。<br><code>volatile-ttl</code>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选<strong>将要过期的数据</strong>淘汰。<br><code>volatile-random</code>：从已设置过期时间的数据集（<code>server db[i].expires</code>）中<strong>任意选择数据</strong>淘汰。<br><code>allkeys-lru</code>：从<strong>数据集</strong>（<code>server.db[i].dict</code>）中挑选<strong>最近最少使用的数据</strong>淘汰。<br><code>allkeys-random</code>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。<br><code>no-enviction</code>（驱逐）：<strong>禁止驱逐数据</strong>。</p><h1>Redis的缓存穿透、缓存击穿、缓存雪崩</h1><h2 id="缓存穿透">缓存穿透</h2><p><strong>缓存穿透：缓存和数据库中都没有的数据，可用户仍源源不断的发起请求</strong>，导致每次请求都到数据库，从而压垮数据库<br><strong>解决办法</strong></p><ul><li><strong>业务层校验</strong><ul><li>用户发过来的请求，<strong>根据请求参数进行校验</strong>，对于明显错误的参数，直接拦截返回。</li><li>如请求参数为主键自增id，那么对于请求小于0的id参数，可以直接返回错误请求。</li></ul></li><li><strong>不存在数据设置短过期时间</strong><ul><li>对于某个查询为空的数据，可以将这个空结果进行<code>Redis</code>缓存，但设置很短的过期时间，如30s，可以根据实际业务设定。</li></ul></li><li><strong>布隆过滤器</strong><ul><li>布隆过滤器是<strong>一种数据结构，利用极小的内存，可以判断大量的数据</strong>“一定不存在或者可能存在”。</li><li>对于缓存击穿，我们可以将查询的数据条件都哈希到一个足够大的布隆过滤器中，用户发送的<strong>请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了</strong>，从而避免下一步对数据库的压力。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620114220915.png" alt="image-20250620114220915"></p><h2 id="缓存击穿">缓存击穿</h2><p><strong>缓存击穿：Redis中一个<code>热点key</code>在失效的同时，大量的请求过来</strong>，从而会全部到达数据库，压垮数据库。<br><strong>解决办法</strong></p><ul><li><strong>设置热点数据永不过期</strong><ul><li>对于某个需要频繁获取的信息，缓存在Redis中，并设置其永不过期。</li><li>当然这种方式比较粗暴，对于某些业务场景是不适合的。</li></ul></li><li><strong>定时更新</strong><ul><li>比如这个热点数据的过期时间是1h，那么每到59minutes时，</li><li>通过定时任务去更新这个热点key，并重新设置其过期时间。</li></ul></li><li><strong>互斥锁（常用</strong>）<ul><li>在<code>Redis</code>中根据key获得value为空时先锁上，再从数据库加载，加载完毕，释放锁。</li><li>若其他线程也在请求该key时，获取锁失败，则睡眠一段时间（如100ms）后重试。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620115506995.png" alt="image-20250620115506995"></p><h2 id="缓存雪崩">缓存雪崩</h2><p><strong>缓存雪崩：Redis中缓存的数据大面积同时失效，或者Redis宕机</strong>，从而会导致大量请求直接到数据库，压垮数据库。<br><strong>解决办法</strong></p><ul><li><strong>设置有效期均匀分布</strong><ul><li>避免缓存设置相近的有效期，我们可以在设置有效期时增加随机值；</li><li>或者统一规划有效期，使得过期时间均匀分布。</li></ul></li><li><strong>数据预热</strong><ul><li>对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。</li></ul></li><li><strong>保证Redis服务高可用</strong><ul><li>为防止Redis集群单节点故障，可以通过哨兵模式和集群模式实现高可用。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620115530134.png" alt="image-20250620115530134"></p><h1>分布式锁</h1><h2 id="分布式锁？">分布式锁？</h2><p><strong>分布式锁</strong></p><ul><li>控制分布式系统<strong>不同进程共同访问共享资源</strong>的一种锁的实现。</li><li>如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往<strong>需要互斥来防止彼此干扰，以保证一致性</strong>。</li></ul><p><strong>特征</strong></p><ul><li><code>互斥性</code>: 任意时刻，只有一个客户端能持有锁。</li><li><code>锁超时释放</code>：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。</li><li><code>可重入性</code>:一个线程如果获取了锁之后,可以再次对其请求加锁。</li><li><code>高性能和高可用</code>：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。</li><li><code>安全性</code>：锁只能被持有的客户端删除，不能被其他客户端删除。</li></ul><p><strong>Redis分布式锁</strong></p><ul><li>其实就是在系统里面<strong>占一个“坑”，其他程序也要占“坑”时，占用成功了就可继续执行，失败了只能放弃或稍后重试</strong>。</li></ul><h2 id="Redis-分布式锁有什么缺陷？">Redis 分布式锁有什么缺陷？</h2><p>Redis 分布式锁不能解决超时的问题，分布式锁<strong>有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题</strong>。</p><h2 id="Redis分布式锁实现">Redis分布式锁实现</h2><h3 id="方案一：SETNX-EXPIRE">方案一：SETNX + EXPIRE</h3><p><strong>先用<code>setnx</code>来抢锁，抢到之后，再用<code>expire</code>给锁设置一个过期时间，防止锁忘记了释放</strong>。<br>SETNX 是<code>SET IF NOT EXISTS</code>的简写。命令格式是<code>SETNX key value</code>，若 key不存在，则SETNX成功返回1，若这个key已经存在，则返回0。<br>该方案中，setnx和expire两个命令分开了，<strong>不是原子操作</strong>。若执行完setnx加锁，正要执行expire设置过期时间时，进程crash或要重启维护了，那么这个锁就“长生不老”了，<strong>别的线程永远获取不到锁</strong>。<br>假设某电商网站的<strong>某商品做秒杀活动</strong>，key可以设置为<code>key_resource_id,value</code>设置任意值，<em>伪代码如下</em>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(jedis.setnx(key_resource_id, lock_value) == 1)&#123; // 加锁</span><br><span class="line">  expire(key_resource_id，100);// 设置过期时间</span><br><span class="line">  try &#123;</span><br><span class="line">    do something // 业务请求</span><br><span class="line">  &#125; catch()&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125; finally&#123;</span><br><span class="line">    jedis.del(key_resource_id); // 释放锁</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二：SETNX-value值是-系统时间-过期时间">方案二：SETNX + value值是(系统时间+过期时间)</h3><p>为了<em>解决发生异常锁得不到释放的场景</em>，<strong>把过期时间放到<code>setnx</code>的<code>value</code>值里面</strong>。若加锁失败，再拿出value值校验一下即可</p><p>但这个方案有<strong>缺点</strong>：<br>过期时间是客户端自己生成的（<code>System.currentTimeMillis()</code>是当前系统的时间），要求分布式环境下，每个<strong>客户端的时间必须同步</strong>。<br>若锁过期的时候，并发多个客户端同时请求过来，都执行<code>jedis.getSet()</code>，最终只能有一个客户端加锁成功，但该客户端锁的过期时间，可能被别的客户端覆盖。<br><strong>该锁没有保存持有者的唯一标识，可能被别的客户端释放/解锁。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">long expires = System.currentTimeMillis() + expireTime;// 系统时间+设置的过期时间</span><br><span class="line">String expiresStr = String.value0f(expires);</span><br><span class="line">// 如果当前锁不存在，返回加锁成功</span><br><span class="line">if(jedis.setnx(key resource id,expiresStr) == 1)&#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">// 如果锁已经存在，获取锁的过期时间</span><br><span class="line">String currentValueStr = jedis.get(key resource id);</span><br><span class="line">// 如果杂取到的过期时间，小于系统当前时间，表示已经过期</span><br><span class="line">if(currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis())&#123;</span><br><span class="line">  // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span><br><span class="line">  String oldValueStr =jedis.getSet(key resource id, expiresStr);</span><br><span class="line">  if(oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr))&#123;</span><br><span class="line">    // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 其他情况，均返回加锁失败</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure><h3 id="方案三：使用Lua脚本-包含SETNX-EXPIRE两条指令">方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)</h3><p>可以使用Lua脚本来保证原子性（包含<code>setnx</code>和<code>expire</code>两条指令）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// lua脚本如下：</span><br><span class="line">if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then</span><br><span class="line">   redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2])</span><br><span class="line">else</span><br><span class="line">   return 0</span><br><span class="line">end;</span><br><span class="line">// 加锁代码如下：</span><br><span class="line">String lua_scripts = &quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot; +</span><br><span class="line">        &quot; redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;;   </span><br><span class="line">Object result = jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));</span><br><span class="line">//判断是否成功</span><br><span class="line">return result.equals(1L);</span><br></pre></td></tr></table></figure><h3 id="方案四：SET的扩展命令（SET-EX-PX-NX）">方案四：SET的扩展命令（SET EX PX NX）</h3><p>巧用Redis的SET指令扩展参数，它也是原子性的！伪代码如下：<br><code>SET key value[EX seconds][PX milliseconds][NX|XX]</code></p><ul><li><code>NX</code>：表示key不存在时，才能set成功，也保证只有第一个客户端请求才能获得锁。其他客户端请求只能等其释放锁，才能获取。</li><li><code>EX seconds</code>：设定key的过期时间，时间单位是秒。</li><li><code>PX milliseconds</code>：设定key的过期时间，单位为毫秒</li><li><code>XX</code>：仅当key存在时设置值</li></ul><p>这个方案可能<strong>存在问题</strong>：</p><ul><li><strong>锁过期释放了，业务还没执行完</strong>。<ul><li>假设线程a获取锁成功，一直在执行临界区的代码。100s过去后，它还没执行完。但锁已过期，此时线程b请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么临界区的业务代码都不是严格串行执行的了。</li></ul></li><li><strong>锁被别的线程误删</strong><ul><li>假设线程a执行完后，去释放锁。但它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但线程b临界区业务代码可能都还没执行完。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(jedis.set(key_resource id, lock_value, &quot;NX&quot;,&quot;EX&quot;，100s) == 1)&#123; // 加锁</span><br><span class="line">  try &#123;</span><br><span class="line">    // do something 业务处理</span><br><span class="line">  &#125; catch()&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    jedis.del(key_resource_id); // 释放锁</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案五：SET-EX-PX-NX-校验唯一随机值，再删除">方案五：SET EX PX NX  + 校验唯一随机值，再删除</h3><p>既然锁可能被别的线程误删，那我们<strong>给value值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下</strong>，伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(jedis.set(key _resource id, uni_request id, &quot;NX&quot;,&quot;EX&quot;，100s) == 1)&#123; // 加锁</span><br><span class="line">  try &#123;</span><br><span class="line">    // do something 业务处理</span><br><span class="line">  &#125; catch()&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    // 判断是不是当前线程加的锁, 是才释放</span><br><span class="line">    if(uni request id.equals(jedis.get(key resource id)))&#123;</span><br><span class="line">      jedis.del(lockKey);//释放锁</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断是不是当前线程加的锁 和 释放锁 不是原子操作</strong>。调用<code>jedis.del()</code>释放锁时，可能这把锁已经不属于当前客户端，会解除他人加的锁。<br>为了更严谨，用lua脚本代替。lua脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then</span><br><span class="line">  return redis.call(&#x27;del&#x27;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">  return 0</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h3 id="方案六：Redisson框架">方案六：Redisson框架</h3><p><code>Redisson</code>框架下，只要线程加锁成功，就会启动一个<code>watch dog</code>看门狗（一个后台线程），每隔10秒检查一下，若线程1还持有锁，就会不断延长锁key的生存时间。因此，<code>Redisson</code><strong>解决了<em>锁过期释放，业务没执行完</em>问题</strong>。Redisson底层原理如图所示：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620122023110.png" alt="image-20250620122023110"></p><h3 id="方案七：多机实现的分布式锁Redlock-Redisson">方案七：多机实现的分布式锁Redlock+Redisson</h3><p>前六种方案都是基于单机版。但Redis一般都是集群部署的（如图）：</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250620122038873.png" alt="image-20250620122038873"></p><p>若线程一在Redis的master节点上拿到了锁，但加锁的key还没同步到slave节点。恰好这时master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁，但线程一也已经拿到锁了，锁的安全性就没了。</p><h3 id="Redlock">Redlock</h3><p><strong>Redlock核心思想：</strong><br>搞多个<code>Redis master</code>部署，以保证它们不会同时宕掉。并且<strong>这些master节点是完全相互独立的，相互之间不存在数据同步</strong>。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。<br><strong>RedLock的简化实现步骤：</strong></p><ul><li>按顺序向<code>N</code>（N=5）个master节点请求加锁</li><li>根据设置的超时时间来判断，是不是要跳过该master节点。</li><li>如果<strong>大于等于<code>N/2+1</code></strong>（5/2+1=3）个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功。</li><li>如果获取锁失败，解锁！</li></ul><p><strong>RedLock的实现步骤：</strong></p><ul><li><p>获取当前时间，以毫秒为单位。</p></li><li><p>按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，且超时时间要小于锁的失效时间。</p><ul><li>（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间，就假设超时时间是50ms）。若超时则跳过该master节点，尽快尝试下一个master节点。</li></ul></li><li><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如图，10s&gt; 30ms+40ms+50ms+40ms+50ms）</p><ul><li><p>如果<strong>获取到了锁</strong>，key的真正有效时间就变了，需要减去获取锁所使用的时间。</p></li><li><p>如果<strong>获取锁失败</strong>（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也<strong>需要解锁</strong>，以防止有些漏网之鱼）。</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/1750393665152.png" alt="1750393665152"></p>]]></content>
    
    
    <summary type="html">‌Redis（Remote Dictionary Server ），即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</summary>
    
    
    
    <category term="中间件" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="Database" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Database/"/>
    
    
    <category term="Redis" scheme="https://southernfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Kafka and Zookeeper</title>
    <link href="https://southernfish.github.io/2025/06/19/kafka-zookeeper/"/>
    <id>https://southernfish.github.io/2025/06/19/kafka-zookeeper/</id>
    <published>2025-06-19T11:55:36.000Z</published>
    <updated>2025-06-21T08:05:35.151Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka 和 ZooKeeper 在分布式系统中扮演着不同的角色，并且它们之间有着紧密的合作关系。</p><h1>Kafka</h1><h1>Kafka是什么？</h1><p>‌<strong>Kafka</strong>‌是一个<strong>分布式流处理平台</strong>，最初由<code>LinkedIn</code>开发，后成为<code>Apache</code>开源项目。<code>Kafka</code>主要用于<strong>构建实时数据管道和流应用</strong>，具有高吞吐量、低延迟和可扩展性等特点‌。Kafka的<strong>核心功能</strong>包括：</p><ul><li>‌<strong>消息发布与订阅</strong>‌：Kafka允许应用程序发布和订阅消息流。</li><li>‌<strong>分布式日志</strong>‌：Kafka将数据持久化到磁盘，支持高吞吐量的数据收集。</li><li>‌<strong>流处理</strong>‌：支持复杂的流处理操作，如转换、过滤和聚合</li></ul><h1>kafka 可以脱离 zookeeper 单独使用吗？为什么？</h1><p><code>kafka</code> 不能脱离 <code>zookeeper</code> 单独使用，因为 <strong>kafka 使用 zookeeper 管理和协调 kafka 的节点服务器</strong>。</p><h2 id="kafka-有几种数据保留的策略？">kafka 有几种数据保留的策略？</h2><p>kafka 有<strong>两种</strong>数据保存策略：<strong>按照过期时间保留</strong>、<strong>按照存储的消息大小保留</strong>。</p><h2 id="kafka-设置了-7-天和-10G-清除数据，第五天消息达-10G，kafka-如何处理？">kafka 设置了 7 天和 10G 清除数据，第五天消息达 10G，kafka 如何处理？</h2><p>这个时候 kafka 会执行数据清除工作，<strong>时间和大小不论那个满足条件，都会清空数据</strong>。</p><h2 id="什么情况会导致-kafka-运行变慢？">什么情况会导致 kafka 运行变慢？</h2><p>cpu 性能瓶颈<br>磁盘读写瓶颈<br>网络瓶颈</p><h2 id="使用-kafka-集群需要注意什么？">使用 kafka 集群需要注意什么？</h2><p>集群的数量不是越多越好，<strong>最好不要超过 7 个</strong>，因为<strong>节点越多</strong>，消息复制需要的时间就越长，<strong>整个群组的吞吐量就越低</strong>。<br>集群数量最好是<strong>单数</strong>，因为<strong>超过一半故障集群就不能用了，设置为单数容错率更高</strong>。</p><h1>Zookeeper</h1><h2 id="zookeeper-是什么？">zookeeper 是什么？</h2><p>‌<strong>ZooKeeper</strong>‌是一个开源的<strong>分布式协调服务</strong>，由<code>Apache</code>开发。它主要用于<strong>解决分布式系统中的一致性问题</strong>，如配置管理、节点选举和分布式锁等‌。<code>ZooKeeper</code>的<strong>主要功能</strong>包括：</p><ul><li>‌<strong>配置管理</strong>‌：集中管理分布式系统中的配置信息。</li><li>‌<strong>命名服务</strong>‌：提供唯一的命名服务，帮助分布式系统中的服务发现，客户端能根据指定名字获取资源或服务的地址，提供者等信息。</li><li>‌<strong>分布式锁</strong>‌：实现分布式环境中的锁机制。<code>zookeeper</code> 提供两种锁：<strong>独占锁、共享锁</strong>。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可有多个线程同时读同一个资源，若要使用写锁也只能有一个线程使用。</li><li>‌<strong>集群管理</strong>‌：管理集群中的节点，<strong>确保数据的一致性和系统的可靠性</strong>。监控节点存活状态、运行请求等。</li><li><strong>主节点选举：<strong>主节点挂掉了之后可以从备用的节点开始</strong>新一轮选主</strong>，使用 zookeeper 可以协助完成这个过程。</li></ul><h2 id="zookeeper-有几种部署模式？-三种">zookeeper 有几种部署模式？(三种)</h2><p>**单机部署：**一台集群上运行；<br>**集群部署：**多台集群运行；<br>**伪集群部署：**一台集群启动多个 zookeeper 实例运行。</p><h2 id="zookeeper-怎么保证主从节点的状态同步？">zookeeper 怎么保证主从节点的状态同步？</h2><p><code>zookeeper</code> 的核心是<strong>原子广播</strong>，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。<code>zab 协议</code>有两种模式，分别是<strong>恢复模式（选主）和广播模式（同步）</strong>。<em>当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了</em>。状态同步保证了 <code>leader</code> 和 <code>server</code> 具有相同的系统状态。</p><h2 id="集群中为什么要有主节点？">集群中为什么要有主节点？</h2><p>在分布式环境中，<strong>有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果</strong>，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h2 id="集群中有-3-台服务器，一个节点宕机了，zookeeper-还可以用吗？">集群中有 3 台服务器，一个节点宕机了，zookeeper 还可以用吗？</h2><p>可以继续使用，<strong>单数服务器只要没超过一半的服务器宕机就可以继续使用</strong>。</p><h2 id="zookeeper-的通知机制？">zookeeper 的通知机制？</h2><p><strong>客户端会对某个 <code>znode</code> 建立一个 <code>watcher</code> 事件</strong>，当该 <code>znode</code> 发生变化时，这些客户端会<strong>收到 zookeeper 的通知</strong>，然后客户端可以<strong>根据 znode 变化来做出业务上的改变</strong>。</p><h2 id="Kafka与ZooKeeper的关系">Kafka与ZooKeeper的关系</h2><p><code>Kafka</code>依赖<code> ZooKeeper</code>来管理集群元数据、控制器选举和消费者组协调等任务。ZooKeeper 为 Kafka 提供了选主（<code>leader election</code>）、集群成员管理等核心功能，<strong>确保Kafka能够在多个节点之间进行有效的通信和管理‌</strong>。随着 Kafka 的发展，其对 ZooKeeper的依赖也带来了一些问题：</p><ul><li>‌<strong>复杂性增加</strong>‌：ZooKeeper 是一个独立的外部组件，增加了运维的复杂度。</li><li>‌<strong>性能瓶颈</strong>‌：在高负载情况下，ZooKeeper 可能成为系统的瓶颈，限制Kafka的扩展能力。</li><li>‌<strong>一致性问题</strong>‌：Kafka内部的一致性模型与 ZooKeeper 的一致性模型有所不同，可能导致状态不一致，影响系统的稳定性和消息传递的可靠性‌。</li></ul>]]></content>
    
    
    <summary type="html">‌Kafka 和 ZooKeeper 在分布式系统中扮演着不同的角色，并且它们之间有着紧密的合作关`</summary>
    
    
    
    <category term="中间件" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="分布式" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Kafka" scheme="https://southernfish.github.io/tags/Kafka/"/>
    
    <category term="Zookeeper" scheme="https://southernfish.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://southernfish.github.io/2025/06/19/database-sql/"/>
    <id>https://southernfish.github.io/2025/06/19/database-sql/</id>
    <published>2025-06-19T11:55:36.000Z</published>
    <updated>2025-06-21T08:05:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。</p><h2 id="数据库的三范式是什么？">数据库的三范式是什么？</h2><p><strong>第一范式：<strong>强调的是</strong>列的原子性</strong>，即数据库表的每一列都是不可分割的原子数据项。<br><strong>第二范式：<strong>要求实体的属性</strong>完全依赖于主关键字</strong>。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br><strong>第三范式：<strong>任何</strong>非主属性不依赖于其它非主属性</strong>。</p><h2 id="一自增表共-7-条数据，删了最后-2-条，重启-MySQL后插入一条，此时-id-？">一自增表共 7 条数据，删了最后 2 条，重启 MySQL后插入一条，此时 id ？</h2><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p><h2 id="char-和-varchar-的区别是什么？">char 和 varchar 的区别是什么？</h2><p>**char(n) ：**固定长度类型，如 char(10)，当输入”abc”三个字符时，它们占的空间还是 10 个字节，其他 7 个是空字节。</p><ul><li>**优点：**效率高；</li><li>**缺点：**占用空间；</li><li>**适用场景：**存储密码的 md5 值，固定长度的，使用 char 非常合适。</li></ul><p>**varchar(n) ：**可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p><ul><li>从<strong>空间</strong>上考虑 varcahr 比较合适；</li><li>从<strong>效率</strong>上考虑 char 比较合适，二者使用需要权衡。</li></ul><h2 id="如何获取当前数据库版本？">如何获取当前数据库版本？</h2><p>使用 select version() 获取当前 MySQL 数据库版本。</p><h2 id="float-和-double-的区别是什么？">float 和 double 的区别是什么？</h2><p><strong><code>float</code></strong> 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br><strong><code>double</code></strong> 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p><h2 id="MySQL-的内连接、左连接、右连接有什么区别？">MySQL 的内连接、左连接、右连接有什么区别？</h2><p>内连接：<code>inner join</code>；左连接：<code>left join</code>；右连接：<code>right join</code>。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h2 id="怎么验证-MySQL-的索引是否满足需求？">怎么验证 MySQL 的索引是否满足需求？</h2><p>使用 <code>explain</code> 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br><strong>explain 语法：</strong><code>explain select * from table where type=1</code>。</p><h2 id="数据库的事务隔离？">数据库的事务隔离？</h2><p>MySQL 的事务隔离是在 <code>MySQL. ini</code> 配置文件里添加的，在文件的最后添加：<br>transaction-isolation = REPEATABLE-READ<br><strong>可用的配置值：</strong><code>READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE</code>。</p><ul><li><code>READ-UNCOMMITTED</code>：<strong>读未提交</strong>，事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li><li><code>READ-COMMITTED</code>：<strong>读提交</strong>，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li><li><code>REPEATABLE-READ</code>：<strong>可重复读</strong>，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li><li><code>SERIALIZABLE</code>：<strong>序列化</strong>，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p>**脏读：**表示一个事务能够读取另一个事务中还未提交的数据。<br>**不可重复读：**是指在一个事务内，多次读同一数据。<br><strong>幻读：<strong>指同一个事务内多次查询返回的结果集不一样。发生</strong>幻读的原因</strong>是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所以数据行的记录就变多或者变少了。</p><ul><li><em>MySQL默认使用的是“可重复读”隔离级别，SQL标准的默认隔离级别是“读提交”</em>。</li><li>MySQL在“可重复读”级别下通过<strong>多版本并发控制（MVCC）机制避免幻读</strong>的问题。</li></ul><h2 id="MySQL-常用的引擎？">MySQL 常用的引擎？</h2><p><code>InnoDB 引擎</code>：mysql 5.1 后默认的数据库引擎，提供了对数据库 <strong>acid 事务的支持</strong>，并且还提供了<strong>行级锁和外键的约束</strong>，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在<strong>内存中建立缓冲池，用于缓冲数据和索引</strong>。但该引擎<em>不支持全文搜索，同时启动也比较慢，它不会保存表的行数</em>，所以当进行 <code>select count(*) from table</code> 指令时，需要进行扫描全表。由于锁的粒度小，写操作不会锁定全表,所以<strong>在并发度较高的场景下使用会提升效率</strong>。<br><code>MyIASM 引擎</code>：<strong>不提供事务的支持，也不支持行级锁和外键</strong>。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是<strong>保存了表的行数</strong>，于是当进行 <code>select count(*) from table</code> 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><h2 id="MySQL-的行锁和表锁？">MySQL 的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。<br>**表级锁：**开销小，加锁快，不会出现死锁。锁粒度大，发生锁冲突的概率最高，并发量最低。<br>**行级锁：**开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高。</p><h2 id="乐观锁和悲观锁？">乐观锁和悲观锁？</h2><p>**乐观锁：**每次拿数据时都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br><strong>悲观锁：<strong>每次拿数据时都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。采用数据库自身的<code>for update</code>能力，对数据库表或者行增加锁<br><em>数据库的乐观锁需要自己实现</em>，在表里面</strong>添加一个 <code>version</code> 字段，每次修改成功值加 1</strong>，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><h2 id="MySQL-问题排查都有哪些手段？">MySQL 问题排查都有哪些手段？</h2><p>使用 <code>show processlist</code> 命令查看当前所有连接信息。<br>使用 <code>explain</code> 命令查询 SQL 语句执行计划。<br>开启<strong>慢查询日志</strong>，查看慢查询的 SQL。</p><h2 id="如何做-SQL-优化？">如何做 SQL 优化？</h2><p><strong>一、避免不走索引的场景</strong></p><ul><li>尽量<strong>避免在字段开头模糊查询</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量<strong>避免使用<code>not in</code></strong>，会导致引擎走全表扫描。</li><li>尽量<strong>避免使用 or</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量<strong>避免进行null值的判断</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>尽量<strong>避免在where条件中等号的左侧进行表达式、函数操作</strong>，会导致数据库引擎放弃索引进行全表扫描。</li><li>数据量大时，<strong>避免使用<code>where 1 = 1</code></strong>。通常为方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引做全表扫描。</li><li>查询条件<strong>不能用 &lt;&gt; 或者 !=</strong></li><li>隐式类型转换造成不使用索引</li><li><strong><code>order by</code> 条件要与<code>where</code>中条件一致</strong>，否则order by不会利用索引进行排序</li><li><strong>正确使用<code>hint</code>优化语句</strong></li></ul><p><strong>二、SELECT语句其他优化</strong></p><ul><li><strong>避免出现select</strong></li><li><strong>避免出现不确定结果的函数</strong></li><li>多表关联查询时，<strong>小表在前，大表在后</strong>。</li><li>使用<strong>表的别名</strong></li><li>尽可能<strong>用<code>where</code>子句替换<code>HAVING</code>子句中的条件</strong></li></ul><h2 id="MySQL数据中有很多换行符和回车符怎么办？">MySQL数据中有很多换行符和回车符怎么办？</h2><p>**换行符：**CHAR(10) = “\n”<br><strong>回车符：</strong> CHAR(13) = “\r”<br>在MySQL中，回车符、换行符都属于char类型，放到varchar中时，在navcat等插件上是不显示的，需要在mysql终端和navcat对比才能看出来。</p><p><strong>如何去掉换行符、回车符</strong>。如果条件允许，建议<strong>直接通过语句清除掉换行符和回车符</strong>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 去除&quot;hero title&quot;列中所有换行符 (通过以下两种方式都可以)</span><br><span class="line">update &#x27;LOL&#x27; set hero_title = REPLACE(hero_title, &#x27;\n&#x27;, &#x27;&#x27;);</span><br><span class="line">update &#x27;LOL&#x27; set hero_title = REPLACE(hero_title, char(10), &#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">// 去除&quot;hero title&quot;列中所有回车符</span><br><span class="line">update &#x27;LOL&#x27; set hero_title = REPLACE(hero_title, &#x27;\r&#x27;, &#x27;&#x27;);</span><br><span class="line">update &#x27;LOL&#x27; set hero_title = REPLACE(hero_title, char(13),&#x27;&#x27;);</span><br></pre></td></tr></table></figure><p><strong>如何忽略&quot;换行符、回车符&quot;进行SELECT查询</strong>。条件不允许，不能动库里的数据。可以通过修改SQL来<strong>过滤掉换行符、回车符，但一定程度上会影响查询效率</strong>，而且要改很多代码，你懂得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 忽略掉换行符查询</span><br><span class="line">SELECT * from &#x27;LOL&#x27; where REPLACE(hero_title, char(10), &#x27;&#x27;) = &#x27;换行符换行符换行符’; </span><br><span class="line">// 忽略掉回车符查询</span><br><span class="line">SELECT * from &#x27;LOL&#x27; where REPLACE(hero_title, char(13), &#x27;&#x27;) =&#x27;回车符回车符回车符’;</span><br><span class="line">// 忽略掉换行符 &amp; 回车符查询</span><br><span class="line">SELECT * from &#x27;LOL&#x27; where REPLACE(REPLACE(hero_title, char(13), &#x27;&#x27;), char(18),&#x27;&#x27;) = &#x27;回车符回车符回车符’;</span><br></pre></td></tr></table></figure><h2 id="int-20-中20的涵义">int(20)中20的涵义</h2><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；<br>不影响内部存储，只是<strong>影响带 zerofill 定义的 int 时，前面补多少个 0</strong>，易于报表展示</p><h2 id="SQL语句主要分为哪几类">SQL语句主要分为哪几类</h2><ul><li>数据定义语言DDL（<code>Data Definition Language</code>）CREATE，DROP，ALTER<ul><li>对<strong>逻辑结构</strong>等有操作的，其中包括表结构，视图和索引。</li></ul></li><li>数据查询语言DQL（<code>Data Query Language</code>）SELEC<ul><li>即<strong>查询</strong>操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</li></ul></li><li>数据操纵语言DML（<code>Data Manipulation Language</code>）INSERT，UPDATE，DELETE<ul><li>对<strong>数据</strong>进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。</li></ul></li><li>数据控制功能DCL（<code>Data Control Languag</code>e）GRANT，REVOKE，COMMIT，ROLLBACK<ul><li>对<strong>数据库安全性完整性</strong>等有操作的，可以简单的理解为<strong>权限控制</strong>等。</li></ul></li></ul><h2 id="SQL-约束有哪几种？">SQL 约束有哪几种？</h2><p><code>NOT NULL</code>：用于控制字段的内容一定不能为空（NULL）。<br><code>UNIQUE</code>：控件<strong>字段内容不能重复</strong>，一个表<strong>允许有多个 Unique 约束</strong>。<br><code>PRIMARY KEY</code>：控件<strong>字段内容不能重复</strong>，但它在一个表只允许出现一个。<br><code>FOREIGN KEY</code>：用于<strong>预防破坏表之间连接的动作，也能防止非法数据插入外键列</strong>，因为它必须是它指向表中的值之一。<br><code>CHECK</code>：用于<strong>控制字段的值范围</strong>。</p><h2 id="drop、delete与truncate的区别">drop、delete与truncate的区别</h2><p>在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p><table><thead><tr><th></th><th><strong>delete</strong></th><th><strong>truncate</strong></th><th><strong>drop</strong></th></tr></thead><tbody><tr><td>类型</td><td>DML</td><td>DDL</td><td>DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行，不释放空间，不重置自增列</td><td>表结构还在，删除表方全部数据，重置自增列，释放空间</td><td>删除表结构、数据、索引、约束等全部内容，释放空间，表不复存在</td></tr></tbody></table><h1>ACID</h1><h2 id="ACID-是什么？">ACID 是什么？</h2><p><strong><code>Atomicity</code>（原子性）：<strong>一个事务（<code>transaction</code>）中的所有操作，<strong>或全部完成，或全部不完成</strong>，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（<code>Rollback</code>）到事务开始前的状态，就像这个事务从来没有执行过一样。即</strong>事务不可分割、不可约简</strong>。<br><strong><code>Consistency</code>（一致性）：<strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示</strong>写入的资料必须完全符合所有的预设约束、触发器、级联回滚</strong>等。<br><strong><code>Isolation</code>（隔离性）：<strong>数据库</strong>允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</strong>。事务隔离分为不同级别，包括读未提交（<code>Read uncommitted</code>）、读提交（<code>read committed</code>）、可重复读（<code>repeatable read</code>）和串行化（<code>Serializable</code>）。<br>**<code>Durability</code>（持久性）：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</p><h2 id="ACID-原子性：MySQL通过使用日志文件来实现事务的原子性？">ACID-原子性：MySQL通过使用日志文件来实现事务的原子性？</h2><p><strong>日志刷盘</strong><br>当一个事务开始时，InnoDB会为该事务分配一个<strong>唯一事务ID</strong>，并开始<strong>记录重做日志和回滚日志</strong>。随着事务的执行，所有的数据修改都会<strong>先写入到重做日志缓冲区</strong>中，然后在适当时机，<strong>这些修改会被刷新到磁盘上的重做日志文件中</strong>。如果系统崩溃，重做日志将被用来重做事务，确保事务的修改被应用到数据库中。<br><strong>Redo Log</strong><br>事务执行过程中发生错误或系统故障时，如果数据修改已经写入重做日志缓冲区中，在适当的时机（系统恢复时），这些修改会被刷新到磁盘上的重做日志文件中。<br><strong>Undo Log</strong><br>在事务执行过程中发生错误或系统故障，且无法通过**<code>Redo Log</code>** 保证数据一致性和完整性，MySQL将<strong>利用日志来回滚事务中的所有操作</strong>，保证数据库的原子性不被破坏。</p><h2 id="ACID-一致性：MySQL通过几种机制来保证数据的一致性？">ACID-一致性：MySQL通过几种机制来保证数据的一致性？</h2><p><strong>约束（<code>Constraints</code>）：<strong>MySQL允许定义各种约束（如</strong>主键约束、外键约束、唯一约束</strong>等），这些约束直接作用于数据表上，确保数据的完整性和一致性。<br>**事务隔离级别（<code>Transaction Isolation Levels</code>）：**通过合理选择事务隔离级别，可以在并发环境下有效地维护数据的一致性。读未提交（<code>Read Uncommitted</code>）、读提交（<code>Read Committed</code>）、可重复读（<code>Repeatable Read</code>）、串行化（<code>Serializable</code>）<br><strong>锁定机制（<code>Locking Mechanisms</code>）：<strong>MySQL使用锁定机制来</strong>控制对数据的并发访问</strong>，包括*行级锁（<code>Row-Level Locks</code>）、表级锁（<code>Table Locks</code>）*等，以确保在并发事务中数据的一致性和完整性。<br><strong>原子性操作（<code>Atomic Operations</code>）：<strong>MySQL通过原子性操作确保事务中的所有操作</strong>要么全部成功，要么全部失败</strong>，从而保持数据的一致性。</p><h2 id="ACID-持久性：MySQL中保证数据持久性的技术？">ACID-持久性：MySQL中保证数据持久性的技术？</h2><ul><li>日志文件<ul><li><strong>重做日志（<code>Redo Log</code>）：<strong>InnoDB存储引擎使用重做日志来保证事务的持久性。事务提交时，事务所做的所有</strong>修改都会被记录到重做日志</strong>中。即使数据库发生崩溃，重做日志也可以在重启后被用来重放这些修改，确保数据的持久性。</li><li><strong>二进制日志（<code>Binary Log</code>）：<strong>MySQL服务器使用</strong>二进制日志记录所有修改数据库数据的操作</strong>，如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等。二进制日志不仅对数据恢复至关重要，也是复制和增量备份的基础。</li></ul></li><li>备份策略<ul><li>**全量备份：**定期对整个数据库进行完整备份，以确保数据的持久性和可恢复性。</li><li><strong>增量备份：仅备份自上次备份以来发生变化的数据</strong>。与全量备份结合使用，可以有效减少数据恢复时间和存储需求。</li><li><strong>点对点恢复（<code>Point-in-Time Recovery, PITR</code>）：<strong>使用二进制日志实现，可以</strong>将数据库恢复到特定时间点的状态</strong>，非常适合处理操作错误或数据损坏的情况。</li></ul></li></ul><h2 id="MySQL的binlog有有几种录入格式？分别有什么区别？">MySQL的binlog有有几种录入格式？分别有什么区别？</h2><p>有三种格式，statement，row和mixed。</p><ul><li><strong><code>statement</code>模式</strong>下，每一条会<strong>修改数据的sql都会记录在<code>binlog</code>中</strong>。不需要记录每一行的变化，<strong>减少了binlog日志量，节约了IO，提高性能</strong>。由于sql的执行是有上下文的，因此在<strong>保存的时候需要保存相关的信息</strong>，同时还有一些使用了函数之类的语句无法被记录复制。</li><li><strong><code>row</code>级别</strong>下，不记录sql语句上下文相关信息，仅<strong>保存哪条记录被修改。记录单元为每一行的改动</strong>，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件<strong>保存的信息太多，日志量太大</strong>。</li><li><strong><code>mixed</code></strong>，一种折中的方案，<strong>普通操作使用statement记录，当无法使用statement的时候使用row</strong>。</li></ul><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p><h1>索引</h1><h2 id="MySQL-索引是怎么实现的？">MySQL 索引是怎么实现的？</h2><p>索引是<strong>满足某种特定查找算法的数据结构</strong>，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 <strong><code>B+ 树</code><strong>实现的，</strong><code>B+ 树</code>的搜索效率，可到达二分法的性能</strong>，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h2 id="创建索引的原则有哪些？">创建索引的原则有哪些？</h2><ul><li><strong>最左前缀匹配原则</strong>，组合索引非常重要的原则，mysql会一直<strong>向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配</strong>，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li><strong>较频繁作为查询条件的字段</strong>才去创建索引</li><li>更新频繁字段不适合创建索引</li><li><strong>不能有效区分数据的列不适合做索引列</strong>(如性别，男女未知，最多也就三种，区分度实在太低)</li><li>尽量的<strong>扩展索引，不要新建索引</strong>。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li><li><strong>定义有外键的数据列</strong>一定要建立索引。</li><li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li><li>对于定义为text、image和bit的数据类型的列不要建立索引。</li></ul><h1>InnoDB</h1><h1>MyISAM索引与InnoDB索引的区别？</h1><p><strong><code>InnoDB</code>索引是聚簇索引</strong>，MyISAM索引是非聚簇索引。<br><code>InnoDB</code>的<strong>主键索引的叶子节点存储着行数据</strong>，因此主键索引非常高效。<br><strong><code>MyISAM</code>索引的叶子节点存储的是行数据地址</strong>，需要再寻址一次才能得到数据。<br><strong>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据</strong>，因此查询时做到覆盖索引会非常高效。</p><h2 id="mysql-innodb存储引擎的特点">mysql innodb存储引擎的特点</h2><p><strong>事务支持：<strong>InnoDB支持ACID事务属性。<br><strong>崩溃恢复</strong>：InnoDB会</strong>将数据写入到磁盘上的日志文件</strong>中，即使在系统崩溃的情况下，也能通过这些日志文件恢复数据。<br>**MVCC (多版本并发控制)：**InnoDB使用多版本并发控制，这允许更高的并发性。<br>**外键约束：**InnoDB支持外键约束，这对于维护数据库的引用完整性非常有用。<br><strong>行级锁定：<strong>与表级锁定相比，InnoDB</strong>支持行级锁定，提供了更高的并发性能</strong>。<br><strong>自适应哈希索引：<strong>InnoDB会</strong>自动为频繁访问的热点数据创建哈希索引，以提高查询速度</strong>。</p><h2 id="主键使用自增ID还是UUID？">主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。<br>在InnoDB存储引擎中，主键索引是作为<strong>聚簇索引</strong>存在的，主键索引的<code>B+树</code>叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，只需要不断向后排列即可，如果是*<code>UUID</code>，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降*。<br>总之，在数据量大一些的情况下，用自增主键性能会好一些。<br>主键是聚簇索引，若没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个<strong>隐式的主键</strong>。</p><h2 id="如何使用InnoDB？">如何使用InnoDB？</h2><p>在创建表时指定使用InnoDB存储引擎，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE example (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h2 id="优化InnoDB性能的技巧">优化InnoDB性能的技巧</h2><p><strong>配置<code>innodb_buffer_pool_size</code>：控制InnoDB缓存数据和索引的内存大小</strong>。通常设置为系统内存的50%-80%。<br><strong>调整<code>innodb_log_file_size</code>：增加日志文件的大小可以减少日志磁盘写入次数</strong>，但需要确保磁盘I/O足够快。<br>**使用合适的索引：**确保对查询进行优化的索引。<br><strong>监控和调整<code>innodb_io_capacity</code>：<strong>这个参数</strong>控制后台I/O操作的速率</strong>，需要根据实际的磁盘I/O性能进行调整。<br><strong>批量操作：<strong>大量插入、更新或删除操作时，尽量使用</strong>事务批量处理，减少对数据库的冲击</strong>。</p><h2 id="InnoDB常见问题及解决方案？">InnoDB常见问题及解决方案？</h2><p>**性能问题：**若发现InnoDB性能不佳，<strong>先检查是否有足够的内存分配给<code>innodb_buffer_pool_size</code>，以及磁盘I/O是否成为瓶颈</strong>。<br><strong>锁等待：<strong>高并发下，锁等待可能导致性能下降。可</strong>通过<code>SHOW ENGINE INNODB STATUS</code>查看锁等待情况</strong>，并考虑优化查询或增加索引。<br><strong>死锁：<strong>死锁是多个事务相互等待对方释放资源的情况。MySQL会检测到死锁并自动回滚其中一个事务以解除死锁。可以</strong>通过<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>表来诊断死锁</strong>。</p><h1>业务相关</h1><h2 id="导入数据后数据库数据重复原因及解决？">导入数据后数据库数据重复原因及解决？</h2><p>**表象原因：**如<em>网络延迟、用户连点、并发</em>等<br>**本质原因：**在<em>数据库设计、及代码逻辑的严谨性</em>出了问题。</p><p><strong>前端解决方案（不可靠，推荐）</strong><br><em>用户点击按钮后，让按钮点击失效或者禁用</em>，待后端响应完成后，按钮可用<br><strong>数据库解决方案(可靠，推荐，适合高并发场景)</strong></p><ul><li>幂等主要手段就是通过表中的<strong>唯一约束</strong>实现。</li><li>添加表的<strong>唯一约束或唯一索引</strong>进行约束处理，是最有效的防治重复提交的方法</li><li>MySql 避免&quot;重复插入记录&quot;的方法：<code>INSERT ignore into，Replace into，ON DUPLICATE KEY UPDATE</code></li><li>使用 <code>ignore</code> 关键字，若用主键 <code>primary</code>或唯一索引 <code>unique</code> 区分了记录的唯一性，避免重复插入记录可以使用</li></ul><p><strong>悲观锁解决方案(可靠，推荐，适合高并发场景)</strong></p><ul><li><strong>悲观锁：<strong>以一种预防的姿态在</strong>修改数据之前把数据锁住</strong>，再对数据进行读写，<strong>释放锁之前任何人都不能对其数据进行操作</strong>，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，才可以对数据进行操作，一般数据库本身锁的机制都基于悲观锁;</li><li><strong>特点：<strong>可以完全</strong>保证数据的独占性和正确性</strong>，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</li></ul><p>**幂等：**其任意多次执行所产生的影响均与一次执行的影响相同<br><strong>需要幂等的场景:</strong></p><ul><li><strong>核心业务数据新增</strong>，如订单系统中新增订单、用户信息系统中新增用户；</li><li><strong>审批流系统多人审批同一数据</strong>时，可能导致审批多次。</li><li><strong>定时任务触发</strong>数据生成时可能重复触发，导致数据生成多次。</li></ul>]]></content>
    
    
    <summary type="html">‌数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。数据库软件有着整体性和共享性的特点。</summary>
    
    
    
    <category term="中间件" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="Database" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件</title>
    <link href="https://southernfish.github.io/2025/06/19/message-queue-middleware/"/>
    <id>https://southernfish.github.io/2025/06/19/message-queue-middleware/</id>
    <published>2025-06-19T10:15:36.000Z</published>
    <updated>2025-06-21T08:05:35.151Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于RabbitMQ的问题</p><h2 id="RabbitMQ-的使用场景有哪些？">RabbitMQ 的使用场景有哪些？</h2><p><strong>抢购活动，削峰填谷，防止系统崩塌</strong>。<br><strong>延迟信息处理</strong>，比如 10 分钟之后给下单未付款的用户<strong>发送邮件提醒</strong>。<br><strong>解耦系统</strong>，对于<strong>新增的功能可以单独写模块扩展</strong>，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p><h2 id="RabbitMQ-有哪些重要的角色？">RabbitMQ 有哪些重要的角色？</h2><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><ul><li><strong>生产者：<strong>消息的创建者，负责</strong>创建和推送数据</strong>到消息服务器；</li><li><strong>消费者：<strong>消息的接收方，用于</strong>处理数据和确认消息</strong>；</li><li>**代理：**就是 <strong><code>RabbitMQ</code> 本身</strong>，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h2 id="RabbitMQ-有哪些重要的组件？">RabbitMQ 有哪些重要的组件？</h2><p><code>ConnectionFactory</code>（连接管理器）：<strong>应用程序与Rabbit之间建立连接的管理器</strong>，程序代码中使用。<br><code>Channel</code>（信道）：<strong>消息推送使用的通道</strong>。<br><code>Exchange</code>（交换器）：用于<strong>接受、分配消息</strong>。<br><code>Queue</code>（队列）：用于<strong>存储</strong>生产者的消息。<br><code>RoutingKey</code>（路由键）：用于把生成者的数据<strong>分配到交换器</strong>上。<br><code>BindingKey</code>（绑定键）：用于<strong>把交换器的消息绑定到队列</strong>上。</p><h2 id="RabbitMQ-中-vhost-的作用是什么？">RabbitMQ 中 vhost 的作用是什么？</h2><p><strong>vhost：<strong>每个 RabbitMQ 都能创建很多 <code>vhost</code>，我们称之为</strong>虚拟主机</strong>，每个虚拟主机其实都是 <strong>mini 版的RabbitMQ</strong>，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h2 id="RabbitMQ-的消息是怎么发送的？">RabbitMQ 的消息是怎么发送的？</h2><p>首先客户端必须<strong>连接到 <code>RabbitMQ</code> 服务器</strong>才能发布和消费消息，<strong>客户端和 <code>rabbit server</code> 之间会创建一个 <code>tcp 连接</code></strong>，一旦 <strong><code>tcp</code> 打开并通过了认证</strong>（认证就是你发送给 rabbit 服务器的用户名和密码），你的<strong>客户端和 <code>RabbitMQ</code> 就创建了一条 <code>amqp 信道</code>（channel）</strong>，信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><h2 id="RabbitMQ-怎么保证消息的稳定性？">RabbitMQ 怎么保证消息的稳定性？</h2><p>提供了<strong>事务</strong>的功能。<br>通过<strong>将 <code>channel</code> 设置为 <code>confirm</code>（确认）模式</strong>。</p><h2 id="RabbitMQ-怎么避免消息丢失？">RabbitMQ 怎么避免消息丢失？</h2><ul><li><strong>把消息持久化磁盘</strong>，保证服务器重启消息不丢失。</li><li><strong>每个集群中至少有一个物理磁盘，保证消息落入磁盘</strong>。</li></ul><h2 id="要保证消息持久化成功的条件有哪些？">要保证消息持久化成功的条件有哪些？</h2><p><strong>声明队列</strong>必须<strong>设置持久化 <code>durable</code> 设置为 <code>true</code></strong>。<br><strong>消息推送投递模式</strong>必须设置持久化，<strong><code>deliveryMode</code> 设置为 2（持久）</strong>。<br>消息<strong>已经到达持久化交换器</strong>。<br>消息<strong>已经到达持久化队列</strong>。<br>以上四个条件都满足才能保证消息持久化成功。</p><h2 id="RabbitMQ-持久化有什么缺点？">RabbitMQ 持久化有什么缺点？</h2><p>持久化的缺点就是<strong>降低了服务器的吞吐量</strong>，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可**尽量使用 <code>ssd 硬盘</code>**来缓解吞吐量的问题。</p><h2 id="RabbitMQ-有几种广播类型？">RabbitMQ 有几种广播类型？</h2><p><code>direct</code>（默认方式）：最基础最简单的模式，<strong>发送方把消息发送给订阅方</strong>，针对多个订阅者，<strong>默认采取轮询方式进行消息发送</strong>。<br><code>headers</code>：与 <code>direct</code> 类似，只是性能很差，此类型几乎用不到。<br><code>fanout</code>：<strong>分发模式</strong>，把消息<strong>分发给所有订阅者</strong>。<br><code>topic</code>：<strong>匹配订阅模式</strong>，使用<strong>正则匹配</strong>到消息队列，能匹配到的都能接收到。</p><h2 id="RabbitMQ-怎么实现延迟消息队列？">RabbitMQ 怎么实现延迟消息队列？</h2><p>延迟队列的实现有两种方式：</p><ul><li>通过<strong>消息过期后进入死信交换器，再由交换器转发到延迟消费队列</strong>，实现延迟功能；</li><li>使用 <code>RabbitMQ-delayed-message-exchange</code> 插件实现延迟功能。</li></ul><h2 id="RabbitMQ-集群有什么用？">RabbitMQ 集群有什么用？</h2><p>集群主要有以下两个用途：</p><ul><li>**高可用：**某个服务器出现问题，整个 <code>RabbitMQ</code> 还可以继续使用；</li><li>**高容量：**集群可以承载更多的消息量。</li></ul><h2 id="RabbitMQ-节点的类型有哪些？">RabbitMQ 节点的类型有哪些？</h2><p>**磁盘节点：**消息会存储到磁盘。<br>**内存节点：**消息都存储在内存中，<strong>重启服务器消息丢失，性能高于磁盘类型</strong>。</p><h2 id="RabbitMQ-集群搭建需要注意哪些问题？">RabbitMQ 集群搭建需要注意哪些问题？</h2><p>各<strong>节点之间使用<code>“–link”</code>连接</strong>，此属性不能忽略。<br>各节点使用的 <strong><code>erlang cookie</code> 值必须相同</strong>，此值相当于“秘钥”的功能，<strong>用于各节点的认证</strong>。<br><strong>整个集群中必须包含一个磁盘节点</strong>。</p><h2 id="RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？">RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h2><p>不是，原因有以下两个：</p><ul><li><strong>存储空间的考虑：<strong>若每个节点都拥有所有队列的完全拷贝，新增节点不但没有新增存储空间，反而</strong>增加了冗余数据</strong>；</li><li><strong>性能的考虑：<strong>若每条消息都需要完整拷贝到每一个集群节点，那新增节点并</strong>没有提升处理消息的能力</strong>，最多是保持和单节点相同的性能<strong>甚至是更糟</strong>。</li></ul><h2 id="RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？">RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h2><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><p>唯一磁盘节点崩溃了，<strong>集群可以保持运行，但不能更改任何东西</strong></p><h2 id="RabbitMQ-对集群节点停止顺序有要求吗？">RabbitMQ 对集群节点停止顺序有要求吗？</h2><p><code>RabbitMQ</code> 对集群的停止顺序是有要求的，应该<strong>先关闭内存节点，最后再关闭磁盘节点。若顺序恰好相反的话，可能会造成消息的丢失</strong>。</p>]]></content>
    
    
    <summary type="html">简单记录一些关于消息中间件的问题</summary>
    
    
    
    <category term="中间件" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="MQ" scheme="https://southernfish.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://southernfish.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="https://southernfish.github.io/2025/06/19/mybatis/"/>
    <id>https://southernfish.github.io/2025/06/19/mybatis/</id>
    <published>2025-06-19T09:25:36.000Z</published>
    <updated>2025-06-21T08:05:35.152Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于MyBatis的问题</p><h2 id="MyBatis-中-和-的区别是什么？">MyBatis 中 #{}和 ${}的区别是什么？</h2><p><code>\#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符替换。在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 <code>PreparedStatement</code> 的 set 方法赋值，这样可以有效防止 SQL 注入，保证程序的运行安全。</p><h2 id="MyBatis-有几种分页方式？">MyBatis 有几种分页方式？</h2><p>**分页方式：**逻辑分页和物理分页。</p><ul><li><strong>逻辑分页：<strong>使用 <code>MyBatis</code> 自带的 <code>RowBounds</code> 进行分页，它是</strong>一次性查询很多数据，然后在数据中再进行检索</strong>。</li><li><strong>物理分页：<strong>手写 SQL 分页或使用分页插件 <code>PageHelper</code>，去数据库</strong>查询指定条数的分页数据</strong>的形式。</li></ul><h2 id="MyBatis-逻辑分页和物理分页的区别是什么？">MyBatis 逻辑分页和物理分页的区别是什么？</h2><p><strong>逻辑分页</strong>是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是<strong>需要消耗大量的内存、有内存溢出的风险、对数据库压力较大</strong>。<br><strong>物理分页</strong>是从数据库<strong>查询指定条数的数据</strong>，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p><h2 id="RowBounds-是一次性查询全部结果吗？为什么？">RowBounds 是一次性查询全部结果吗？为什么？</h2><p><code>RowBounds</code> 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 <em>MyBatis 是对 jdbc 的封装</em>，<strong>在 jdbc 驱动中有一个 <code>Fetch Size</code> 的配置，它规定了每次最多从数据库查询多少条数据</strong>，假如你要查询更多数据，它会在你<strong>执行 next()的时候，去查询更多的数据</strong>。<br>就好比去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()时会自动完成查询工作。这样做的好处可以<strong>有效防止内存溢出</strong>。</p><h2 id="MyBatis-是否支持延迟加载？延迟加载的原理是什么？">MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h2><p><code>MyBatis</code> 支持延迟加载，设置 <code>lazyLoadingEnabled=true</code> 。<br><strong>延迟加载的原理</strong>是<strong>调用的时候触发加载</strong>，而不是在初始化的时候就加载信息。<br>比如调用 <code>a. getB(). getName()</code>，这个时候发现 <code>a. getB()</code> 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 <code>a. setB(b)</code>，而这时候再调用 <code>a. getB(). getName()</code> 就有值了，这就是延迟加载的基本原理。</p><h2 id="MyBatis-的一级缓存和二级缓存？">MyBatis 的一级缓存和二级缓存？</h2><p><strong>一级缓存：基于 <code>PerpetualCache</code> 的 <code>HashMap</code> 本地缓存</strong>，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，<strong>可能会出现脏数据</strong>。<strong>当 <code>Session flush 或 close</code> 之后，该 Session 中的所有 Cache 就将清空</strong>，默认一级缓存是开启的。<br><strong>二级缓存：<strong>也是</strong>基于 <code>PerpetualCache</code> 的 <code>HashMap</code> 本地缓存</strong>，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，<strong>要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)</strong>。<br><strong>开启二级缓存数据查询流程：</strong><code>二级缓存 -&gt; 一级缓存 -&gt; 数据库</code>。<br>**缓存更新机制：**当某一个作用域(一级缓存 Session/二级缓存 Mapper)<strong>进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear</strong>。</p><h2 id="MyBatis-和-hibernate-的区别有哪些？">MyBatis 和 hibernate 的区别有哪些？</h2><p><strong>灵活性：<strong>MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。<br><strong>可移植性：</strong><code>MyBatis</code> 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以</strong>可移植性比较差</strong>。<br>**学习和使用门槛：**MyBatis 入门比较简单，使用门槛也更低。<br><strong>二级缓存：</strong><code>hibernate 拥有更好的二级缓存，可以自行更换为第三方的二级缓存</code>。</p><h2 id="MyBatis-有哪些执行器（Executor）？">MyBatis 有哪些执行器（Executor）？</h2><p>MyBatis 有<strong>三种</strong>基本的Executor执行器：<br>**<code>SimpleExecutor：</code>**每执行一次 <code>update 或 select</code> 就开启一个 <code>Statement</code> 对象，<strong>用完立刻关闭</strong> Statement 对象；<br><strong><code>ReuseExecutor：</code><strong>执行 <code>update 或 select</code>，<strong>以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建</strong>，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是</strong>重复使用 Statement 对象</strong>；<br>**<code>BatchExecutor：</code>**执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（<code>addBatch()</code>），等待统一执行（<code>executeBatch()</code>），它<em>缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理</em>，与 jdbc 批处理相同。</p><h2 id="MyBatis-分页插件的实现原理是什么？">MyBatis 分页插件的实现原理是什么？</h2><p>分页插件的基本原理是使用 <code>MyBatis</code> 提供的插件接口，实现自定义插件，<strong>在插件的拦截方法内拦截待执行的 SQL</strong>，然后重写 SQL，根据 <code>dialect</code> 方言，<strong>添加对应的物理分页语句和物理分页参数</strong>。</p><h2 id="MyBatis-如何编写一个自定义插件？">MyBatis 如何编写一个自定义插件？</h2><h3 id="自定义插件实现原理">自定义插件实现原理</h3><p>MyBatis 自定义插件针对 MyBatis 四大对象(<code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>)进行拦截：<br><strong>Executor：<strong>拦截</strong>内部执行器</strong>，它负责<strong>调用 <code>StatementHandler</code> 操作数据库，并把结果集通过 <code>ResultSetHandler</code> 进行自动映射，另外它还处理了二级缓存的操作</strong>；<br><strong>StatementHandler：<strong>拦截 <strong>SQL 语法构建的处理</strong>，它是 MyBatis 直接和数据库执行 <code>SQL 脚本</code>的对象，另外它也</strong>实现了 MyBatis 的一级缓存</strong>；<br><strong>ParameterHandler：<strong>拦截</strong>参数的处理</strong>；<br><strong>ResultSetHandler：<strong>拦截</strong>结果集的处理</strong>。</p><h3 id="自定义插件实现关键">自定义插件实现关键</h3><p><code>MyBatis插件</code>要实现 <code>Interceptor</code> 接口，接口包含的方法，如下代码所示：<br>**<code>setProperties</code> 方法：**在 MyBatis 进行配置插件的时候可配置自定义相关属性，即：<strong>接口实现对象的参数配置</strong>；<br><strong><code>plugin</code> 方法：<strong>插件用于</strong>封装目标对象</strong>的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：<code>return Plugin. wrap(target, this)</code>；<br><strong><code>intercept</code> 方法：<strong>是要</strong>进行拦截的时候要执行的方法</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interfaceInterceptor&#123;</span><br><span class="line">  object intercept(Invocation invocation) throws Throwable;</span><br><span class="line">  object plugin(object target);</span><br><span class="line">  voidsetProperties(Properties properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Intercepts(&#123;@signature(type = Executor.class, method = &quot;query&quot;, </span><br><span class="line">    args = &#123;Mappedstatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="line">publicclassTestInterceptorimplementsInterceptor &#123;</span><br><span class="line">  public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    Object target = invocation.getTarget(); //被代理对象</span><br><span class="line">    Method method = invocation.getMethod();//代理方法</span><br><span class="line">    Object[] args = invocation.getArgs() // 方法参数</span><br><span class="line">    // do something ...... 方法拦截前执行代码块</span><br><span class="line">    Object result =invocation.proceed():</span><br><span class="line">    // do something ...... 方法拦截后执行代码块</span><br><span class="line">    return result:</span><br><span class="line">  &#125;</span><br><span class="line">  public object plugin(object target)&#123;</span><br><span class="line">    return Plugin.wrap(target, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MyBatis</summary>
    
    
    
    <category term="框架" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="MyBatis" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/MyBatis/"/>
    
    
    <category term="MyBatis" scheme="https://southernfish.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate</title>
    <link href="https://southernfish.github.io/2025/06/19/hibernate/"/>
    <id>https://southernfish.github.io/2025/06/19/hibernate/</id>
    <published>2025-06-19T08:45:36.000Z</published>
    <updated>2025-06-21T08:05:35.151Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于Hibernate的问题</p><h2 id="为什么要使用-hibernate？">为什么要使用 hibernate？</h2><p><code>hibernate</code> 是<strong>对 jdbc 的封装</strong>，大大简化了数据访问层的繁琐的重复性代码。<br>hibernate 是一个优秀的 ORM 实现，很大程度上<strong>简化了 DAO 层的编码功能</strong>。<br>可以很<strong>方便的进行数据库的移植工作</strong>。<br><strong>提供了缓存机制</strong>，使程序执行更改的高效。</p><h2 id="什么是-ORM-框架？">什么是 ORM 框架？</h2><p><code>ORM（Object Relation Mapping）</code>对象关系映射，是<strong>把数据库中的关系数据映射成为程序中的对象</strong>。<br>**使用 ORM 的优点：**提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p><h2 id="hibernate-中如何在控制台查看打印的-SQL-语句？">hibernate 中如何在控制台查看打印的 SQL 语句？</h2><p>在 <code>Config</code> 里面<strong>把 <code>hibernate. show_SQL</code> 设置为 <code>true</code></strong> 就可以。但不建议开启，<em>开启之后会降低程序的运行效率</em></p><h2 id="hibernate-有几种查询方式？">hibernate 有几种查询方式？</h2><p><strong>三种：</strong><code>hql</code>、<code>原生 SQL</code>、<code>条件查询 Criteria</code></p><h2 id="hibernate-实体类可以被定义为-final-吗？">hibernate 实体类可以被定义为 final 吗？</h2><p>实体类可以定义为 final 类，但这样就<strong>不能使用 <code>hibernate 代理模式</code>下的延迟关联提供性能</strong>了，所以不建议定义实体类为 final。</p><h2 id="在-hibernate-中使用-Integer-和-int-做映射有什么区别？">在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h2><p><code>Integer</code> 类型为对象，它的值允许为 null，而 <code>int</code> 属于基础数据类型，值不能为 null。</p><h2 id="hibernate-是如何工作的？">hibernate 是如何工作的？</h2><p>读取并解析配置文件 → 读取并解析映射文件，创建 <code>SessionFactory</code> → 打开 <code>Session</code> → 创建事务 → 进行持久化操作 → 提交事务 → 关闭 <code>Session</code> → 关闭 <code>SessionFactory</code></p><h2 id="get-和-load-的区别？">get()和 load()的区别？</h2><p>数据查询时，<strong>没有 <code>OID</code> 指定的对象，<code>get()</code> 返回 null；<code>load()</code> 返回一个代理对象</strong>。<br><strong><code>load()</code>支持延迟加载</strong>；<code>get()</code> 不支持延迟加载。</p><h2 id="hibernate-的缓存机制？">hibernate 的缓存机制？</h2><p>**一级缓存：**也叫 ·Session 缓存·，<strong>只在 Session 作用范围内有效</strong>，不需要用户干涉，由 hibernate 自身维护，<em>缓存清除方式</em>：</p><ul><li><code>evict(object)</code>清除 object 的缓存；</li><li><code>clear()</code>清除一级缓存中的所有缓存；</li><li><code>flush()</code>刷出缓存；</li></ul><p>**二级缓存：**应用级别的缓存，<strong>在所有 Session 中都有效，支持配置第三方的缓存</strong>，如：EhCache。</p><h2 id="hibernate-对象有哪些状态？">hibernate 对象有哪些状态？</h2><p><strong>临时/瞬时状态：直接new 出来的对象</strong>，该对象还没被持久化（没保存在数据库中），不受 Session 管理。<br>**持久化状态：**调用 Session 的 <code>save/saveOrupdate/get/load/list</code> 等方法时，对象就是持久化状态。<br>**游离状态：<code>**Session</code> <strong>关闭之后</strong>对象就是游离状态。</p><h2 id="在-hibernate-中-getCurrentSession-和-openSession-的区别？">在 hibernate 中 getCurrentSession 和 openSession 的区别？</h2><p><strong><code>getCurrentSession</code> 会绑定当前线程</strong>，而 openSession 则不会。<br><code>getCurrentSession</code> 事务是 Spring 控制的，并且不需要手动关闭，而 <strong><code>openSession</code> 需要手动开启和提交事务</strong>。</p><h2 id="hibernate-实体类必须要有无参构造函数吗？为什么？">hibernate 实体类必须要有无参构造函数吗？为什么？</h2><p><code>hibernate</code> 中每个实体类<strong>必须提供一个无参构造函数</strong>，因为 hibernate 框架<strong>要使用 <code>reflection api</code>，通过调用 <code>ClassnewInstance()</code> 来创建实体类的实例</strong>，如果没有无参的构造函数就会抛出异常。</p>]]></content>
    
    
    <summary type="html">Hibernate</summary>
    
    
    
    <category term="框架" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Hibernate" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/Hibernate/"/>
    
    
    <category term="Hibernate" scheme="https://southernfish.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud</title>
    <link href="https://southernfish.github.io/2025/06/19/SpringCloud/"/>
    <id>https://southernfish.github.io/2025/06/19/SpringCloud/</id>
    <published>2025-06-19T08:30:36.000Z</published>
    <updated>2025-06-21T08:05:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录关于Spring Cloud的相关问题</p><h2 id="什么是-spring-cloud？">什么是 spring cloud？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring cloud 是一系列框架的有序集合。</span><br><span class="line">利用 spring boot 的开发便利性简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>spring cloud</code> 是<strong>一系列框架的有序集合</strong>。<br>利用 <code>spring boot 的开发便利性</code>简化了分布式系统基础设施的开发，如<strong>服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控</strong>等，都可以用 spring boot 的开发风格做到一键启动和部署。</p><h2 id="spring-cloud-断路器的作用是什么？Hystrix">spring cloud 断路器的作用是什么？Hystrix</h2><p>在分布式架构中，断路器模式的作用也是类似的，当<em>某个服务单元发生故障</em>（类似用电器发生短路）之后，<em>通过断路器的故障监控</em>（类似熔断保险丝），<em>向调用方返回一个错误响应，而不是长时间的等待</em>。这样就不会使得线程因调用故障服务被长时间占用不释放，<strong>避免故障在分布式系统中的蔓延</strong>。</p><h2 id="spring-cloud-的核心组件有哪些？-Netflix">spring cloud 的核心组件有哪些？(Netflix)</h2><table><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th><th><strong>解决了什么问题</strong></th></tr></thead><tbody><tr><td>Eureka</td><td>服务注册与发现</td><td>硬编码服务提供者地址的方式有不少问题。要想解决这些问题，服务消费者需要一个强大的服务发现机制，服务消费者使用这种机制获取服务提供者的网络信息。不仅如此，即使<strong>服务提供者的网络地址发生变化，服务消费者也无须修改配置文件</strong>。</td></tr><tr><td>Ribbon</td><td>客户端侧负载均衡</td><td><code>Ribbon</code> 的作用是负载均衡，<strong>会帮你在每次请求时选择一台服务器，均匀的把请求分发到各个服务器上</strong>。</td></tr><tr><td>Feign</td><td>REST调用</td><td>基于<strong>动态代理机制</strong>，<code>Feign Client</code> 会根据注解，跟你指定的服务<strong>建立连接、构造请求、发起请求、获取响应、解析响应等</strong>。</td></tr><tr><td>Hystrix</td><td>容错处理</td><td>服务链上，因某个微服务的异常，而导致雪崩效应，整条服务链宕机的问题；Hystrix会去捕获这个异常，利用Hystrix接口处理这类异常。提供线程池，不同的服务走不同的线程池，实现了<strong>不同服务调用的隔离，避免了服务雪崩的问题</strong></td></tr><tr><td>Zuul</td><td>微服务网关</td><td>由 <code>Zuul</code> 网关转发请求给对应的服务，<strong>负责网络路由，可以做统一的降级、限流、认证授权、安全等</strong>。</td></tr></tbody></table><h2 id="分布式、微服务系统常见的问题？">分布式、微服务系统常见的问题？</h2><p><strong>服务雪崩</strong><br>多个微服务之间调用时，假设<em>微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它微服务</em>，这就是**<code>“扇出”</code><strong>。若扇出链路上<em>某个微服务调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源</em>，进而引起系统崩溃，这就是所谓的</strong><code>“雪崩效应”</code><strong>。<br>对于高流量的应用来说，<em>单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和</em>。比失败更糟糕的是，这些应用程序还可能<em>导致服务之间的延迟增加，线程和其他系统资源紧张，导致整个系统发生更多的级联故障</em>。<br>这些都表示</strong>需要对故障和延迟进行隔离和管理**，以便单个依赖关系的失败，不能取消整个应用程序或系统。<br>通常一个模块下的某个实例失败后，这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。<br><strong>解决方法</strong><br><code>Hystrix</code>是一个用于<strong>处理分布式系统的延迟和容错的开源库</strong>，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，<code>Hystrix</code>能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。<br><code>“断路器”</code>本身是一种开关装置，当某个服务单元发生故障后，通过断路器的故障监控（类似熔断保险丝），<strong>向调用方返回一个符合预期的、可处理的备选响应（<code>FallBack</code>），而非长时间等待或抛出调用方无法处理的异常</strong>，保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>]]></content>
    
    
    <summary type="html">Spring Cloud</summary>
    
    
    
    <category term="框架" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="spring" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
    <category term="Spring Cloud" scheme="https://southernfish.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="https://southernfish.github.io/2025/06/19/SpringBoot/"/>
    <id>https://southernfish.github.io/2025/06/19/SpringBoot/</id>
    <published>2025-06-19T07:52:36.000Z</published>
    <updated>2025-06-21T08:05:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录关于Spring Boot的相关问题</p><h2 id="什么是-spring-boot？">什么是 spring boot？</h2><p><code>spring boot</code> 是为 spring 服务的，是用来<strong>简化新 spring 应用的初始搭建以及开发过程</strong>的。</p><h2 id="为什么要用-spring-boot？">为什么要用 spring boot？</h2><p><em>配置简单、独立运行、自动装配、无代码生成和 xml 配置、提供应用监控、易上手、提升开发效率</em></p><ol><li>配置简单，不需要编写太多的xml配置文件；</li><li>内置tomcat服务器，不需要打包成war包，可以直接放到tomcat中运行；</li><li><strong>独立运行：</strong><code>SpringBoot</code>可以创建独立运行的应用而不需要依赖于容器；</li><li><strong>提供应用监控</strong>，提供<code>maven</code>极简配置，以及可视化的相关监控功能，比如性能监控，应用的健康程度等；</li></ol><h2 id="spring-boot-核心配置文件是什么？">spring boot 核心配置文件是什么？</h2><p>spring boot 核心的两个配置文件：</p><ul><li><code>bootstrap (. yml 或者 . properties)</code>：<code>boostrap</code> 由父 <code>ApplicationContext</code> 加载，比 <code>applicaton</code> 优先加载，且 boostrap 里面的属性不能被覆盖；</li><li><code>application (. yml 或者 . properties)</code>：用于 spring boot 项目的自动化配置。</li></ul><h2 id="spring-boot-配置文件有哪几种类型？它们有什么区别？">spring boot 配置文件有哪几种类型？它们有什么区别？</h2><p>配置文件有 <code>. properties</code> 格式和 <code>. yml</code> 格式，它们主要的区别是<strong>书写风格不同</strong>。<br>yml 格式不支持 <code>@PropertySource</code> 注解导入。</p><h2 id="spring-boot-有哪些方式可以实现热部署？">spring boot 有哪些方式可以实现热部署？</h2><p>使用 <code>devtools</code> 启动热部署，添加 <code>devtools库</code>，在配置文件中把 <code>spring.devtools.restart.enabled</code> 设置为 <code>true</code>；<br>使用 <code>Intellij Idea</code> 编辑器，勾上自动编译或手动重新编译。</p><h2 id="jpa-和-hibernate-有什么区别？">jpa 和 hibernate 有什么区别？</h2><p><code>jpa</code> 全称 <code>Java Persistence API</code>，<strong>是 Java 持久化接口规范，<code>hibernate</code> 属于 jpa 的具体实现</strong>。</p><h2 id="springboot-的常见注解">springboot 的常见注解</h2><table><thead><tr><th>注解</th><th>解释</th></tr></thead><tbody><tr><td>@SpringBootApplication</td><td>这个注解是Spring Boot最核心的注解，用在 <code>Spring Boot的主类</code>上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。它是<code>@Configuration,@EnableAutoConfiguration,@ComponentScan</code>三个注解的组合。</td></tr><tr><td>@EnableAutoConfiguration</td><td>允许 Spring Boot 自动配置注解，开启这个注解后，Spring Boot 根据当前类路径下的包或者类来配置 Spring Bean。</td></tr><tr><td>@SpringBootConfiguration</td><td><code>@Configuration</code> 注解的变体，仅用来<code>修饰Spring Boot 配置</code>，或者可利于 Spring Boot 后续的扩展。</td></tr><tr><td>@ConditionalOnBean</td><td><code>@ConditionalOnBean(A.class)</code>仅仅在当前上下文中存在A对象时，才实例化一个Bean。</td></tr><tr><td>@ConditionalOnMissingBean</td><td>组合@Conditional注解，和@ConditionalOnBean注解相反，仅在当前上下文中不存在A对象时，才实例化一个Bean。</td></tr><tr><td>@ConditionalOnClass</td><td>组合 @Conditional 注解，仅当某些类存在于<code>classpath</code>上时候才创建某个Bean。</td></tr><tr><td>@ConditionalOnMissingClass</td><td>组合@Conditional注解，和@ConditionalOnMissingClass注解相反，当<code>classpath</code>中没有指定的 Class才开启配置。</td></tr><tr><td>@ConditionalOnWebApplication</td><td>组合@Conditional 注解，当前<strong>项目类型是 WEB 项目</strong>才开启配置。<br />当前项目有以下 3 种类型：<br /><code>ANY</code>(任何Web项目都匹配)<br /><code>SERVLET</code>（仅Servelet项目才会匹配）<br /><code>REACTIVE</code>（只有基于响应的web应用程序才匹配）</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>组合@Conditional注解，当前<strong>项目类型不是 WEB 项目</strong>才开启配置。</td></tr><tr><td>@ConditionalOnProperty</td><td>组合 @Conditional 注解，当<strong>指定的属性有指定的值</strong>时才开启配置。</td></tr><tr><td>@ConditionalOnExpression</td><td>组合 @Conditional 注解，当 <strong>SpEL 表达式为 true 时</strong>才开启配置。<br />@Conditional <br />@ConditionalOnExpression(“${enabled:false}”)</td></tr><tr><td>@ConditionalOnJava</td><td>组合@Conditional 注解，当<strong>运行的 <code>Java JVM</code> 在指定的版本范围时</strong>才开启配置。</td></tr><tr><td>@ConditionalOnResource</td><td>组合 @Conditional 注解，当<strong>类路径下有指定的资源</strong>才开启配置。<br />@Bean<br />@ConditionalOnResource(resources=“classpath:shiro.ini”)</td></tr><tr><td>@ConditionalOnJndi</td><td>组合 @Conditional 注解，当<strong>指定的 JNDI 存在时</strong>才开启配置。</td></tr><tr><td>@ConditionalOnCloudPlatform</td><td>组合 @Conditional 注解，当<strong>指定的云平台激活时</strong>才开启配置。</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>组合 @Conditional 注解，当<strong>指定的 class 在容器中只有一个 Bean，或者同时有多个但为首选时</strong>才开启配置。</td></tr><tr><td>@ConfigurationProperties</td><td><code>Spring Boot</code>可<em>使用注解的方式将自定义的properties文件映射到实体bean中，比如config.properties文件</em>。<br />@Data<br />@ConfigurationProperties(“rocketmq.consumer”)</td></tr><tr><td>@EnableConfigurationProperties</td><td>当<code>@EnableConfigurationProperties</code>注解应用到你的@Configuration时，任何被@ConfigurationProperties注解的beans将自动被<code>Environment属性</code>配置。 这种风格的配置<strong>适合与SpringApplication的外部YAML配置进行配合使用</strong>。<br />@Configuration<br />@EnableConfigurationProperties({RocketMQProducerProperties.class, RocketMQConsumerProperties.class,})</td></tr><tr><td>@AutoConfigureAfter</td><td>用在自动配置类上面，表示该自动配置类需要<strong>在另外指定的自动配置类配置完之后</strong>。</td></tr><tr><td>@AutoConfigureBefore</td><td>用在自动配置类上面，表示该自动配置类需要<strong>在另外指定的自动配置类配置之前</strong>。</td></tr><tr><td>@AutoConfigureOrder</td><td>Spring Boot 1.3.0中有一个新的注解<code>@AutoConfigureOrder</code>，用于<strong>确定配置加载的优先级顺序</strong>。<br />@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) // 自动配置里面的最高优先级@Configuration@ConditionalOnWebApplication // 仅限于web应用@Import(BeanPostProcessorsRegistrar.class) // 导入内置容器的设置</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Spring Boot</summary>
    
    
    
    <category term="框架" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="spring" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC</title>
    <link href="https://southernfish.github.io/2025/06/19/SpringMvc/"/>
    <id>https://southernfish.github.io/2025/06/19/SpringMvc/</id>
    <published>2025-06-19T07:12:36.000Z</published>
    <updated>2025-06-21T08:05:35.150Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些有关 Spring MVC 的问题</p><h1>Spring</h1><h2 id="为什么要使用-spring？">为什么要使用 spring？</h2><p>spring <strong>提供 ioc 技术</strong>，容器会帮你管理依赖的对象，而无需自己创建和管理依赖对象，<strong>轻松实现程序的解耦</strong>。<br>spring <strong>提供了事务支持</strong>，使得<strong>事务操作更加方便</strong>。<br>spring <strong>提供了面向切面编程</strong>，这样可以<strong>更方便的处理某一类的问题</strong>。<br><strong>更方便的框架集成</strong>，<code>spring</code> 可以很方便的集成其他框架，比如 <code>MyBatis</code>、<code>hibernate</code> 等。</p><h2 id="什么是-aop？">什么是 aop？</h2><p><code>aop</code> 是<strong>面向切面编程</strong>，<strong>通过预编译方式和运行期动态代理实现程序功能的统一维护</strong>的一种技术。<br>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理<strong>日志、异常</strong>等。</p><h2 id="什么是-ioc？">什么是 ioc？</h2><p><strong>ioc：</strong><code>Inversionof Control</code>（中文：<strong>控制反转</strong>）是 spring 的核心，对于 spring 框架来说，就是<strong>由 spring 来负责控制对象的生命周期和对象间的关系</strong>。<br>简单来说，控制指的是<strong>当前对象对内部成员的控制权</strong>；控制反转指的是，这种控制权不由当前对象管理了，由其他（类，第三方容器）来管理。</p><h2 id="spring-有哪些主要模块？">spring 有哪些主要模块？</h2><p>**spring core：**框架的最基础部分，<strong>提供 ioc 和依赖注入特性</strong>。<br><strong>spring context：<strong>构建于 <code>core</code> 封装包基础上的 <code>context</code> 封装包，<strong>提供了一种框架式的对象访问方法</strong>。<br><strong>spring dao：</strong><code>Data Access Object</code> <strong>提供了JDBC的抽象层</strong>。<br><strong>spring aop：<strong>提供了</strong>面向切面的编程</strong>实现，可</strong>自定义拦截器、切点</strong>等。<br>**spring Web：**提供了针对<code> Web</code> 开发的集成特性，如文件上传，利用 <code>servlet listeners</code> 进行 ioc 容器初始化和针对 <code>Web</code> 的 <code>ApplicationContext</code>。<br><strong>spring Web mvc：</strong><code>spring</code> 中的 <code>mvc</code> 封装包提供了<code> Web</code> 应用的 <code>Model-View-Controller（MVC）</code>的实现。</p><h2 id="spring-常用的注入方式有哪些？">spring 常用的注入方式有哪些？</h2><ul><li>setter 属性注入</li><li>构造方法注入</li><li>注解方式注入</li></ul><h2 id="spring-中的-bean-是线程安全的吗？">spring 中的 bean 是线程安全的吗？</h2><p><code>spring</code> 中的 <code>bean</code> <strong>默认是单例模式</strong>，spring 框架并没有对单例 bean 进行多线程的封装处理。<br>实际上<strong>大部分时候 <code>spring bean</code> 是无状态</strong>的（比如 <code>dao</code> 类），所以某种程度上来说 bean 也是安全的，但<em>如果 bea有状态的话（比如<code>view model</code> 对象），那就要开发者自己去保证线程安全了</em>，最简单的就是<strong>改变 bean 的作用域，把<code>singleton</code>变更为<code>prototype</code></strong>，这样请求 bean 相当于 <code>new Bean()</code>了，所以就可以保证线程安全了。</p><ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul><h2 id="spring-支持几种-bean-的作用域？">spring 支持几种 bean 的作用域？</h2><p>spring 支持 5 种作用域，如下：<br><strong>singleton：</strong><code>spring ioc</code> 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；<br>**prototype：**每次从容器调用 bean 时都会创建一个新的示例，即每次 <code>getBean()</code>相当于执行 <code>new Bean()</code>操作；<br>Web 环境下的作用域：</p><ul><li>**request：**每次 http 请求都会创建一个 bean；</li><li>**session：**同一个 <code>http session</code> 共享一个 bean 实例；</li><li>**global-session：**用于 <code>portlet</code> 容器，因为每个 <code>portlet</code> 有单独的 <code>session</code>，<code>globalsession</code> 提供一个全局性的 <code>http session</code>。</li></ul><p><strong>注意：</strong> 使用 <code>prototype</code> 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h2 id="spring-自动装配-bean-有哪些方式？">spring 自动装配 bean 有哪些方式？</h2><p><strong>no：<strong>默认值，表示</strong>没有自动装配</strong>，应使用显式 bean 引用进行装配。<br><strong>byName：<strong>它</strong>根据 bean 的名称注入对象依赖项</strong>。<br><strong>byType：<strong>它</strong>根据类型</strong>注入对象依赖项。<br><strong>构造函数：<strong>它</strong>通过构造函数</strong>来注入依赖项，需要设置大量的参数。<br>**autodetect：**容器首先通过构造函数使用 <code>autowire</code> 装配，如果不能，则通过 <code>byType</code> 自动装配。</p><h2 id="spring-事务实现方式有哪些？">spring 事务实现方式有哪些？</h2><p>**声明式事务：**声明式事务也有两种实现方式，<strong>基于 xml 配置文件的方式和注解方式</strong>（ @Transaction ）。<br><strong>编码方式：<strong>提供</strong>编码的形式管理和维护事务</strong>。</p><h2 id="spring-的事务隔离？">spring 的事务隔离？</h2><p>spring 有五大隔离级别，默认值为 <code>ISOLATION_DEFAULT</code>（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><ul><li>**ISOLATION_DEFAULT：**用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li><li><strong>ISOLATIONREADUNCOMMITTED：</strong><code>读未提交</code>，最低隔离级别、事务未提交前，就可被其他事务读取（会出现脏读、不可重复读、幻读）；</li><li><strong>ISOLATIONREADCOMMITTED：</strong><code>读提交</code>，一个事务提交后才能被其他事务读取到（会造成不可重复读、幻读），<code>SQL server</code> 的默认级别；</li><li><strong>ISOLATIONREPEATABLEREAD：</strong><code>可重复读</code>，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），<code>MySQL</code> 的默认级别；</li><li><strong>ISOLATION_SERIALIZABLE：</strong><code>序列化</code>，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p>**脏读：**表示一个事务能够读取另一个事务中还未提交的数据。<br>**不可重复读：**是指在一个事务内，多次读同一数据。<br>**幻读：**指同一个事务内多次查询返回的结果集不一样。<strong>发生幻读的原因</strong>是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h1>Spring MVC</h1><h2 id="spring-mvc-运行流程？">spring mvc 运行流程？</h2><p><code>spring mvc</code> 先<strong>将请求发送给 <code>DispatcherServlet</code></strong>。<br><code>DispatcherServlet</code> 查询一个或多个 <code>HandlerMapping</code>，<strong>找到处理请求的 <code>Controller</code></strong>。<br><code>DispatcherServlet</code> 再<strong>把请求提交到对应的 <code>Controller</code></strong>。<br><code>Controller</code> 进行业务逻辑处理后，会<strong>返回一个<code>ModelAndView</code></strong>。<br><code>Dispathcher</code> 查询一个或多个<code>ViewResolver</code> 视图解析器，<strong>找到 <code>ModelAndView</code> 对象指定的视图对象</strong>。<br>视图对象负责<strong>渲染返回给客户端</strong>。</p><h2 id="spring-mvc-有哪些组件？">spring mvc 有哪些组件？</h2><p>前置控制器 DispatcherServlet<br>映射控制器 HandlerMapping<br>处理器 Controller<br>模型和视图 ModelAndView<br>视图解析器 ViewResolver</p><h2 id="RequestMapping-的作用是什么？">@RequestMapping 的作用是什么？</h2><p>将 http 请求映射到相应的类/方法上。</p><h2 id="Autowired-的作用是什么？">@Autowired 的作用是什么？</h2><p><code>@Autowired</code> 可<strong>对类成员变量、方法及构造函数进行标注，完成自动装配工作</strong>。<br>通过<code>@Autowired</code> 的使用来<strong>消除 <code>set/get</code> 方法</strong>。</p><h2 id="Controller和-RestController的区别？">@Controller和@RestController的区别？</h2><p><strong>功能定位：</strong></p><ul><li>**@Controller：**主要用于处理HTTP请求并返回视图（如<code>JSP</code>、<code>Thymeleaf</code>页面），或通过<code>@ResponseBody</code>注解返回数据对象。</li><li><strong>@RestController：</strong><code>@Controller</code>与<code>@ResponseBody</code>的组合注解，专门用于构建RESTful API，直接返回数据（如<code>JSON</code>、<code>XML</code>），不涉及视图渲染。</li></ul><p><strong>返回值类型：</strong></p><ul><li>**@Controller：**可返回<code>String</code>（视图名称）、<code>ModelAndView</code>对象或通过<code>@ResponseBody</code>返回实体对象。</li><li>**@RestController：**默认返回实体对象（如自定义类），自动序列化为<code>JSON/XML</code>等格式。</li></ul><p><strong>使用场景：</strong></p><ul><li><p>**@Controller：**适用于需要渲染视图的传统Web应用场景，例如用户登录后跳转页面或展示表单。</p></li><li><p>**@RestController：**适用于开发<code>RESTful API</code>接口，直接返回数据供前端或第三方系统调用。</p></li></ul><p><strong>注解组合关系：</strong><br><code>@RestController</code>本质上是<code>@Controller + @ResponseBody</code>的组合，所有方法默认带有<code>@ResponseBody</code>属性，无需显式标注。<br>若需在<code>@RestController</code>中跳转页面，需通过<code>ModelAndView</code>封装返回值。</p>]]></content>
    
    
    <summary type="html">hello word</summary>
    
    
    
    <category term="框架" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="spring" scheme="https://southernfish.github.io/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
    <category term="Spring MVC" scheme="https://southernfish.github.io/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="https://southernfish.github.io/2025/06/19/java-exceptions/"/>
    <id>https://southernfish.github.io/2025/06/19/java-exceptions/</id>
    <published>2025-06-19T06:58:36.000Z</published>
    <updated>2025-06-21T08:05:35.151Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于 Java异常的问题</p><h1>基本问题</h1><h2 id="throw-和-throws-的区别？">throw 和 throws 的区别？</h2><p>**throw：**是真实抛出一个异常。<br>**throws：**是声明可能会抛出一个异常。</p><h2 id="final、finally、finalize-有什么区别？">final、finally、finalize 有什么区别？</h2><p><strong>final：<strong>是</strong>修饰符</strong>，如果修饰类，此类<strong>不能被继承</strong>；如果修饰方法和变量，此方法和此变量<strong>不能再被改变</strong>，只能使用。<br><strong>finally：<strong>是 try{} catch{} finally{} 最后一部分，表示</strong>不论发生任何情况都会执行</strong>，finally 部分可以省略，但若 finally 部分存在，则一定会执行 finally 里面的代码。<br><strong>finalize：<strong>是 Object 类的一个方法，在</strong>垃圾收集器执行的时候会调用被回收对象的此方法</strong>。</p><h2 id="try-catch-finally-中哪个部分可以省略？">try-catch-finally 中哪个部分可以省略？</h2><p>try-catch-finally 其中 <strong>catch 和 finally 都可以被省略，但不能同时省略</strong>，也就是说有 try 时，必须后面跟一个 catch 或 finally。</p><h2 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？">try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p><strong>finally 一定会执行</strong>，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p><h1>异常</h1><h2 id="异常机制？">异常机制？</h2><p>**异常机制：**当<em>程序出现异常，程序安全的退出、处理完后继续执行的机制</em><br>Java是采用面向对象的方式来处理异常的。<strong>处理过程：</strong></p><ul><li><strong>抛出异常：<strong>在执行一个方法时，如果发生异常，则这个方法</strong>生成代表该异常的一个对象</strong>，停止当前执行路径，并<strong>把异常对象提交给JRE</strong>。</li><li>**捕获异常：**JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，<strong>从生成异常的方法开始回溯，直到找到相应的异常处理代码为止</strong></li></ul><h2 id="try-with-resources">try-with-resources</h2><p>可以使用 try-with-resources 语句来自动管理资源，如自动关闭实现了 AutoCloseable 或 Closeable 接口的资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以使用 try-with-resources 语句来自动管理资源，如自动关闭实现了 AutoCloseable 或 Closeable 接口的资源。</span><br><span class="line">try (Resource resource = new Resource()) &#123;</span><br><span class="line">    // 使用资源</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 处理异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见的异常类有哪些？">常见的异常类有哪些？</h2><ul><li>NullPointerException 空指针异常 （RuntimeException 无需编译器处理，增加逻辑处理来避免这些异常）</li><li>ClassNotFoundException 指定类不存在（CheckedException 需要编译器处理，使用 try-catch 结构）</li><li>NumberFormatException 字符串转换为数字异常（RuntimeException ）</li><li>IndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 数据类型转换异常</li><li>FileNotFoundException 文件未找到异常</li><li>NoSuchMethodException 方法不存在异常</li><li>IOException IO 异常</li><li>SocketException Socket 异常</li></ul><h2 id="异常分类">异常分类</h2><p>所有异常的<strong>根类为 java.lang.Throwable</strong>。若内置的异常类不能够满足需要，还可以创建自己的异常类。<br>Throwable 派生了两个子类：Error 和 Exception。<br><strong>Error</strong> 是程序无法处理的错误。大多错误与代码编写者执行的操作无关，而表示代码运行时 JVM 出现的问题。<br><strong>Exception</strong> 是程序本身能够处理的异常。分为 RuntimeException 运行时异常，CheckedException 已检查异常。<strong>RuntimeException 无需编译器处理，增加逻辑处理</strong>来避免这些异常；<strong>CheckedException 需要编译器处理，使用 try-catch 结构</strong>。</p>]]></content>
    
    
    <summary type="html">java 异常</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Exceptions" scheme="https://southernfish.github.io/tags/Exceptions/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程</title>
    <link href="https://southernfish.github.io/2025/06/19/java-oop/"/>
    <id>https://southernfish.github.io/2025/06/19/java-oop/</id>
    <published>2025-06-19T06:55:36.000Z</published>
    <updated>2025-06-21T08:05:35.151Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一些关于面向对象编程的问题</p><h2 id="Java-中面向对象编程的三大特性">Java 中面向对象编程的三大特性</h2><p><strong>封装、继承、多态。<strong>分别实现了</strong>数据的隐藏与保护、代码的复用扩展以及行为的灵活适配</strong>。‌</p><p><strong>封装</strong>是对数据和行为进行集中管理的过程‌，其核心在于隐藏内部实现细节，仅通过接口与外界交互。主要作用包括：‌</p><ul><li>*数据保护‌：*通过访问权限控制，如 private、protected 限制外部直接修改属性；‌‌‌‌‌</li><li>*接口标准化‌：*提供统一的方法调用入口，如 getter、setter 控制属性访问；‌‌‌</li><li>*模块化设计‌：*将同一类功能封装到同一对象中。</li></ul><p><strong>继承</strong>通过父子类关系实现代码复用和扩展‌，其特点包括：‌</p><ul><li>*子类复用父类功能‌：*子类可直接使用父类的公共属性和方法；‌‌‌‌‌</li><li>*层级扩展能力‌：*子类可新增特性或重写父类方法，如子类用 extends 继承父类并添加特有属性；‌‌‌</li><li>*访问规则约束‌：*父类私有成员（private）不可被子类继承，保证封装性。‌‌‌</li></ul><p><strong>多态</strong>通过统一的接口实现不同类型的差异化行为‌，具体表现为：‌</p><ul><li>*动态绑定‌：*父类引用指向子类对象；‌‌‌</li><li>*方法重写与重载‌：*子类覆写父类方法（重写）或同一类中同名不同参方法（重载）；‌‌‌‌‌</li><li>*灵活性增强‌：*同一方法在不同子类中表现不同。‌</li></ul><h2 id="什么是泛型？为什么要使用泛型？">什么是泛型？为什么要使用泛型？</h2><p>泛型，即**“参数化类型”**。泛型的出现是为了<em>统一集合当中的数据类型</em>。可<em>在编译阶段约束操作的数据类型，并进行检查</em><br>**参数化类型：**在方法定义时，<em>将方法签名中的形参数据类型设置为参数</em>（可称之为类型参数：尖括号 &lt;&gt; 中的泛型标识，用于指代任何数据类型），调用该方法时再从外部传入一个具体的数据类型和变量。<br>**泛型的本质：**<em>将类型参数化</em>。泛型使用过程中，数据类型被设置为一个参数，<strong>使用时从外部传入一个数据类型</strong>；而一旦传入了具体的数据类型后，<strong>传入变量（实参）的数据类型若不匹配，编译器就会直接报错</strong>。这种参数化类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p>**细节：**不能写基本数据类型；指定泛型具体类型后，传递数据时可传该类型和其子类类型；若不写泛型，默认是Object<br>**泛型标识：**是任意设置的，Java 常见泛型标识及其代表含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T ：代表一般的任何类。</span><br><span class="line">E ：代表 Element 元素的意思，或者 Exception 异常的意思。</span><br><span class="line">K ：代表 Key 的意思。</span><br><span class="line">V ：代表 Value 的意思，通常与 K 一起配合使用。</span><br><span class="line">S ：代表 Subtype 的意思。</span><br></pre></td></tr></table></figure><p>**使用场景：**定义类、方法、接口的时候，若类型不确定，可定义泛型；<em>若类型不确定，但知道继承体系，可用泛型通配符 ？</em><br><strong>泛型不具备继承性，但是数据具备继承性</strong></p>]]></content>
    
    
    <summary type="html">面向对象编程</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="OOP" scheme="https://southernfish.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>对象拷贝</title>
    <link href="https://southernfish.github.io/2025/06/19/java-object-copy/"/>
    <id>https://southernfish.github.io/2025/06/19/java-object-copy/</id>
    <published>2025-06-19T06:30:36.000Z</published>
    <updated>2025-06-21T08:05:35.151Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录关于Java中对象拷贝的问题</p><h2 id="为什么要使用克隆？">为什么要使用克隆？</h2><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以**当需要一个新的对象来保存当前对象的“状态”**就靠克隆方法了。</p><h2 id="如何实现对象克隆？">如何实现对象克隆？</h2><p>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过<strong>对象的序列化和反序列化实现克隆</strong>，可以实现真正的深度克隆。</p><h2 id="深拷贝和浅拷贝区别是什么？">深拷贝和浅拷贝区别是什么？</h2><p>**浅克隆：**当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br>**深克隆：**除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>]]></content>
    
    
    <summary type="html">对象拷贝</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Object" scheme="https://southernfish.github.io/tags/Object/"/>
    
  </entry>
  
</feed>
