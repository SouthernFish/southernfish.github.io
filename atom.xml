<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Southern Fish</title>
  
  
  <link href="https://southernfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://southernfish.github.io/"/>
  <updated>2025-06-24T14:24:28.354Z</updated>
  <id>https://southernfish.github.io/</id>
  
  <author>
    <name>Southern Fish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java的加密方式</title>
    <link href="https://southernfish.github.io/2025/06/24/java/java-encription/"/>
    <id>https://southernfish.github.io/2025/06/24/java/java-encription/</id>
    <published>2025-06-24T09:53:36.000Z</published>
    <updated>2025-06-24T14:24:28.354Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，加密英文文本通常涉及到使用加密算法，比如对称加密（如AES）或非对称加密（如RSA）。本文整理了几种java常用的几种加密方法。本文转载自：<a href="https://blog.csdn.net/wa_ka_ka/article/details/148293941">Java常用加密方式</a></p><h1 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h1><ul><li><strong>对称加密：</strong>指加密和解密的密钥相同，优点就是加解密的效率高且易于实现。</li><li><strong>非对称加密：</strong>指加密和解密的密钥不相同，也称为公私要加密。</li><li><strong>不可逆加密：</strong>特征就是加密过程不需要密钥，并且加密后的数据不能被解密，只能输入同样的数据并且经过同样的不可逆加密算法才能获取同样的加密数据。</li></ul><h1 id="加密算法的应用"><a href="#加密算法的应用" class="headerlink" title="加密算法的应用"></a>加密算法的应用</h1><ul><li><strong>数字签名：</strong>进行身份认证和数据完整性验证，主要用到了非对称密钥加密技术与数字摘要技术。</li><li><strong>数字证书：</strong>主要用来确保数字签名是安全有效的，数字证书由独立的证书发行机构发布。数字证书各不相同，每种证书可提供不同级别的可信度，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息。</li><li><strong>MD5：</strong>对用户密码进行加密并进行保存。</li><li><strong>网络数据加密：</strong>保障传输的数据安全，即使被截获报文，在没有密匙的情况下也无法得知报文真实内容。</li><li><strong>SSL协议：</strong>在<strong>握手阶段使用的是非对称加密</strong>，在<strong>传输阶段使用的是对称加密</strong>，即在SSL上传送的数据是使用对称密钥加密的。同时HTTPS也是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证（确认客户端连接的目标主机是否是真实正确的主机）的网络协议。</li></ul><h1 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h1><ul><li><strong>优点：</strong>算法对消息双方公开、计算量小、加解密速度快、效率高。</li><li><strong>缺点：</strong>在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。如果一方的秘钥被泄露，那么加密信息就会被破解。</li></ul><h2 id="DES介绍"><a href="#DES介绍" class="headerlink" title="DES介绍"></a>DES介绍</h2><p>DES全称为<code>Data Encryption Standard</code>，即<strong>数据加密标准</strong>，是一种<strong>使用密钥加密的<code>块算法</code><strong>，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（<code>FIPS</code>），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。但是近些年使用越来越少，因为</strong>DES使用56位密钥</strong>，以现代计算能力，24小时内即可被破解。DES加密和解密过程中，**密钥长度都必须是<code>8的倍数</code>**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DESHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String dataSource, String password)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// DES算法要求有一个可信任的随机数源</span></span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="type">DESKeySpec</span> <span class="variable">desKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(password.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 创建一个密钥工厂，然后用它对desKey进行转换</span></span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyFactory.generateSecret(desKey);</span><br><span class="line">        <span class="comment">// Cipher对象实际完成加密操作</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        <span class="comment">// 用密钥初始化Cipher对象，ENCRYPT_MODE用于将Cipher初始化为加密模式的常量</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,secretKey,random);</span><br><span class="line">        <span class="comment">// 正式对数据进行加密操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(dataSource.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decrypt</span><span class="params">(String src, String password)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="type">DESKeySpec</span> <span class="variable">desKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(password.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyFactory.generateSecret(desKey);</span><br><span class="line">        <span class="comment">// Cipher对象实际完成解密操作</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE,secretKey,random);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(src.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加解密测试:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DESTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">DESHelper</span> <span class="variable">desHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESHelper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;原始数据：&quot;</span>+source);</span><br><span class="line">    <span class="type">byte</span>[] encryptData = desHelper.encrypt(source, <span class="string">&quot;1qaz2wsx&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;加密后数据：&quot;</span>+encryptData);</span><br><span class="line">    <span class="type">byte</span>[] decryptData = desHelper.decrypt(encryptData, <span class="string">&quot;1qaz2wsx&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;解密后数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(decryptData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IDEA介绍"><a href="#IDEA介绍" class="headerlink" title="IDEA介绍"></a>IDEA介绍</h2><ul><li>这种算法是在DES算法的基础上发展出来的，类似于<strong>三重DES</strong>。</li><li>发展IDEA也是因为感到DES具有密钥太短等缺点。</li><li><strong>DEA的密钥为128位</strong>，这么长的密钥在今后若干年内应该是安全的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDEAHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;IDEA&quot;</span>; <span class="comment">// 密钥算法</span></span><br><span class="line">    <span class="comment">// 加密、解密算法、工作模式、填充方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CIPHER_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;IDEA/ECB/ISO10126Padding&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥，只有bouncycastle支持</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 二进制密钥</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] initKey() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>()); <span class="comment">// 加入bouncyCastle支持</span></span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">kg</span> <span class="operator">=</span> KeyGenerator.getInstance(KEY_ALGORITHM);  <span class="comment">// 实例化密钥生成器</span></span><br><span class="line">        kg.init(<span class="number">128</span>); <span class="comment">// 初始化密钥生成器，IDEA要求密钥长度为128位</span></span><br><span class="line">        SecretKey secretKey=kg.generateKey(); <span class="comment">// 生成密钥</span></span><br><span class="line">        <span class="keyword">return</span> secretKey.getEncoded(); <span class="comment">// 获取二进制密钥编码形式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 二进制密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Key 密钥</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title function_">toKey</span><span class="params">(<span class="type">byte</span>[] key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key,KEY_ALGORITHM); <span class="comment">// 实例化DES密钥</span></span><br><span class="line">        <span class="keyword">return</span> secretKey; <span class="comment">// 生成密钥</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 加密后的数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] data,<span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>()); <span class="comment">// 加入bouncyCastle支持</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">k</span> <span class="operator">=</span> toKey(key); <span class="comment">// 还原密钥</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM); <span class="comment">// 实例化</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, k);  <span class="comment">// 初始化，设置为加密模式</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data); <span class="comment">// 执行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 解密后的数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] data,<span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>()); <span class="comment">// 加入bouncyCastle支持</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">k</span> <span class="operator">=</span> toKey(key); <span class="comment">// 还原密钥</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, k); <span class="comment">// 初始化，设置为解密模式</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data); <span class="comment">// 执行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加解密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">IDEATest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;原始数据：&quot;</span>+str);</span><br><span class="line">    <span class="type">byte</span>[] key = IDEAHelper.initKey(); <span class="comment">// 初始化密钥</span></span><br><span class="line">    System.out.println(<span class="string">&quot;密钥：&quot;</span>+ Base64.encodeBase64String(key));</span><br><span class="line">    <span class="type">byte</span>[] data = IDEAHelper.encrypt(str.getBytes(), key); <span class="comment">// 加密数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;加密后数据：&quot;</span>+Base64.encodeBase64String(data));</span><br><span class="line">    data=IDEAHelper.decrypt(data, key);</span><br><span class="line">    System.out.println(<span class="string">&quot;解密后数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h1><ul><li><strong>优点：</strong>非对称加密与对称加密相比其安全性更好，只要私钥不泄露，很难被破解。</li><li><strong>缺点：</strong>加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</li></ul><h2 id="RSA介绍"><a href="#RSA介绍" class="headerlink" title="RSA介绍"></a>RSA介绍</h2><p>RSA是目前最有影响力和最常用的<strong>公钥加密算法</strong>。它能够抵抗到目前为止已知的绝大多数密码攻击，<strong>已被ISO推荐为公钥数据加密标准</strong>。<strong>RSA公开密钥密码体制的原理是：</strong>根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RSAHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SIGNATURE_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;MD5withRSA&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PUBLIC_KEY</span> <span class="operator">=</span> <span class="string">&quot;RSAPublicKey&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">&quot;RSAPrivateKey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptBASE64(String key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.decodeBase64(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptBASE64</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥对信息生成数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sign</span><span class="params">(<span class="type">byte</span>[] data, String privateKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 解密由base64编码的私钥</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(privateKey);</span><br><span class="line">        <span class="comment">// 构造PKCS8EncodedKeySpec对象</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="comment">// KEY_ALGORITHM 指定的加密算法</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">// 取私钥匙对象</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">priKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 用私钥对信息生成数字签名</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        signature.initSign(priKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(signature.sign());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sign 数字签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 校验成功返回true 失败返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(<span class="type">byte</span>[] data, String publicKey, String sign)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 解密由base64编码的公钥</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(publicKey);</span><br><span class="line">        <span class="comment">// 构造X509EncodedKeySpec对象</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="comment">// KEY_ALGORITHM 指定的加密算法</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">// 取公钥匙对象</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">pubKey</span> <span class="operator">=</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        signature.initVerify(pubKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line">        <span class="comment">// 验证签名是否正常</span></span><br><span class="line">        <span class="keyword">return</span> signature.verify(decryptBASE64(sign));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPrivateKey(<span class="type">byte</span>[] data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得私钥</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 对数据解密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPrivateKey(String data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> decryptByPrivateKey(decryptBASE64(data), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用公钥解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPublicKey(<span class="type">byte</span>[] data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得公钥</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">// 对数据解密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用公钥加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encryptByPublicKey(String data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对公钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得公钥</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">// 对数据加密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用私钥加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encryptByPrivateKey(<span class="type">byte</span>[] data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对密钥解密</span></span><br><span class="line">        <span class="type">byte</span>[] keyBytes = decryptBASE64(key);</span><br><span class="line">        <span class="comment">// 取得私钥</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(keyBytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        <span class="type">Key</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">// 对数据加密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPrivateKey</span><span class="params">(Map&lt;String, Key&gt; keyMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> (Key) keyMap.get(PRIVATE_KEY);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPublicKey</span><span class="params">(Map&lt;String, Key&gt; keyMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> keyMap.get(PUBLIC_KEY);</span><br><span class="line">        <span class="keyword">return</span> encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Key&gt; <span class="title function_">initKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGen</span> <span class="operator">=</span> KeyPairGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line">        keyPairGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGen.generateKeyPair();</span><br><span class="line">        Map&lt;String, Key&gt; keyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">2</span>);</span><br><span class="line">        keyMap.put(PUBLIC_KEY, keyPair.getPublic());<span class="comment">// 公钥</span></span><br><span class="line">        keyMap.put(PRIVATE_KEY, keyPair.getPrivate());<span class="comment">// 私钥</span></span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加解密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RSATest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Map&lt;String, Key&gt; keyMap = initKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">publicKey</span> <span class="operator">=</span> getPublicKey(keyMap);</span><br><span class="line">    <span class="type">String</span> <span class="variable">privateKey</span> <span class="operator">=</span> getPrivateKey(keyMap);</span><br><span class="line">    System.out.println(<span class="string">&quot;公钥：&quot;</span> + publicKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;私钥：&quot;</span> + privateKey);</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;原始数据：&quot;</span> + src);</span><br><span class="line">    <span class="type">byte</span>[] encryptByPrivateKey = encryptByPrivateKey(src.getBytes(), privateKey);</span><br><span class="line">    <span class="type">byte</span>[] encryptByPublicKey = encryptByPublicKey(src, publicKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;私钥加密后数据&quot;</span> + encryptByPrivateKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;公钥加密后数据&quot;</span> + encryptByPublicKey);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> sign(encryptByPrivateKey, privateKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;数字签名：&quot;</span> + sign);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">verify</span> <span class="operator">=</span> verify(encryptByPrivateKey, publicKey, sign);</span><br><span class="line">    System.out.println(<span class="string">&quot;签名验证结果：&quot;</span> + verify);</span><br><span class="line">    <span class="type">byte</span>[] decryptByPublicKey = decryptByPublicKey(encryptByPrivateKey, publicKey);</span><br><span class="line">    <span class="type">byte</span>[] decryptByPrivateKey = decryptByPrivateKey(encryptByPublicKey, privateKey);</span><br><span class="line">    System.out.println(<span class="string">&quot;公钥解密私钥加密后的数据：&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(decryptByPublicKey));</span><br><span class="line">    System.out.println(<span class="string">&quot;私钥解密公钥加密后的数据：&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(decryptByPrivateKey));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不可逆算法"><a href="#不可逆算法" class="headerlink" title="不可逆算法"></a>不可逆算法</h1><h2 id="MD5介绍"><a href="#MD5介绍" class="headerlink" title="MD5介绍"></a>MD5介绍</h2><p>MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（也就是把一个任意长度的字节串变换成一定长的十六进制数字串）。主要有以下特点：</p><ol><li><strong>压缩性：</strong> 任意长度的数据，算出的MD5值长度都是固定的。</li><li><strong>容易计算：</strong> 从原数据计算出MD5值很容易。</li><li><strong>抗修改性：</strong> 对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li><strong>强抗碰撞：</strong> 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MD5Helper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String s)</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] md5Bytes = md5.digest(s.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> md5ToString(md5Bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将md5数组转化为16进制字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">md5ToString</span><span class="params">(<span class="type">byte</span>[] md5Bytes)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">hexValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; md5Bytes.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> md5Bytes[i] &amp; <span class="number">0Xff</span>;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">16</span>)&#123;</span><br><span class="line">                hexValue.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hexValue.append(Integer.toHexString(val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexValue.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MD5Test</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">    <span class="type">MD5Helper</span> <span class="variable">md5Helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MD5Helper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">src1</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src2</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;src1 加密后数据：&quot;</span> + md5Helper.encode(src1));</span><br><span class="line">    System.out.println(<span class="string">&quot;src2 加密后数据：&quot;</span> + md5Helper.encode(src2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SHA1介绍"><a href="#SHA1介绍" class="headerlink" title="SHA1介绍"></a>SHA1介绍</h2><p>对于长度小于<code>2^64位</code>的消息，SHA1会产生<strong>一个160位(40个字符)的消息摘要</strong>。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。SHA1有如下<strong>特性</strong>：</p><ul><li>不可以从消息摘要中复原信息；</li><li>两个不同的消息不会产生同样的消息摘要，(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SHA1Helper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String str)</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == str || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="type">char</span>[] hexDigits = &#123; <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span> &#125;;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">mdTemp</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA1&quot;</span>); <span class="comment">// 创建SHA1算法消息摘要对象</span></span><br><span class="line">        mdTemp.update(str.getBytes(StandardCharsets.UTF_8)); <span class="comment">// 使用指定的字节数组更新摘要</span></span><br><span class="line">        <span class="type">byte</span>[] md = mdTemp.digest(); <span class="comment">// 生成hash值的字节数组</span></span><br><span class="line">        <span class="comment">// SHA1算法生成信息摘要的关键过程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> md.length;</span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[j*<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">byte0</span> <span class="operator">=</span> md[i];</span><br><span class="line">            buf[k++] = hexDigits[byte0 &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>];</span><br><span class="line">            buf[k++] = hexDigits[byte0 &amp; <span class="number">0xf</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SHA1Test</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">    <span class="type">SHA1Helper</span> <span class="variable">sha1Helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SHA1Helper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">src1</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src2</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;src1 加密后数据：&quot;</span> + sha1Helper.encode(src1));</span><br><span class="line">    System.out.println(<span class="string">&quot;src2 加密后数据：&quot;</span> + sha1Helper.encode(src2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HMAC-介绍"><a href="#HMAC-介绍" class="headerlink" title="HMAC 介绍"></a>HMAC 介绍</h2><p>HMAC 是密钥相关的<strong>哈希运算消息认证码</strong>（<code>Hash-based Message Authentication Code</code>），HMAC 运算利用 <strong>哈希算法</strong> (MD5、SHA1 等)，<strong>以 <code>一个密钥 和 一个消息</code> 为输入，生成一个 <code>消息摘要</code> 作为 输出。</strong>HMAC 发送方 和 接收方 都有的 key 进行计算，而没有该 key 的第三方，则 无法计算 出正确的 散列值，这样就可以 防止数据被篡改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HMACHelper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mac mac;</span><br><span class="line">    <span class="comment">// MAC算法可选以下多种算法：HmacMD5/HmacSHA1/HmacSHA256/HmacSHA384/HmacSHA512</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_MAC</span> <span class="operator">=</span> <span class="string">&quot;HmacMD5&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HMACHelper</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(StandardCharsets.UTF_8), KEY_MAC);</span><br><span class="line">        mac = Mac.getInstance(secretKey.getAlgorithm());</span><br><span class="line">        mac.init(secretKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sign</span><span class="params">(String content)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(mac.doFinal(content.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String signature, String content)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] result = mac.doFinal(content.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(result, signature.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加密测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HMACTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HMACHelper</span> <span class="variable">hmacHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HMACHelper</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;满天星辰不及你！&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] signature = hmacHelper.sign(src);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> hmacHelper.verify(signature, src);</span><br><span class="line">    System.out.println(<span class="string">&quot;src 生成数字签名：&quot;</span> + signature);</span><br><span class="line">    System.out.println(<span class="string">&quot;签名验证结果：&quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在Java中，加密英文文本通常涉及到使用加密算法，比如对称加密（如AES）或非对称加密（如RSA）。本文整理了几种java常用的几种加密方法。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://southernfish.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>超文本传输协议HTTP、HTTPS</title>
    <link href="https://southernfish.github.io/2025/06/24/framwork/http-and-https/"/>
    <id>https://southernfish.github.io/2025/06/24/framwork/http-and-https/</id>
    <published>2025-06-24T07:06:36.000Z</published>
    <updated>2025-06-24T14:24:28.352Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理了一些关于HTTP和HTTPS的相关内容。‌ 参考文章链接： <a href="https://blog.csdn.net/molangmolang/article/details/147905987">http和https的区别？（详细图文讲解）</a></p><h1 id="什么是-HTTP、HTTPS"><a href="#什么是-HTTP、HTTPS" class="headerlink" title="什么是 HTTP、HTTPS"></a>什么是 HTTP、HTTPS</h1><p><code>HTTP</code>（超文本传输协议，<code>Hypertext Transfer Protocol</code>）是一种用于<strong>分布式、协作式、超媒体信息系统</strong>的应用层协议。它允许客户端（如浏览器）与服务器之间进行通信，以请求和传输网页、图片、视频等资源。HTTP <strong>基于请求-响应模型</strong>，客户端发送请求到服务器，服务器处理请求后返回响应。</p><p><code>HTTPS</code>（安全超文本传输协议，<code>Hypertext Transfer Protocol Secure</code>）是 HTTP 的安全版本，通过在 HTTP 的基础上添加 <code>SSL/TLS（安全套接字层/传输层安全性）</code>协议来实现数据加密和安全传输。HTTPS 不仅能够传输数据，还能<strong>确保数据的机密性、完整性和身份验证，防止数据在传输过程中被窃取或篡改</strong>。</p><p> HTTP 在传输敏感信息（如用户登录信息、金融交易数据等）时存在较大的安全隐患，容易<strong>被中间人攻击、数据泄露</strong>等问题所困扰。为了解决这些问题，HTTPS 应运而生。它通过加密技术保护数据传输过程中的隐私和完整性，同时通过数字证书验证服务器的身份，确保用户与合法的服务器进行通信。此外，搜索引擎也倾向于优先推荐使用 HTTPS 的网站。</p><hr><h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>HTTP 是一种<strong>基于请求-响应模型的应用层协议</strong>，主要用于客户端（如浏览器）与服务器之间的通信。基本原理可概括为以下步骤：</p><ul><li> <strong>客户端发起请求：</strong>客户端通过浏览器或其他工具向服务器发送一个 HTTP 请求。请求中包含请求方法（如 GET、POST、PUT、DELETE 等）、请求的资源路径（URL）、HTTP 版本以及一系列<strong>请求头信息</strong>（如<code>Host</code>、<code>User-Agent</code>、<code>Accept</code>等）。</li><li><strong>服务器处理请求：</strong>服务器接收到请求后，根据请求方法和资源路径解析请求内容，并调用相应的应用程序或服务来处理请求。</li><li><strong>服务器返回响应：</strong>服务器处理完请求后，生成一个 HTTP 响应并发送回客户端。响应中包含 <strong>HTTP 状态码</strong>（如 200 表示成功，404 表示未找到等）、<strong>响应头信息</strong>（如<code>Content-Type</code>、<code>Content-Length</code>等）以及<strong>响应体</strong>（如网页内容、图片数据等）。</li><li><strong>客户端接收响应：</strong>客户端接收到服务器的响应后，解析响应内容并将其呈现给用户（如显示网页内容）。</li></ul><p>HTTP 协议<strong>基于无连接和无状态的通信方式</strong>，每次请求和响应完成后，连接即被关闭，服务器不会保存客户端的任何状态信息。这种设计使得 HTTP 协议简单高效，适合大规模的分布式网络应用。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li><strong>建立连接</strong><ol><li>客户端通过 <code>TCP/IP</code> 协议与服务器建立连接。默认情况下，HTTP 使用端口号 <code>80</code>。</li><li>客户端向服务器发送一个 TCP 连接请求，服务器接受连接后，双方建立一个可靠的 TCP 连接。</li></ol></li><li><strong>发送请求</strong><ol><li>客户端通过建立的 TCP 连接向服务器发送 HTTP 请求。请求由请求行、请求头和请求体组成。</li><li>请求行包含请求方法、资源路径和 HTTP 版本号，例如：<code>GET /index.html HTTP/1.1</code>。</li><li>请求头包含客户端的一些信息：<code>Host</code>（目标服务器地址）、<code>User-Agent</code>（客户端类型）、<code>Accept</code>（可接受的响应类型）等。</li><li>请求体（可选）包含客户端发送给服务器的数据，如表单数据、文件上传等。</li></ol></li><li><strong>服务器处理请求</strong><ol><li>服务器接收到客户端的请求后，解析请求行和请求头，确定请求的资源路径和方法。</li><li>根据请求方法和资源路径，服务器调用相应的应用程序或服务来处理请求。</li><li>如果请求方法是 GET，服务器会查找请求的资源并返回内容；如果是 POST，服务器会处理客户端提交的数据并返回结果。</li></ol></li><li><strong>返回响应</strong><ol><li>服务器处理完请求后，生成一个 HTTP 响应并发送回客户端。</li><li>响应由状态行、响应头和响应体组成。</li><li>状态行包含 HTTP 版本号、状态码和状态消息，例如：<code>HTTP/1.1 200 OK</code>。</li><li>响应头包含服务器的一些信息，如<code>Content-Type</code>（响应内容类型）、<code>Content-Length</code>（响应体长度）等。</li><li>响应体包含服务器返回的数据，如网页内容、图片数据等。</li></ol></li><li><strong>关闭连接</strong><ol><li>客户端接收到服务器的响应后，解析响应内容并将其呈现给用户。</li><li>一旦响应处理完成，客户端和服务器之间的 TCP 连接被关闭。</li></ol></li></ol><h2 id="特点与优势"><a href="#特点与优势" class="headerlink" title="特点与优势"></a>特点与优势</h2><ol><li><strong>简单高效</strong><ol><li>HTTP 协议的设计简洁明了，易于理解和实现。它基于文本格式，便于调试和开发。</li><li>HTTP 的无状态特性使每个请求和响应都独立，服务器不需要保存客户端的状态信息，提高了服务器的处理能力和扩展性。</li></ol></li><li><strong>灵活通用</strong><ol><li>HTTP 支持多种请求方法（如 GET、POST、PUT、DELETE 等），能够满足不同的应用场景。</li><li>它可以传输多种类型的数据，如文本、图片、视频等，适用于各种网络应用。</li></ol></li><li><strong>广泛支持</strong><ol><li>HTTP 是互联网上最广泛使用的协议之一，几乎所有浏览器和服务器都支持 HTTP 协议。</li><li>它与多种其他协议（如 TCP/IP、DNS 等）无缝集成，能够轻松构建复杂的网络应用。</li></ol></li><li><strong>可扩展性</strong><ol><li>HTTP 协议通过请求头和响应头提供了丰富的扩展机制，允许开发者添加自定义的头信息来实现特定的功能。</li><li>它还支持多种内容编码（如 gzip 压缩）和缓存机制，能够优化网络传输效率和性能。</li></ol></li><li><strong>兼容性强</strong><ol><li>HTTP 协议版本更新（如从 HTTP/1.1 到 HTTP/2）保持了向后兼容性，使旧的客户端和服务器能够无缝迁移到新的协议版本。</li><li>它还支持多种编程语言和开发框架，方便开发者进行开发和部署。</li></ol></li></ol><hr><h1 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h1><h2 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h2><p>HTTPS 是 HTTP 协议的安全版本，通过在 HTTP 的基础上添加 SSL/TLS（安全套接字层/传输层安全性）协议来实现数据的安全传输。其核心原理可概括为以下几个方面：</p><ol><li><p><strong>加密传输</strong></p><p>HTTPS 使用 SSL/TLS 协议对传输的数据进行加密。加密过程包括<strong>对称加密和非对称加密</strong>两种方式。在握手过程中，客户端和服务器首先使用<strong>非对称加密（如 RSA 或 ECC）交换密钥</strong>，然后使用<strong>对称加密（如 AES）对后续的通信数据进行加密</strong>。这种加密方式既保证了密钥交换的安全性，又提高了数据传输的效率。</p></li><li><p><strong>身份验证</strong></p><p>HTTPS 通过数字证书来验证服务器的身份。服务器需要从权威的证书颁发机构（CA）<strong>获取数字证书</strong>，并在握手过程中将证书发送给客户端。客户端通过<strong>验证证书的有效性</strong>（包括证书的颁发机构、有效期、域名等信息）来确认服务器的身份，防止中间人攻击。</p></li><li><p><strong>数据完整性</strong></p><p>HTTPS 使用<strong>哈希算法</strong>（如 <code>SHA-256</code>）对传输的数据进行完整性校验。在数据传输过程中，客户端和服务器会生成数据的哈希值，并在接收数据时验证哈希值是否一致。如果数据在传输过程中被篡改，哈希值将不匹配，从而确保数据的完整性。</p></li><li><p><strong>协议层级</strong></p><p>HTTPS 在 <code>TCP 层之上、HTTP 层之下</code>工作。它通过 SSL/TLS 协议封装 HTTP 数据，使得 HTTP 协议在传输过程中得到保护。默认情况下，HTTPS 使用端口号 <code>443</code>。</p></li></ol><h2 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li><strong>建立连接</strong><ol><li>客户端通过 TCP/IP 协议与服务器建立连接。默认情况下，HTTPS 使用端口号 443。</li><li>客户端向服务器发送一个 TCP 连接请求，服务器接受连接后，双方建立一个可靠的 TCP 连接。</li></ol></li><li><strong>SSL/TLS 握手</strong><ol><li>客户端向服务器发送一个<code>ClientHello</code>消息，包含客户端支持的 SSL/TLS 版本、加密算法列表、随机数等信息。</li><li>服务器收到<code>ClientHello</code>消息后，选择一种加密算法，并向客户端发送一个<code>ServerHello</code>消息，包含服务器选择的 SSL/TLS 版本、加密算法、随机数等信息。</li><li>服务器向客户端发送自己的数字证书（包括公钥），客户端验证证书的有效性。</li><li>客户端生成一个预主密钥（<code>Pre-Master Secret</code>），并使用服务器的公钥对其进行加密，然后发送给服务器。</li><li>服务器使用自己的私钥解密预主密钥，客户端和服务器分别使用预主密钥和之前交换的随机数生成主密钥（<code>Master Secret</code>），用于后续的对称加密通信。</li><li>客户端和服务器分别发送<code>ChangeCipherSpec</code>消息和<code>Finished</code>消息，表示握手完成，开始使用对称加密进行通信。</li></ol></li><li><strong>发送请求和响应</strong><ol><li>客户端通过建立的安全连接向服务器发送 HTTP 请求，请求内容经过 SSL/TLS 加密。</li><li>服务器接收到加密的请求后，解密请求内容并处理请求，然后将响应内容加密后发送回客户端。</li><li>客户端接收到加密的响应后，解密响应内容并将其呈现给用户。</li></ol></li><li><strong>关闭连接</strong><ol><li>客户端或服务器可以随时发送<code>CloseNotify</code>消息来关闭连接。</li><li>一旦连接关闭，<code>SSL/TLS</code> 会话结束。</li></ol></li></ol><h2 id="特点与优势-1"><a href="#特点与优势-1" class="headerlink" title="特点与优势"></a>特点与优势</h2><ol><li><p><strong>数据加密</strong></p><p>HTTPS 对传输的数据进行加密，防止数据在传输过程中被窃取或篡改。即使攻击者能够截获数据，也无法解密其内容，从而保护了用户的隐私和敏感信息。</p></li><li><p><strong>身份验证</strong></p><p>HTTPS 通过数字证书验证服务器身份，确保客户端与合法的服务器进行通信。这有效防止了中间人攻击，提高了网络通信的安全性。</p></li><li><p><strong>数据完整性</strong></p><p>HTTPS 使用哈希算法对数据进行完整性校验，确保数据在传输过程中未被篡改。如果数据被篡改，客户端将拒绝接收数据，从而保障了数据的完整性。</p></li><li><p><strong>兼容性强</strong></p><p>HTTPS 是基于 HTTP 协议的扩展，兼容现有的 HTTP 应用。大多数现代浏览器和服务器都支持 HTTPS，开发者可以轻松地将现有的 HTTP 应用迁移到 HTTPS。</p></li><li><p><strong>搜索引擎优化（SEO）</strong></p><p>搜索引擎（如 Google）倾向于优先推荐使用 HTTPS 的网站，因为 HTTPS 提供了更高的安全性。这有助于提升网站在搜索引擎结果页面（SERP）中的排名，增加网站的流量。</p></li><li><p><strong>提升用户信任</strong></p><p>使用 HTTPS 的网站在浏览器地址栏中会显示一个绿色的锁形图标，表明网站是安全的。这有助于提升用户对网站的信任，增加用户在网站上的停留时间和交互行为。</p></li><li><p><strong>支持 HTTP/2</strong></p><p>HTTPS 是 HTTP/2 的基础，HTTP/2 提供了更高的性能优化，如多路复用、服务器推送等。使用 HTTPS 可以更好地支持 HTTP/2 的特性，提升网站的加载速度和用户体验。</p></li></ol><hr><h1 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h1><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><ol><li><p><strong>数据加密</strong><br><strong>HTTP：</strong>HTTP 是<strong>明文传输协议</strong>，数据在客户端和服务器之间传输时未经过加密。这意味着传输的数据（如用户名、密码、信用卡信息等）可能会被网络中的中间设备（如路由器、代理服务器）或恶意攻击者截获。<br><strong>HTTPS：</strong>HTTPS 在 HTTP 的基础上引入了 <strong>SSL/TLS 加密机制</strong>。在数据传输过程中，客户端和服务器之间通过<strong>非对称加密交换密钥</strong>，然后使用<strong>对称加密对数据进行加密</strong>。即使数据被截获，攻击者也无法解密其内容，从而有效保护了数据的机密性。</p></li><li><p><strong>数据完整性</strong><br><strong>HTTP：</strong>HTTP 协议本身<strong>不提供数据完整性校验机制</strong>。数据在传输过程中可能会被篡改，而客户端无法检测到这种篡改。<br><strong>HTTPS：</strong>HTTPS 使用<strong>哈希算法</strong>（如 SHA-256）对传输的数据进行完整性校验。在数据传输过程中，客户端和服务器会生成数据的哈希值，并<strong>在接收数据时验证哈希值是否一致</strong>。如果数据在传输过程中被篡改，哈希值将不匹配，从而确保数据的完整性。</p></li><li><p><strong>身份验证</strong><br><strong>HTTP：</strong>HTTP 协议<strong>不提供身份验证机制</strong>，无法验证服务器或客户端的身份。攻击者可以通过中间人攻击（<code>MITM</code>）伪装成合法的服务器或客户端，窃取用户数据。<br><strong>HTTPS：</strong>HTTPS 使用<strong>数字证书</strong>来验证服务器的身份。服务器需要从权威的证书颁发机构（<code>CA</code>）获取数字证书，并在握手过程中将证书发送给客户端。<strong>客户端通过验证证书的有效性</strong>（包括证书的颁发机构、有效期、域名等信息）来确认服务器的身份，从而防止中间人攻击。</p></li></ol><h2 id="协议基础"><a href="#协议基础" class="headerlink" title="协议基础"></a>协议基础</h2><ol><li><p><strong>使用的协议</strong><br><strong>HTTP：</strong>HTTP 是一种<strong>应用层协议</strong>，基于 <code>TCP/IP</code> 协议栈工作。它主要用于客户端和服务器之间的数据传输。<br><strong>HTTPS：</strong>HTTPS 是 HTTP 的安全版本，通过在 HTTP 的基础上添加 <code>SSL/TLS 协议</code>来实现数据的安全传输。SSL/TLS 是一种<strong>传输层安全协议</strong>，用于加密数据并验证通信双方的身份。</p></li><li><p><strong>端口号</strong><br><strong>HTTP：</strong>HTTP 默认使用端口号 <code>80</code>。<br><strong>HTTPS：</strong>HTTPS 默认使用端口号 <code>443</code>。</p></li></ol><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ol><li><p><strong>加载速度</strong><br><strong>HTTP：</strong>HTTP 是明文传输，数据传输速度快，但安全性差。在没有加密开销的情况下，HTTP 的加载速度通常比 HTTPS 快。<br><strong>HTTPS：</strong>HTTPS 在数据传输过程中需要进行加密和解密操作，这会增加一定的计算开销，可能导致加载速度略慢。然而，随着硬件性能的提升和 SSL/TLS 协议的优化，这种性能差距已经逐渐缩小。此外，HTTPS 支持 HTTP/2 协议，HTTP/2 通过多路复用、服务器推送等技术可以显著提升页面加载速度。</p></li><li><p><strong>对服务器的影响</strong><br><strong>HTTP：</strong>HTTP 不涉及加密和解密操作，<strong>对服务器的计算资源要求较低</strong>。<br><strong>HTTPS：</strong>HTTPS 的加密和解密操作会<strong>增加服务器的计算开销</strong>，尤其是在高并发场景下。不过，现代服务器的硬件性能已经足够强大，能够较好地处理这些额外的负载。此外，使用硬件加速（如 <code>SSL 加速卡</code>）可以进一步减轻服务器的负担。</p></li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>HTTP 的适用场景</strong></p><ol><li><strong>非敏感信息传输：</strong>HTTP 适用于传输非敏感信息，如公开的网页内容、新闻资讯等。这些信息即使被截获也不会对用户或企业造成严重损失。</li><li><strong>低安全性需求的内部网络：</strong>在企业内部网络中，如果数据传输的安全性要求不高，可以使用 HTTP 来降低系统复杂性和成本。</li><li><strong>简单的信息查询：</strong>对于一些简单的信息查询服务，如天气预报、股票行情等，HTTP 是一个高效且经济的选择。</li></ol><p><strong>HTTPS 的适用场景</strong></p><ol><li><strong>电子商务网站：</strong>电子商务网站涉及用户敏感信息（如信用卡信息、个人身份信息等），须使用 HTTPS 保护用户隐私和数据安全。</li><li><strong>金融服务：</strong>银行、证券等金融服务机构需要使用 HTTPS 来确保交易数据的安全性和完整性，防止数据泄露和欺诈行为。</li><li><strong>个人隐私保护：</strong>涉及用户个人隐私的应用（如电子邮件、社交媒体、在线医疗等）需要使用 HTTPS 来保护用户的隐私。</li><li><strong>搜索引擎优化（SEO）：</strong>搜索引擎倾向于优先推荐使用 HTTPS 的网站，为了提升网站在搜索结果中的排名，建议使用 HTTPS。</li><li><strong>需要高安全性的企业应用：</strong>对于企业内部的敏感应用（如人力资源管理系统、财务系统等），使用 HTTPS 可以有效防止数据泄露和中间人攻击。</li></ol><h1 id="HTTP-和-HTTPS-的实际应用"><a href="#HTTP-和-HTTPS-的实际应用" class="headerlink" title="HTTP 和 HTTPS 的实际应用"></a>HTTP 和 HTTPS 的实际应用</h1><h2 id="HTTP-的常见应用"><a href="#HTTP-的常见应用" class="headerlink" title="HTTP 的常见应用"></a>HTTP 的常见应用</h2><ul><li><strong>网站浏览</strong><br>HTTP 是互联网上最早广泛应用的协议之一，广泛用于普通的网站浏览场景。许多新闻网站、博客、社交媒体平台等在早期都使用 HTTP 协议来传输网页内容。例如：<ul><li><strong>新闻网站：</strong>用户通过浏览器访问新闻网站时，HTTP 协议用于从服务器获取新闻文章、图片和视频等资源。这些内容通常是公开的，对安全性要求不高，因此 HTTP 能够高效地完成任务。</li><li><strong>博客平台：</strong>博客作者发布文章后，读者可以通过 HTTP 协议访问博客页面，查看文章内容。由于博客内容大多是公开分享的，HTTP 的简单性和高效性使其成为合适的选择。</li></ul></li><li><strong>简单信息查询</strong><br>HTTP 也常用于简单的信息查询服务，如天气预报、股票行情、公共信息查询等。这些服务的特点是：<ul><li><strong>数据公开性：</strong>查询的内容通常是公开的，不需要加密保护。例如，用户查询天气信息时，数据是公开的，对安全性要求不高。</li><li><strong>高效性：</strong>HTTP 的无状态特性和简单的请求-响应模型使其能够快速处理大量用户的查询请求，适合这类对性能要求较高的场景。</li></ul></li></ul><h2 id="HTTPS-的常见应用"><a href="#HTTPS-的常见应用" class="headerlink" title="HTTPS 的常见应用"></a>HTTPS 的常见应用</h2><ul><li><strong>电子商务</strong><br>电子商务网站是 HTTPS 应用的典型场景之一。在这些网站上，用户需要输入敏感信息，如信用卡号、地址、联系方式等。HTTPS 的加密机制能够确保这些信息在传输过程中不被窃取或篡改。例如：<ul><li><strong>在线购物平台：</strong>用户在购买商品时，需要输入支付信息和个人信息。HTTPS 通过加密这些数据，确保用户的隐私和交易安全。</li><li><strong>支付网关：</strong>支付网关是处理支付交易的核心环节，必须使用 HTTPS 来保护用户的支付信息。SSL/TLS 加密和数字证书验证机制能够有效防止中间人攻击，确保交易的完整性和安全性。</li></ul></li><li><strong>金融交易</strong><br>金融行业对数据安全的要求极高，因此 HTTPS 是金融交易的必备技术。银行、证券公司等金融机构通过 HTTPS 来保护用户的账户信息、交易记录和资金操作。例如：</li><li><ul><li><strong>网上银行：</strong>用户登录网上银行时，HTTPS 用于加密登录信息，防止密码被窃取。在进行转账、查询余额等操作时，HTTPS 确保数据的安全传输。</li><li><strong>证券交易：</strong>证券交易系统需要处理大量的敏感数据，如股票买卖订单、资金流向等。HTTPS 通过加密和身份验证机制，确保交易的安全性和合规性。</li></ul></li><li><strong>个人隐私保护</strong><br>许多涉及个人隐私的应用和服务都采用了 HTTPS 来保护用户数据。例如：<ul><li><strong>社交媒体平台：</strong>用户在社交媒体上分享个人信息、照片和消息时，HTTPS 确保这些数据在传输过程中不被泄露。例如，Facebook 和 Twitter 等平台都使用 HTTPS 来保护用户的隐私。</li><li><strong>在线医疗平台：</strong>在线医疗平台涉及用户的健康信息和医疗记录，这些信息非常敏感。HTTPS 通过加密和身份验证机制，确保用户的医疗数据在传输过程中不被窃取或篡改。</li><li><strong>电子邮件服务：</strong>许多电子邮件服务提供商（如 Gmail、Outlook 等）使用 HTTPS 来保护用户的邮件内容。HTTPS 确保用户在登录邮箱、发送和接收邮件时，数据的安全性和隐私性得到保障。</li></ul></li></ul><p>HTTP 和 HTTPS 在实际应用中各有其适用场景。<strong>HTTP 适用于对安全性要求不高、注重效率的场景，而 HTTPS 则是处理敏感数据和需要高安全性的场景的首选协议</strong>。</p>]]></content>
    
    
    <summary type="html">‌本文整理了一些关于HTTP和HTTPS的相关内容。‌</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="RestfulApi" scheme="https://southernfish.github.io/categories/Framwork/RestfulApi/"/>
    
    
    <category term="RestfulApi" scheme="https://southernfish.github.io/tags/RestfulApi/"/>
    
  </entry>
  
  <entry>
    <title>数据库引擎InnoDB</title>
    <link href="https://southernfish.github.io/2025/06/24/database/database-innodb/"/>
    <id>https://southernfish.github.io/2025/06/24/database/database-innodb/</id>
    <published>2025-06-24T05:34:36.000Z</published>
    <updated>2025-06-24T14:24:28.351Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB，是<a href="https://baike.baidu.com/item/MySQL/471251?fromModule=lemma_inlink">MySQL</a>的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/1239260?fromModule=lemma_inlink">数据库引擎</a>之一，现为MySQL的默认<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/8969956?fromModule=lemma_inlink">存储引擎</a>，为[MySQL AB](<a href="https://baike.baidu.com/item/MySQL">https://baike.baidu.com/item/MySQL</a> AB/2620844?fromModule=lemma_inlink)发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由<a href="https://baike.baidu.com/item/%E7%94%B2%E9%AA%A8%E6%96%87%E5%85%AC%E5%8F%B8/430115?fromModule=lemma_inlink">甲骨文公司</a>并购。与传统的ISAM与<a href="https://baike.baidu.com/item/MyISAM/0?fromModule=lemma_inlink">MyISAM</a>相比，InnoDB的最大特色就是支持了<a href="https://baike.baidu.com/item/ACID/10738?fromModule=lemma_inlink">ACID</a>兼容的<a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1/5945882?fromModule=lemma_inlink">事务</a>（Transaction）功能，类似于<a href="https://baike.baidu.com/item/PostgreSQL/530240?fromModule=lemma_inlink">PostgreSQL</a>。InnoDB采用<a href="https://baike.baidu.com/item/%E5%8F%8C%E8%BD%A8%E5%88%B6/8309993?fromModule=lemma_inlink">双轨制</a>授权，一个是<a href="https://baike.baidu.com/item/GPL/0?fromModule=lemma_inlink">GPL</a>授权，另一个是专有软件授权。</p><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h2 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h2><p><strong><code>InnoDB</code>索引是聚簇索引</strong>，MyISAM索引是非聚簇索引。<br><code>InnoDB</code>的<strong>主键索引的叶子节点存储着行数据</strong>，因此主键索引非常高效。<br><strong><code>MyISAM</code>索引的叶子节点存储的是行数据地址</strong>，需要再寻址一次才能得到数据。<br><strong>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据</strong>，因此查询时做到覆盖索引会非常高效。</p><h2 id="MySQL-InnoDB存储引擎的特点"><a href="#MySQL-InnoDB存储引擎的特点" class="headerlink" title="MySQL InnoDB存储引擎的特点"></a>MySQL InnoDB存储引擎的特点</h2><p><strong>事务支持：</strong>InnoDB支持ACID事务属性。<br><strong>崩溃恢复</strong>：InnoDB会<strong>将数据写入到磁盘上的日志文件</strong>中，即使在系统崩溃的情况下，也能通过这些日志文件恢复数据。<br><strong>MVCC (多版本并发控制)：</strong>InnoDB使用多版本并发控制，这允许更高的并发性。<br><strong>外键约束：</strong>InnoDB支持外键约束，这对于维护数据库的引用完整性非常有用。<br><strong>行级锁定：</strong>与表级锁定相比，InnoDB<strong>支持行级锁定，提供了更高的并发性能</strong>。<br><strong>自适应哈希索引：</strong>InnoDB会<strong>自动为频繁访问的热点数据创建哈希索引，以提高查询速度</strong>。</p><h2 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。<br>在InnoDB存储引擎中，主键索引是作为<strong>聚簇索引</strong>存在的，主键索引的<code>B+树</code>叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，只需要不断向后排列即可，如果是*<code>UUID</code>，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降*。<br>总之，在数据量大一些的情况下，用自增主键性能会好一些。<br>主键是聚簇索引，若没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个<strong>隐式的主键</strong>。</p><h2 id="如何使用InnoDB？"><a href="#如何使用InnoDB？" class="headerlink" title="如何使用InnoDB？"></a>如何使用InnoDB？</h2><p>在创建表时指定使用InnoDB存储引擎，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE example (</span><br><span class="line">    <span class="built_in">id</span> INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (<span class="built_in">id</span>)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h2 id="优化InnoDB性能的技巧"><a href="#优化InnoDB性能的技巧" class="headerlink" title="优化InnoDB性能的技巧"></a>优化InnoDB性能的技巧</h2><p><strong>配置<code>innodb_buffer_pool_size</code>：控制InnoDB缓存数据和索引的内存大小</strong>。通常设置为系统内存的50%-80%。<br><strong>调整<code>innodb_log_file_size</code>：增加日志文件的大小可以减少日志磁盘写入次数</strong>，但需要确保磁盘I/O足够快。<br><strong>使用合适的索引：</strong>确保对查询进行优化的索引。<br><strong>监控和调整<code>innodb_io_capacity</code>：</strong>这个参数<strong>控制后台I/O操作的速率</strong>，需要根据实际的磁盘I/O性能进行调整。<br><strong>批量操作：</strong>大量插入、更新或删除操作时，尽量使用<strong>事务批量处理，减少对数据库的冲击</strong>。</p><h2 id="InnoDB常见问题及解决方案？"><a href="#InnoDB常见问题及解决方案？" class="headerlink" title="InnoDB常见问题及解决方案？"></a>InnoDB常见问题及解决方案？</h2><p><strong>性能问题：</strong>若发现InnoDB性能不佳，<strong>先检查是否有足够的内存分配给<code>innodb_buffer_pool_size</code>，以及磁盘I/O是否成为瓶颈</strong>。<br><strong>锁等待：</strong>高并发下，锁等待可能导致性能下降。可<strong>通过<code>SHOW ENGINE INNODB STATUS</code>查看锁等待情况</strong>，并考虑优化查询或增加索引。<br><strong>死锁：</strong>死锁是多个事务相互等待对方释放资源的情况。MySQL会检测到死锁并自动回滚其中一个事务以解除死锁。可以<strong>通过<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>表来诊断死锁</strong>。</p><hr><h1 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h1><p>MVCC全称<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">多版本并发控制</a>，是在并发访问数据库时对操作数据做多版本管理，避免因为写数据时要加写锁而阻塞读取数据的请求问题。</p><h2 id="InnoDB的MVCC实现原理"><a href="#InnoDB的MVCC实现原理" class="headerlink" title="InnoDB的MVCC实现原理"></a>InnoDB的MVCC实现原理</h2><p>MySQL <code>InnoDB</code> 存储引擎使用多版本并发控制（MVCC，<code>Multi-Version Concurrency Control</code>）来支持高并发环境下的读写操作，而不会互相阻塞。MVCC 允许在同一个时刻有多个事务对同一数据进行操作，而不会导致数据不一致。使用软性手段既要保证串行化隔离级别的安全性同时保证系统的整体性能和吞吐量。转载自文章 <a href="https://blog.csdn.net/carolineme/article/details/145860802">Innodb MVCC实现原理</a></p><ol><li><p><strong>事务版本号</strong></p><p>每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</p></li><li><p><strong>表格的隐藏列</strong></p><table><thead><tr><th>隐藏列名称</th><th>说明</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>记录操作该数据事务的事务ID；</td></tr><tr><td>DB_ROLL_PTR</td><td>指向上一个版本数据在undo log 里的位置指针；</td></tr><tr><td>DB_ROW_ID</td><td>隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</td></tr></tbody></table></li><li><p><strong>Undo log</strong></p><p>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。<strong>主要用途：</strong></p><ul><li><p>保证事务进行<code>rollback</code>时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p></li><li><p><strong>用于MVCC快照读的数据</strong>，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p></li></ul></li><li><p><strong>Read view</strong></p><p>在innodb 中每个事务开启后都会得到一个read_view。副本主要保存了当前<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020">数据库系统</a>中正处于活跃（没有commit）的事务的ID号，保存的是系统中当前不应该被本事务看到的其他事务id列表。<strong>Read view 的几个重要属性：</strong></p><table><thead><tr><th>属性名称</th><th>说明</th></tr></thead><tbody><tr><td>trx_ids</td><td>当前系统活跃(未提交)事务版本号集合</td></tr><tr><td>max_limit_id</td><td>创建当前read view 时“当前系统最大事务版本号+1”</td></tr><tr><td>min_limit_id</td><td>创建当前read view 时“系统正处于活跃事务最小版本号”</td></tr><tr><td>creator_trx_id</td><td>创建当前read view的事务版本号</td></tr></tbody></table><p><strong>Read view 匹配条件规则：</strong></p><ul><li>如果数据事务ID <code>trx_id &lt; min_limit_id</code>，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li><li>如果<code>trx_id&gt;= max_limit_id</code>，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li><li>如果 <code>min_limit_id =&lt;trx_id&lt; max_limit_id</code>，<strong>需要分3种情况讨论</strong>：<ul><li>如果<code>m_ids包含trx_id</code>，则代表Read View生成时刻，这个事务还未提交，但如果数据的<code>trx_id等于creator_trx_id</code>的话，表明数据是自己生成的，因此是可见的。</li><li>如果<code>m_ids包含trx_id</code>，并且<code>trx_id不等于creator_trx_id</code>，则Read View生成时，事务未提交，并且不是自己生产的，所以当前事务也是看不见的；</li><li>如果<code>m_ids不包含trx_id</code>，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。</li></ul></li></ul><p><code>READ_UNCOMMITTED</code> 级别的事务不会获取read view 副本；<code>RC(read commit)</code> 级别下同一个事务里面的每一次查询都会获得一个新的read view副本；<code>RR(重复读)</code>级别下的一个事务里只会获取一次read view副本，从而保证每次查询的数据都是一样的。</p></li></ol><h2 id="MVCC-Next-key-Lock-防止幻读"><a href="#MVCC-Next-key-Lock-防止幻读" class="headerlink" title="MVCC+Next-key-Lock 防止幻读"></a>MVCC+Next-key-Lock 防止幻读</h2><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><ol><li><p><strong>执行普通 select，此时会以 MVCC 快照读的方式读取数据</strong></p><ul><li><p>在快照读的情况下，RR 隔离级别只会在<strong>事务开启后的第一次查询生成 <code>Read View</code></strong> ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</p></li><li><p><strong>快照读</strong>是指读取数据时不是读取最新版本的数据，而是基于历史版本读取的一个快照信息（mysql读取undo log历史版本)</p></li></ul></li><li><p><strong>执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p><ul><li>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，<strong>就会产生幻读</strong>！</li><li>InnoDB 使用 <code>Next-key Lock</code> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。</li><li>当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的</li></ul></li></ol>]]></content>
    
    
    <summary type="html">‌InnoDB是为处理巨大数据量时的最大性能设计。InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。</summary>
    
    
    
    <category term="Database" scheme="https://southernfish.github.io/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://southernfish.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>大模型</title>
    <link href="https://southernfish.github.io/2025/06/24/large-model/large-model/"/>
    <id>https://southernfish.github.io/2025/06/24/large-model/large-model/</id>
    <published>2025-06-24T03:22:36.000Z</published>
    <updated>2025-06-24T14:24:28.355Z</updated>
    
    <content type="html"><![CDATA[<p>人工智能大模型（简称“大模型”）是指由<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/382460?fromModule=lemma_inlink">人工神经网络</a>构建的一类具有大量参数的人工智能模型。其通常先通过自监督学习或<a href="https://baike.baidu.com/item/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/9075473?fromModule=lemma_inlink">半监督学习</a>在海量数据上进行预训练，然后通过指令微调和人类对齐等方法进一步优化其性能和能力。大模型具有参数量大、训练数据大、计算资源大等特点，拥有解决通用任务、遵循人类指令、进行复杂推理等能力。器主要类别包括：<a href="https://baike.baidu.com/item/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/62884793?fromModule=lemma_inlink">大语言模型</a>、视觉大模型、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B/63122644?fromModule=lemma_inlink">多模态大模型</a>以及基础科学大模型等。目前，大模型已在多个领域得到广泛应用，包括<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/104812?fromModule=lemma_inlink">搜索引擎</a>、<a href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E4%BD%93/9446647?fromModule=lemma_inlink">智能体</a>、相关垂直产业及基础科学等领域，推动了各行业的智能化发展。</p><p>原文链接： <a href="https://zhuanlan.zhihu.com/p/1900212961517213051">大模型</a></p><h1 id="大模型"><a href="#大模型" class="headerlink" title="大模型"></a>大模型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>大模型</strong>（<code>Large Models</code>）通常指参数规模庞大（通常在十亿到万亿级别）的深度学习模型。这类模型通过在大规模数据集上进行训练，具备强大的泛化能力和复杂的任务处理能力，尤其在<strong>自然语言处理（NLP）、计算机视觉（CV）和多模态任务</strong>中表现突出。例如，<a href="https://zhida.zhihu.com/search?content_id=257103601&content_type=Article&match_order=1&q=GPT-3&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTA5NDIwMzEsInEiOiJHUFQtMyIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjI1NzEwMzYwMSwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.pRQ4bw78OW9OCPds9KYVAnts2vd5huIIdlV17yltino&zhida_source=entity">GPT-3</a>（1750亿参数）和<a href="https://zhida.zhihu.com/search?content_id=257103601&content_type=Article&match_order=1&q=PaLM&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTA5NDIwMzEsInEiOiJQYUxNIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjU3MTAzNjAxLCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.pY7El6LSXHn6ol368EhPM_k_HmIaxDphK8H0ACiazno&zhida_source=entity">PaLM</a>（5400亿参数）是典型的大模型。</p><h2 id="大模型和小模型的区别"><a href="#大模型和小模型的区别" class="headerlink" title="大模型和小模型的区别"></a>大模型和小模型的区别</h2><table><thead><tr><th>维度</th><th>大模型</th><th>小模型</th></tr></thead><tbody><tr><td>参数规模</td><td>十亿到万亿级（如GPT-3：175B）</td><td>百万到十亿级（如<a href="https://zhida.zhihu.com/search?content_id=257103601&content_type=Article&match_order=1&q=BERT&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTA5NDIwMzEsInEiOiJCRVJUIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjU3MTAzNjAxLCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.GgzgYV_OlNlMQ6Rk8on2UBVonjpddwn5kjEs0-wm-2k&zhida_source=entity">BERT</a>-base：110M）</td></tr><tr><td>训练数据</td><td>海量数据（TB级文本、图像等）</td><td>较小规模（GB级）</td></tr><tr><td>计算资源</td><td>需要分布式GPU/TPU集群，训练耗时数周至数月</td><td>单卡或少量GPU即可训练，耗时短</td></tr><tr><td>应用场景</td><td>通用任务（文本生成、复杂推理、多模态交互）</td><td>专用任务（分类、实体识别、轻量级部署）</td></tr><tr><td>部署成本</td><td>高昂（需云端算力支持，推理延迟高）</td><td>低成本（可嵌入手机、IoT设备）</td></tr><tr><td>能力特点</td><td>涌现能力（如零样本学习、上下文理解）</td><td>依赖任务微调，泛化能力有限</td></tr></tbody></table><h2 id="相关概念区分"><a href="#相关概念区分" class="headerlink" title="相关概念区分"></a><strong>相关概念区分</strong></h2><ul><li><strong>大模型（<code>Large Model</code>）：</strong>也称基础模型，即 <code>Foundation Model</code>，是指具有大量参数和复杂结构的机器学习模型，能够处理海量数据、完成各种复杂的任务，如<em>自然语言处理、计算机视觉、语音识别</em>等。</li><li>超大模型：超大模型是大模型的一个子集，它们的<strong>参数量远超过大模型</strong>。</li><li><strong>大语言模型（<code>Large Language Model</code>）：</strong>通常是具<strong>有大规模参数和计算能力的自然语言处理模型</strong>，例如 OpenAI 的 GPT-3 模型。这些模型可以通过大量的数据和参数进行训练，以生成人类类似的文本或回答自然语言的问题。大型语言模型在<strong>自然语言处理、文本生成和智能对话</strong>等领域有广泛应用。</li><li><strong><code>GPT（Generative Pre-trained Transformer）</code>：</strong>GPT 和 ChatGPT 都是基于 <code>Transformer</code> 架构的语言模型，但它们在设计和应用上存在区别，<code>GPT 模型</code>旨在<strong>生成自然语言文本并处理各种自然语言处理任务</strong>，如文本生成、翻译、摘要等。它通常在<strong>单向生成</strong>的情况下使用，即根据给定的文本生成连贯的输出。</li><li><strong><code>ChatGPT</code>：</strong>ChatGPT 则<strong>专注于对话和交互式对话</strong>。它经过特定的训练，以更好地处理多轮对话和上下文理解。ChatGPT 设计用于提供流畅、连贯和有趣的对话体验，以响应用户的输入并生成合适的回复。</li><li><strong>预训练模型（<code>Pre-trained Models</code>）：</strong> 在大规模数据上预训练的模型（如BERT、GPT），<strong>可通过微调适配下游任务</strong>。大模型多为预训练模型，但小模型也可预训练。</li><li><strong>基础模型（<code>Foundation Models</code>）：</strong> 斯坦福提出的概念，指<strong>通过自监督学习在大规模数据上训练、可适应多种任务的模型</strong>（如GPT-3）。大模型是基础模型的子集。</li><li><strong>多模态模型（<code>Multimodal Models</code>）：</strong> <strong>处理多种输入</strong>（文本、图像、音频）的模型（如CLIP、DALL·E）。大模型常具备多模态能力，但小模型也可设计为多模态。</li><li><strong>生成式AI（<code>Generative AI</code>）：</strong> 专注于<strong>生成内容</strong>的模型（如GPT、Stable Diffusion）。大模型常为生成式，但生成式模型不一定“大”（如小型GAN）</li></ul><h2 id="大模型的特点"><a href="#大模型的特点" class="headerlink" title="大模型的特点"></a><strong>大模型的特点</strong></h2><p><strong>参数规模超大</strong></p><ul><li><strong>量级</strong>：参数量从十亿（B）到万亿（T）级别，例如GPT-3（175B）、PaLM-2（340B）。</li><li><strong>意义</strong>：参数规模直接影响模型的“记忆容量”和复杂模式捕捉能力，是涌现（<code>Emergence</code>）能力（如逻辑推理、上下文学习）的基础。</li></ul><p><strong>训练数据海量</strong></p><ul><li><strong>数据量</strong>：通常使用<code>TB级</code>文本、图像等<strong>多模态数据</strong>（如GPT-3训练数据约45TB）。</li><li><strong>多样性</strong>：覆盖<strong>多语言、多领域</strong>（网页、书籍、代码等），降低模型对特定任务的过拟合风险。</li></ul><p><strong>计算资源密集</strong></p><ul><li><strong>训练成本</strong>：需数千张GPU/TPU并行训练数周，如GPT-3训练成本约460万美元。</li><li><strong>能耗问题</strong>：单次训练碳排放可达数百吨（如Bloom模型训练排放25吨CO₂）。</li></ul><p><strong>通用任务泛化</strong></p><ul><li><strong>少样本/零样本学习</strong>：无需微调即可完成新任务（如GPT-4直接生成代码）。</li><li><strong>多任务统一</strong>：同一模型处理文本生成、翻译、问答等多种任务（如PaLM-2）。</li></ul><p><strong>涌现能力（Emergent Abilities）</strong></p><ul><li><strong>不可预测性</strong>：模型在达到一定规模后突现出设计时未明确编程的能力，如：<ul><li><strong>上下文学习</strong>（In-context Learning）：通过示例提示调整输出。</li><li><strong>思维链</strong>（Chain-of-Thought）：分步骤推理解决数学问题。</li><li><strong>跨模态对齐</strong>：理解文本与图像的语义关联（如CLIP）。</li></ul></li></ul><h2 id="大模型的分类"><a href="#大模型的分类" class="headerlink" title="大模型的分类"></a><strong>大模型的分类</strong></h2><ul><li><strong>语言大模型（NLP）：</strong>是指在自然语言处理（<code>Natural Language Processing</code>，NLP）领域中的一类大模型，通常用于处理文本数据和理解自然语言。这类大模型的主要特点是它们在大规模语料库上进行了训练，以学习自然语言的各种语法、语义和语境规则。例如：GPT系列（OpenAI）、Bard（Google）、文心一言（百度）。</li><li><strong>视觉大模型（CV）：</strong>是指在计算机视觉（<code>Computer Vision</code>，CV）领域中使用的大模型，通常用于图像处理和分析。这类模型通过在大规模图像数据上进行训练，可以实现各种视觉任务，如图像分类、目标检测、图像分割、姿态估计、人脸识别等。例如：VIT 系列（Google）、文心UFO、华为盘古 CV、INTERN（商汤）。</li><li><strong>多模态大模型：</strong>是指<strong>能够处理多种不同类型数据的大模型</strong>，例如文本、图像、音频等多模态数据。这类模型结合了 NLP 和 CV 的能力，以实现对多模态信息的综合理解和分析，从而能够更全面地理解和处理复杂的数据。例如：DingoDB 多模向量数据库（九章云极 DataCanvas）、DALL-E(OpenAI)、悟空画画（华为）、midjourney。</li></ul><p>按照应用领域的不同，大模型主要可以分为 L0、L1、L2 三个层级：</p><ul><li><strong>通用大模型 L0：</strong>是指可以在<strong>多个领域和任务上通用</strong>的大模型。它们利用大算力、使用海量的开放数据与具有巨量参数的深度学习算法，在大规模无标注数据上进行训练，以寻找特征并发现规律，进而形成可“举一反三”的强大泛化能力，可在不进行微调或少量微调的情况下完成多场景任务，相当于 AI 完成了“通识教育”。</li><li><strong>行业大模型 L1：</strong>是指那些<strong>针对特定行业或领域</strong>的大模型。它们通常使用行业相关的数据进行预训练或微调，以提高在该领域的性能和准确度，相当于 AI 成为“行业专家”。</li><li><strong>垂直大模型 L2：</strong>是指那些<strong>针对特定任务或场景</strong>的大模型。它们通常使用任务相关的数据进行预训练或微调，以提高在该任务上的性能和效果。</li></ul><h2 id="大模型的泛化与微调"><a href="#大模型的泛化与微调" class="headerlink" title="大模型的泛化与微调"></a><strong>大模型的泛化与微调</strong></h2><p><strong>模型的泛化能力：</strong>是指一个模型在面对新的、未见过的数据时，能够正确理解和预测这些数据的能力。在机器学习和人工智能领域，模型的泛化能力是评估模型性能的重要指标之一。</p><p><strong>模型微调：</strong>给定预训练模型（Pre-trained model），基于模型进行微调（Fine Tune）。相对于从头开始训练(Training a model from scatch)，微调可以省去大量计算资源和计算时间，提高计算效率,甚至提高准确率。</p><p>模型微调的基本思想是<strong>使用少量带标签的数据对预训练模型进行再次训练，以适应特定任务</strong>。在这个过程中，模型的参数会根据新的数据分布进行调整。这种方法的好处在于，它利用了预训练模型的强大能力，同时还能够适应新的数据分布。因此，模型微调能够提高模型的泛化能力，减少过拟合现象。</p><p>常见的模型微调方法：</p><ul><li><strong><code>Fine-tuning</code>：</strong>这是最常用的微调方法。通过在预训练模型的最后一层添加一个新的分类层，然后根据新的数据集进行微调。</li><li><strong><code>Feature augmentation</code>：</strong>这种方法通过向数据中添加一些人工特征来增强模型的性能。这些特征可以是手工设计的，也可以是通过自动特征生成技术生成的。</li><li><strong><code>Transfer learning</code>：</strong>这种方法是使用在一个任务上训练过的模型作为新任务起点，然后对模型参数进行微调，以适应新任务。</li></ul><hr><h1 id="大型语言模型"><a href="#大型语言模型" class="headerlink" title="大型语言模型"></a><strong>大型语言模型</strong></h1><p>大型语言模型，一种能够以类似人类语言方式“说话”的软件。这些模型能获取上下文并生成不仅连贯而且感觉像是来自真实人类的回复。</p><p>这些语言模型通过分析大量的文本数据并学习语言使用的模式来工作。它们利用这些模式生成的文本几乎无法与人类所说或写的内容区分开来。例如，GPT-3模型拥有超过1750亿个参数，能够执行摘要生成、问答甚至创作等任务！</p><h2 id="大型语言模型的类型"><a href="#大型语言模型的类型" class="headerlink" title="大型语言模型的类型"></a><strong>大型语言模型的类型</strong></h2><ul><li><p><strong>基于自编码器的模型（Autoencoder-Based Model）</strong></p><p>它通过将输入文本编码为较低维度的表示，然后根据该表示生成新的文本。这类模型在<strong>文本摘要或内容生成</strong>等任务中表现出色。</p></li><li><p><strong>序列到序列模型（Sequence-to-Sequence Model）</strong></p><p>它接收一个输入序列（比如一个句子）并生成一个输出序列（比如翻译成另一种语言）。这些模型通常用于<strong>机器翻译和文本摘要</strong>。</p></li><li><p><strong>基于Transformer的模型（Transformer-Based Models）</strong></p><p>这些模型<strong>使用一种神经网络架构</strong>，非常擅长<strong>理解文本数据中的长距离依赖关系</strong>，使其在<strong>生成文本、翻译语言和回答问题</strong>等各种语言任务中非常有用。</p></li><li><p><strong>递归神经网络模型（Recursive Neural Network Models）</strong></p><p>递归神经网络模型被设计用于<strong>处理结构化数据</strong>，如句子的句法结构表示。这些模型对<strong>情感分析和自然语言推理</strong>等任务非常有用。</p></li><li><p><strong>分层模型（Hierarchical Models）</strong></p><p>分层模型被设计<strong>用于处理不同粒度级别的文本</strong>，例如句子、段落和文档。这些模型<strong>用于文档分类和主题建模</strong>等任务。</p></li></ul><h2 id="大型语言模型是如何工作的"><a href="#大型语言模型是如何工作的" class="headerlink" title="大型语言模型是如何工作的"></a><strong>大型语言模型是如何工作的</strong></h2><p>大型语言模型（LLM）架构是<code>Transformer</code>架构。典型的Transformer模型在处理输入数据时有四个主要步骤：</p><h3 id="词嵌入（Word-Embedding）"><a href="#词嵌入（Word-Embedding）" class="headerlink" title="词嵌入（Word Embedding）"></a><strong>词嵌入（Word Embedding）</strong></h3><p>它将单词表示为高维空间中的向量，使得相似的单词被归为一组。这有助于模型理解单词的含义，并基于此进行预测。</p><p>创建词嵌入<strong>涉及对大量文本数据进行神经网络训练</strong>，例如新闻文章或书籍。在训练过程中，网络学习根据单词在句子中的前后出现的词来预测其在给定上下文中出现的可能性。通过这个过程学习到的向量捕捉了语料库中不同单词之间的语义关系。</p><p>一旦创建了词嵌入，它们可以作为输入传递给在特定语言任务上进行训练的更大的神经网络，例如文本分类或机器翻译。通过使用词嵌入，模型能够更好地理解单词的含义，并基于这种理解做出更准确的预测。</p><h3 id="位置编码（Positional-Encoding）"><a href="#位置编码（Positional-Encoding）" class="headerlink" title="位置编码（Positional Encoding）"></a><strong>位置编码（Positional Encoding）</strong></h3><p>位置编码是<strong>帮助模型确定单词在序列中的位置</strong>的技术。它与单词的含义以及它们之间的关系无关。相反，位置编码主要用于跟踪单词的顺序。例如，当将句子”我喜欢猫”输入到模型时，位置编码可以帮助模型区分”我”是在句子的开头，而”猫”是在句子的结尾。这对于模型理解上下文和生成连贯的输出非常重要。</p><p>位置编码<strong>使用一系列特定模式的向量来表示单词的位置</strong>。这些向量与词嵌入的向量相加，以获得包含位置信息的表示。通过这种方式，模型能够将单词的位置作为输入的一部分，并在生成输出时保持一致。</p><h3 id="Transformers层"><a href="#Transformers层" class="headerlink" title="Transformers层"></a><strong>Transformers层</strong></h3><p>将Transformer层视为传统神经网络层之后的独立层。实际上，Transformer层通<strong>常作为附加层添加到传统神经网络架构</strong>中，以提高LLM在自然语言文本中<strong>建模长距离依赖性的能力</strong>。Transformer层通过<strong>并行处理</strong>整个输入序列而不是顺序处理来工作。它由两个基本组件组成：自注意力机制和前馈神经网络。</p><ul><li><p><strong>自注意力机制（Self-Attention Mechanism）</strong></p><p>它允许模型在生成输出时，有效地在输入序列的不同位置进行交互和关注。自注意力机制的关键思想是<strong>计算输入序列中每个单词之间的相关性</strong>，并将这些相关性用于权衡模型在每个位置的关注程度。</p><p>具体来说，自注意力机制计算每个单词与其他单词之间的相似度，然后将这些相似度转化为<strong>注意力权重</strong>。这些权重决定了模型在生成输出时对不同位置的输入进行关注的程度。这种自注意力机制使得模型能够根据输入序列中的上下文信息灵活地调整输出的生成。</p><p>传统的递归神经网络在处理长序列时容易出现<strong>梯度消失或梯度爆炸</strong>问题，而自注意力机制使得Transformer模型能够更好地捕捉长距离依赖关系。</p></li><li><p><strong>前馈神经网络（Feed-forward Neural Network）</strong></p><p>前馈神经网络<strong>对每个位置的表示进行进一步的处理</strong>。前馈神经网络是由多个全连接层组成的，其中每个层都有一组参数，用于将输入进行<strong>非线性变换</strong>。这个过程可以帮助模型在生成输出时引入更多的复杂性和灵活性。</p></li></ul><h3 id="文本生成"><a href="#文本生成" class="headerlink" title="文本生成"></a><strong>文本生成</strong></h3><p>LLM模型执行的最后一步；LLM经过训练和微调之后，该模型可用于根据提示或问题生成高度复杂的文本。模型通常通过种子输入进行”预热”，种子输入可以是几个单词、一个句子，甚至是一个完整段落。然后，LLM利用其学到的模式生成一个连贯且与上下文相关的回答。</p><p>文本生成依赖于一种称为<strong>自回归</strong>的技术，即<strong>模型根据它已生成的先前单词逐个生成输出序列的每个单词或标记</strong>。模型利用在训练期间学到的参数来计算下一个单词或标记的概率分布，然后选择最有可能的选择作为下一个输出。</p>]]></content>
    
    
    <summary type="html">人工智能大模型（简称“大模型”）是指由人工神经网络构建的一类具有大量参数的人工智能模型，主要类别包括：大语言模型、视觉大模型、多模态大模型以及基础科学大模型等。</summary>
    
    
    
    <category term="large model" scheme="https://southernfish.github.io/categories/large-model/"/>
    
    
    <category term="large model" scheme="https://southernfish.github.io/tags/large-model/"/>
    
  </entry>
  
  <entry>
    <title>Spring上下文</title>
    <link href="https://southernfish.github.io/2025/06/24/framwork/spring-context/"/>
    <id>https://southernfish.github.io/2025/06/24/framwork/spring-context/</id>
    <published>2025-06-24T02:16:36.000Z</published>
    <updated>2025-06-24T14:24:28.353Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring框架中，上下文（Context）是一个非常重要的概念，它代表了Spring应用的核心，用于管理应用程序中的bean（组件）的生命周期，配置信息等。Spring框架提供了多种类型的上下文实现，其中最常用的是ApplicationContext接口及其实现类。</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext是Spring框架中的核心接口，它继承自BeanFactory接口，提供了更丰富的功能。ApplicationContext不仅管理bean的创建和依赖注入，还提供了其他高级功能，如国际化和资源加载等。</p><h2 id="ApplicationContext的实现类"><a href="#ApplicationContext的实现类" class="headerlink" title="ApplicationContext的实现类"></a>ApplicationContext的实现类</h2><ol><li><p><strong>ClassPathXmlApplicationContext</strong>：从类路径下的XML文件中加载配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>FileSystemXmlApplicationContext</strong>：从文件系统中的XML文件中加载配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;path/to/applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>AnnotationConfigApplicationContext</strong>：用于加载基于Java的配置类（使用<code>@Configuration</code>注解的类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br></pre></td></tr></table></figure></li><li><p><strong>XmlWebApplicationContext</strong>：专门为Web应用设计的<code>ApplicationContext</code>实现，用于加载Web应用的XML配置文件。</p></li><li><p><strong>AnnotationConfigWebApplicationContext</strong>：用于Web应用，加载基于Java的配置类。</p></li></ol><h2 id="使用ApplicationContext"><a href="#使用ApplicationContext" class="headerlink" title="使用ApplicationContext"></a>使用ApplicationContext</h2><ol><li><p><strong>加载配置文件或类</strong></p><ul><li><p><strong>XML配置：</strong>通过<code>ClassPathXmlApplicationContext</code>或<code>FileSystemXmlApplicationContext</code>加载XML配置文件。  </p></li><li><p><strong>Java配置：</strong>通过<code>AnnotationConfigApplicationContext</code>加载使用<code>@Configuration</code>注解的类。   </p></li></ul></li><li><p><strong>获取Bean</strong></p><p>一旦上下文被创建，你可以通过它来获取需要的<code>bean</code>或者<code>使用名称</code>：。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> context.getBean(MyBean.class); <span class="comment">// 获取bean</span></span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> (MyBean) context.getBean(<span class="string">&quot;myBean&quot;</span>); <span class="comment">// 获取使用名称</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关闭上下文</strong></p><p>当Spring应用结束时，应该关闭上下文以释放资源或者使用自动关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((ConfigurableApplicationContext) context).close(); <span class="comment">// 关闭上下文</span></span><br><span class="line">((AbstractApplicationContext) context).registerShutdownHook(); <span class="comment">// 注册JVM关闭钩子，自动关闭上下文</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><ul><li><strong>国际化</strong>：通过<code>MessageSource</code>获取本地化消息。</li><li><strong>事件发布</strong>：发布和监听应用事件。</li><li><strong>资源管理</strong>：加载文件资源，如属性文件、XML文件等。</li><li><strong>环境抽象</strong>：提供对不同环境的抽象，如开发、测试、生产等。</li></ul>]]></content>
    
    
    <summary type="html">‌在Spring框架中，在处理上下文（Context）时，通常指的是Spring应用中的ApplicationContext。‌</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="Spring" scheme="https://southernfish.github.io/categories/Framwork/Spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring注解</title>
    <link href="https://southernfish.github.io/2025/06/23/framwork/spring-annotation/"/>
    <id>https://southernfish.github.io/2025/06/23/framwork/spring-annotation/</id>
    <published>2025-06-23T13:10:36.000Z</published>
    <updated>2025-06-24T14:24:28.352Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring框架中，注解是一种非常重要的特性，它极大地简化了配置和开发过程。‌Spring注解是Spring框架中用于简化配置和开发的核心机制，主要分为组件管理、依赖注入、配置类、AOP、Web开发等类别‌。</p><h1 id="Spring注解的底层实现逻辑"><a href="#Spring注解的底层实现逻辑" class="headerlink" title="Spring注解的底层实现逻辑"></a>Spring注解的底层实现逻辑</h1><h2 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h2><p>Java注解的底层实现逻辑主要包括<strong>定义注解、使用注解和通过反射获取注解</strong>。具体源码分析转载自 <a href="https://blog.csdn.net/fk1778770286/article/details/148581060">Java注解底层实现原理 - 源码分析</a></p><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>注解是通过<code>@interface</code>关键字定义的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 默认值</span></span><br><span class="line">    <span class="type">int</span>[] numbers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>@Target</code>和<code>@Retention</code>是元注解，分别指定了注解的应用目标和保留策略。<code>ElementType.TYPE</code>表示该注解可以应用于类、接口或枚举上，<code>RetentionPolicy.RUNTIME</code>表示注解在运行时可以通过反射获取‌</p><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>使用注解时，只需在声明处添加相应的注解即可。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> TestClass.class.getAnnotation(MyAnnotation.class);</span><br><span class="line">        System.out.println(annotation.value()); <span class="comment">// 输出: hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码通过反射获取了<code>TestClass</code>类上的<code>MyAnnotation</code>注解，并打印了其<code>value</code>属性的值‌。</p><h3 id="反射获取注解"><a href="#反射获取注解" class="headerlink" title="反射获取注解"></a>反射获取注解</h3><p>通过反射，可以在运行时获取类、方法、参数等上的注解信息。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = TestClass.class;</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(annotation.value());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有methods</span></span><br><span class="line">    Method[] methods = MyAnnotation.class.getClassLoader()</span><br><span class="line">          .loadClass((<span class="string">&quot;com.pdai.java.annotation.TestMyAnnotation&quot;</span>))</span><br><span class="line">          .getMethods();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotation.class)) &#123; <span class="comment">// 方法上是否有MyAnnotation注解</span></span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">anno</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class); <span class="comment">// 获取MyAnnotation对象信息</span></span><br><span class="line">            System.out.println(anno.title()); <span class="comment">// 访问注解的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="源码分析注解的底层实现"><a href="#源码分析注解的底层实现" class="headerlink" title="源码分析注解的底层实现"></a>源码分析注解的底层实现</h2><p>从 <code>MyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);</code> 开始分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getAnnotation】</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A <span class="title function_">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(annotationClass);</span><br><span class="line">    <span class="keyword">return</span> (A) annotationData().annotations.get(annotationClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>annotationData().annotations.get(annotationClass);</code>：调用 <code>annotationData()</code> 方法获取<strong>当前类的注解数据</strong>，然后从 annotations 映射中获取<strong>指定类型的注解实例</strong></li><li><code>(A)</code>：将获取到的<strong>注解实例强制转换为泛型类型 A</strong></li></ul><h3 id="获取注解数据集-annotationData"><a href="#获取注解数据集-annotationData" class="headerlink" title="获取注解数据集 annotationData"></a>获取注解数据集 annotationData</h3><p>使用 <code>Atomic.casAnnotationData</code> 方法（基于 CAS <a href="https://so.csdn.net/so/search?q=%E4%B9%90%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020">乐观锁</a>机制）尝试将新的 AnnotationData 对象更新到当前类中。若更新成功，返回新的 AnnotationData 对象；若失败，循环会继续重试，直到成功为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#annotationData】</span></span><br><span class="line"><span class="comment">/* 获取当前类的注解数据对象。如果缓存的注解数据已过期或不存在，则创建新的注解数据对象并尝试更新到缓存中。</span></span><br><span class="line"><span class="comment"> * 该方法使用循环重试和 CAS 操作来保证数据的一致性和线程安全。</span></span><br><span class="line"><span class="comment"> * @return 当前类的注解数据对象  */</span></span><br><span class="line"><span class="keyword">private</span> AnnotationData <span class="title function_">annotationData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">// 进入无限循环，实现重试机制，直到成功获取有效的注解数据</span></span><br><span class="line">        <span class="type">AnnotationData</span> <span class="variable">annotationData</span> <span class="operator">=</span> <span class="built_in">this</span>.annotationData; <span class="comment">// 获取当前缓存的注解数据对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="built_in">this</span>.classRedefinedCount; <span class="comment">// 获取当前类的重定义计数，该值在类被重新定义时会递增</span></span><br><span class="line">        <span class="keyword">if</span> (annotationData != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            annotationData.redefinedCount == classRedefinedCount) &#123; <span class="comment">// 检查缓存的注解数据是否存在且未过期</span></span><br><span class="line">            <span class="keyword">return</span> annotationData; <span class="comment">// 若注解数据有效，直接返回缓存的对象</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若缓存的注解数据为空或已过期，乐观地创建一个新的注解数据对象</span></span><br><span class="line">        <span class="type">AnnotationData</span> <span class="variable">newAnnotationData</span> <span class="operator">=</span> createAnnotationData(classRedefinedCount);</span><br><span class="line">        <span class="comment">// 尝试使用 CAS（Compare-And-Swap）操作将新的注解数据对象更新到缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic.casAnnotationData(<span class="built_in">this</span>, annotationData, newAnnotationData)) &#123;</span><br><span class="line">            <span class="keyword">return</span> newAnnotationData; <span class="comment">// 若 CAS 操作成功，说明新的注解数据已成功更新到缓存，返回该对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 CAS 操作失败，说明在创建新对象期间，其他线程已经更新了注解数据，进入下一次循环重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建注解数据集-createAnnotationData"><a href="#构建注解数据集-createAnnotationData" class="headerlink" title="构建注解数据集 createAnnotationData"></a>构建注解数据集 createAnnotationData</h3><ul><li>调用 <code>AnnotationParser.parseAnnotations</code> 方法，解析当前类的原始注解数据，将结果存储在 <code>declaredAnnotations</code> 映射中，<em>键为注解类，值为注解实例</em></li><li><strong>处理父类继承注解：</strong>父类存在，获取父类的注解数据中的注解映射 <code>superAnnotations</code>。遍历 superAnnotations，对于每个注解，检查其是否使用了<code>@Inherited</code>元注解（通过 <code>AnnotationType.getInstance(annotationClass).isInherited()</code> 判断）。若使用了 @Inherited 元注解，且 annotations 为 null，则进行懒初始化，创建一个 LinkedHashMap 来存储继承的注解。将继承的注解添加到 annotations 映射中</li><li><strong>合并注解：</strong>若 annotations 仍为 null，说明没有继承的注解，直接将 annotations 指向 declaredAnnotations。若存在继承的注解，将 declaredAnnotations 中的注解添加到 annotations 中，当前类声明的注解会覆盖继承的注解</li><li><strong>总结：</strong>该方法的核心逻辑是解析当前类的声明注解，若父类存在，获取父类中可继承的注解，将两者合并后创建 AnnotationData 对象。这样可以保证 AnnotationData 对象包含当前类完整的注解信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#createAnnotationData】</span></span><br><span class="line"><span class="keyword">private</span> AnnotationData <span class="title function_">createAnnotationData</span><span class="params">(<span class="type">int</span> classRedefinedCount)</span> &#123;</span><br><span class="line">    <span class="comment">// ------------------------ 处理父类继承注解 ----------------------------------</span></span><br><span class="line">    <span class="comment">// 解析当前类的原始注解数据，将结果存储在 declaredAnnotations 映射中</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; declaredAnnotations =</span><br><span class="line">        AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), <span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">    Class&lt;?&gt; superClass = getSuperclass(); <span class="comment">// 父类获取</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; annotations = <span class="literal">null</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (superClass != <span class="literal">null</span>) &#123; <span class="comment">// 若父类存在</span></span><br><span class="line">        Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; superAnnotations =</span><br><span class="line">            superClass.annotationData().annotations; <span class="comment">// 获取父类的注解数据中的注解映射</span></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; e : superAnnotations.entrySet()) &#123;</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass = e.getKey();</span><br><span class="line">            <span class="comment">// 判断每个注解是否使用了元注解@Inherited</span></span><br><span class="line">            <span class="keyword">if</span> (AnnotationType.getInstance(annotationClass).isInherited()) &#123; </span><br><span class="line">                <span class="keyword">if</span> (annotations == <span class="literal">null</span>) &#123; <span class="comment">// lazy construction （懒初始化）</span></span><br><span class="line">                    <span class="comment">// 创建一个 LinkedHashMap 来存储继承的注解</span></span><br><span class="line">                    annotations = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;((Math.max(</span><br><span class="line">                            declaredAnnotations.size(),</span><br><span class="line">                            Math.min(<span class="number">12</span>, declaredAnnotations.size() + superAnnotations.size())</span><br><span class="line">                        ) * <span class="number">4</span> + <span class="number">2</span>) / <span class="number">3</span></span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将继承的注解添加到 annotations 映射中</span></span><br><span class="line">                annotations.put(annotationClass, e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------ 处理父类继承注解 --------------------------------</span></span><br><span class="line">    <span class="comment">// --------------------------- 合并注解 ----------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (annotations == <span class="literal">null</span>) &#123; <span class="comment">// annotations 仍为 null，说明没有继承的注解</span></span><br><span class="line">        <span class="comment">// no inherited annotations -&gt; share the Map with declaredAnnotations</span></span><br><span class="line">        annotations = declaredAnnotations;</span><br><span class="line">    <span class="comment">// --------------------------- 合并注解 ----------------------------------</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 存在继承的注解 添加后，当前类声明的注解会覆盖继承的注解</span></span><br><span class="line">        <span class="comment">// at least one inherited annotation -&gt; declared may override inherited</span></span><br><span class="line">        annotations.putAll(declaredAnnotations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationData</span>(annotations, declaredAnnotations, classRedefinedCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取当前类的原始注解数据-getRawAnnotations"><a href="#获取当前类的原始注解数据-getRawAnnotations" class="headerlink" title="获取当前类的原始注解数据 getRawAnnotations"></a>获取当前类的原始注解数据 getRawAnnotations</h3><ul><li><strong>native 关键字</strong>：在 Java 里，<code>native</code> 关键字用于声明本地方法。本地方法并非用 Java 实现，而是借助其他编程语言（像 C、C++）实现。Java 虚拟机（JVM）会负责加载并调用这些本地方法。通常，本地方法用于和底层系统交互，或实现对性能要求极高的操作。</li><li><strong>byte[] 返回类型</strong>：该方法返回一个字节数组 byte[]。这意味着<strong>方法会返回当前类原始注解数据的字节表示形式</strong>。原始注解数据是注解在字节码层面的存储形式，可能包含<strong>注解类型、注解属性值</strong>等信息。</li><li><strong>元注解</strong>：作用于自定义注解类型的注解类，在JDK 1.5中提供了4个标准的元注解：<code>@Target，@Retention，@Documented，@Inherited</code>，在JDK 1.8中提供了两个元注解 <code>@Repeatable</code>和<code>@Native</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getRawAnnotations】</span></span><br><span class="line"><span class="keyword">native</span> <span class="type">byte</span>[] getRawAnnotations();</span><br></pre></td></tr></table></figure><h3 id="获取当前类对应的常量池-getConstantPool"><a href="#获取当前类对应的常量池-getConstantPool" class="headerlink" title="获取当前类对应的常量池 getConstantPool"></a>获取当前类对应的常量池 getConstantPool</h3><p><code>getConstantPool</code> 方法是一个本地方法，其作用是获取当前类对应的常量池对象。由于需要直接访问 JVM 内部的数据结构，所以采用本地方法实现。调用该方法后，能得到一个 <code>ConstantPool</code> 对象，进而访问常量池中的常量信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【java.lang.Class#getConstantPool】</span></span><br><span class="line"><span class="keyword">native</span> ConstantPool <span class="title function_">getConstantPool</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="解析当前类的原始注解数据-parseAnnotations"><a href="#解析当前类的原始注解数据-parseAnnotations" class="headerlink" title="解析当前类的原始注解数据 parseAnnotations"></a>解析当前类的原始注解数据 parseAnnotations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#parseAnnotations】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; parseAnnotations(</span><br><span class="line">        <span class="type">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (var0 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parseAnnotations2(var0, var1, var2, (Class[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BufferUnderflowException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Unexpected end of annotations.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; parseAnnotations2(</span><br><span class="line">        <span class="type">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2, Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;[] var3) &#123;</span><br><span class="line">    <span class="type">LinkedHashMap</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">var5</span> <span class="operator">=</span> ByteBuffer.wrap(var0);</span><br><span class="line">    <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> var5.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">        <span class="type">Annotation</span> <span class="variable">var8</span> <span class="operator">=</span> parseAnnotation2(var5, var1, var2, <span class="literal">false</span>, var3);</span><br><span class="line">        <span class="keyword">if</span> (var8 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">var9</span> <span class="operator">=</span> var8.annotationType();</span><br><span class="line">            <span class="keyword">if</span> (AnnotationType.getInstance(var9).retention() == RetentionPolicy.RUNTIME &amp;&amp; var4.put(var9, var8) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Duplicate annotation for class: &quot;</span> + var9 + <span class="string">&quot;: &quot;</span> + var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体会调用到下面的 <code>parseAnnotation2</code> 方法，该方法主要都是解析注解里面的信息，解析出来的值最终会给到我们去创建代理对象用。我们重点关注的是 <code>annotationForMap</code> 这个方法，该方法里面就是通过动态代理来创建注解实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#parseAnnotation2】</span></span><br><span class="line"><span class="comment">/* 解析注解字节数据，生成注解实例。</span></span><br><span class="line"><span class="comment"> * @param var0 包含注解数据的字节缓冲区</span></span><br><span class="line"><span class="comment"> * @param var1 常量池对象，用于获取注解相关的常量信息</span></span><br><span class="line"><span class="comment"> * @param var2 注解所属的类</span></span><br><span class="line"><span class="comment"> * @param var3 若为 true，在遇到类型不存在异常时抛出异常；否则跳过该注解</span></span><br><span class="line"><span class="comment"> * @param var4 要解析的注解类型数组，若为 null 则解析所有注解</span></span><br><span class="line"><span class="comment"> * @return 解析得到的注解实例，若跳过解析则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">parseAnnotation2</span><span class="params">(</span></span><br><span class="line"><span class="params">    ByteBuffer var0, ConstantPool var1, Class&lt;?&gt; var2, <span class="type">boolean</span> var3, Class&lt;? extends Annotation&gt;[] var4)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取注解类型的常量池索引</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于存储临时对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="string">&quot;[unknown]&quot;</span>; <span class="comment">// 注解类型名称，初始为未知</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试获取注解类型的类对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var7 = var1.getUTF8At(var5); <span class="comment">// 从常量池中获取注解类型的名称</span></span><br><span class="line">            var21 = parseSig(var7, var2); <span class="comment">// 解析签名，获取注解类型的类对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var18) &#123;</span><br><span class="line">            var21 = var1.getClassAt(var5);  <span class="comment">// 若解析签名失败，直接从常量池中获取类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError var19) &#123; <span class="comment">// 若找不到类定义</span></span><br><span class="line">        <span class="keyword">if</span> (var3) &#123; <span class="comment">// 若 var3 为 true，抛出类型不存在异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeNotPresentException</span>(var7, var19);</span><br><span class="line">        &#125;</span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>); <span class="comment">// 跳过当前注解的解析</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TypeNotPresentException var20) &#123; <span class="comment">// 若类型不存在</span></span><br><span class="line">        <span class="keyword">if</span> (var3) &#123; <span class="comment">// 若 var3 为 true，抛出类型不存在异常</span></span><br><span class="line">            <span class="keyword">throw</span> var20;</span><br><span class="line">        &#125;</span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>); <span class="comment">// 跳过当前注解的解析</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否只需要解析特定类型的注解</span></span><br><span class="line">    <span class="keyword">if</span> (var4 != <span class="literal">null</span> &amp;&amp; !contains(var4, var21)) &#123; <span class="comment">// 若当前注解类型不在需要解析的类型列表中，跳过解析</span></span><br><span class="line">        skipAnnotation(var0, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于存储临时对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var23 = AnnotationType.getInstance(var21); <span class="comment">// 获取注解类型的元数据</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var17) &#123; <span class="comment">// 若获取元数据失败，跳过当前注解的解析</span></span><br><span class="line">            skipAnnotation(var0, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">var9</span> <span class="operator">=</span> var23.memberTypes(); <span class="comment">// 获取注解类型的成员类型映射</span></span><br><span class="line">        <span class="type">LinkedHashMap</span> <span class="variable">var10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(var23.memberDefaults()); <span class="comment">// 初始化注解成员值映射，使用默认值填充</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">var11</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取注解成员的数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var12</span> <span class="operator">=</span> <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;  <span class="comment">// 遍历所有注解成员</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">var13</span> <span class="operator">=</span> var0.getShort() &amp; <span class="string">&#x27;\uffff&#x27;</span>; <span class="comment">// 从字节缓冲区读取成员名称的常量池索引</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">var14</span> <span class="operator">=</span> var1.getUTF8At(var13); <span class="comment">// 从常量池中获取成员名称</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">var15</span> <span class="operator">=</span> (Class)var9.get(var14); <span class="comment">// 获取成员的类型</span></span><br><span class="line">            <span class="keyword">if</span> (var15 == <span class="literal">null</span>) &#123; <span class="comment">// 若成员类型不存在，跳过该成员值的解析</span></span><br><span class="line">                skipMemberValue(var0);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var16</span> <span class="operator">=</span> parseMemberValue(var15, var0, var1, var2); <span class="comment">// 解析成员值</span></span><br><span class="line">                <span class="comment">// 若成员值类型不匹配，设置异常代理的成员信息</span></span><br><span class="line">                <span class="keyword">if</span> (var16 <span class="keyword">instanceof</span> AnnotationTypeMismatchExceptionProxy) &#123;</span><br><span class="line"> ((AnnotationTypeMismatchExceptionProxy)var16).setMember((Method)var23.members().get(var14));</span><br><span class="line">                &#125;</span><br><span class="line">                var10.put(var14, var16); <span class="comment">// 将解析得到的成员值放入映射中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> annotationForMap(var21, var10); <span class="comment">// 根据注解类型和成员值映射生成注解实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过java动态代理实例化注解代理对象"><a href="#通过java动态代理实例化注解代理对象" class="headerlink" title="通过java动态代理实例化注解代理对象"></a>通过java动态代理实例化注解代理对象</h3><ul><li><code>AccessController.doPrivileged</code>：该方法用于在特权环境下执行特定操作。在 Java 安全模型里，有些操作需要特定权限才能执行，使用 <code>doPrivileged</code> 可确保代码在足够权限下运行</li><li><code>annotationForMap</code> 方法利用 Java 的反射和代理机制，根据给定的注解类型和成员值映射，动态创建一个注解实例。借助 <code>AccessController</code> 确保操作在特权环境下执行，最终返回一个实现了指定注解接口的代理对象（此处需要注意，用的代理类 <code>AnnotationInvocationHandler</code>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationParser#annotationForMap】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Annotation <span class="title function_">annotationForMap</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> Class&lt;? extends Annotation&gt; var0, <span class="keyword">final</span> Map&lt;String, Object&gt; var1)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (Annotation)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Annotation&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Annotation <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Annotation)Proxy.newProxyInstance(var0.getClassLoader(), </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;var0&#125;, </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">AnnotationInvocationHandler</span>(var0, var1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-AnnotationInvocationHandler"><a href="#实现-AnnotationInvocationHandler" class="headerlink" title="实现 AnnotationInvocationHandler"></a>实现 AnnotationInvocationHandler</h3><ul><li><code>AnnotationInvocationHandler</code> 类中的 invoke 方法，该类实现了 <code>InvocationHandler</code> 接口。<strong>在 Java 动态代理机制里，InvocationHandler 接口的 invoke 方法是核心</strong>，当调用代理对象的方法时，实际上会调用 invoke 方法来处理</li><li><strong>处理特殊方法调用：</strong><ul><li>若被调用方法是 toString，调用 <code>toStringImpl</code> 方法生成注解的字符串表示并返回</li><li>若被调用方法是 hashCode，调用 <code>hashCodeImpl</code> 方法计算注解的哈希码并返回</li><li>若被调用方法是 <code>annotationType</code>，返回注解的类型 <code>this.type</code></li></ul></li><li><strong>处理注解成员方法调用：</strong><ul><li>若被调用方法是注解的成员方法，从 <code>memberValues</code> 映射中获取对应的值</li><li>若值为 null，说明注解实例缺少该成员的值，抛出 <code>IncompleteAnnotationException</code> 异常</li><li>若值是 <code>ExceptionProxy</code> 类型，调用 <code>generateException</code> 方法抛出异常</li><li>若值是数组且不为空，调用 <code>cloneArray</code> 方法克隆数组，避免外部修改原始数组，最后返回该值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所属代码：【sun.reflect.annotation.AnnotationInvocationHandler】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6182022883658399397L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method[] memberMethods = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = var1;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getName();</span><br><span class="line">    Class[] var5 = var2.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (var4) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.toStringImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.hashCodeImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4);</span><br><span class="line">                <span class="keyword">if</span> (var6 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(<span class="built_in">this</span>.type, var4);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                        var6 = <span class="built_in">this</span>.cloneArray(var6);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> var6;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h1><h2 id="注解如何生效"><a href="#注解如何生效" class="headerlink" title="注解如何生效"></a>注解如何生效</h2><p><strong>编译期扫描处理，运行期反射处理。编译期扫描处理一般只有Java内置注解会用到</strong>，比如<code>@Override</code>修饰的方法，编译器会检查父类是否有相同的方法。大部分自定义的注解，都是在运行期通过反射拿到并处理。</p><h2 id="运行期如何获取注解"><a href="#运行期如何获取注解" class="headerlink" title="运行期如何获取注解"></a>运行期如何获取注解</h2><p>运行时注解<strong>存放在class文件中的<code>attributes属性表</code>中</strong>。<br><strong>反射获取注解的核心</strong>在：<code>java.lang.reflect</code>下的 <strong><code>AnnotatedElement</code><strong>接口，而</strong><code>AnnotatedElement</code></strong> 接口是所有程序元素（<code>Class</code>、<code>Method</code>和<code>Constructor</code>）的父接口。</p><h2 id="Spring加与不加注解的区别"><a href="#Spring加与不加注解的区别" class="headerlink" title="Spring加与不加注解的区别"></a>Spring加与不加注解的区别</h2><ol><li>‌<strong>配置方式</strong>‌：<ul><li>‌<strong>不加注解</strong>‌：可以<strong>通过XML配置文件来定义bean</strong>，这种方式更加直观，但需要编写XML文件。</li><li>‌<strong>加注解</strong>‌：通过使用<code>@Configuration</code>和<code>@Bean</code>注解来定义bean，这种方式更加灵活，代码更加简洁，且易于维护和修改。</li></ul></li><li>‌<strong>管理方式</strong>‌：<ul><li>‌<strong>不加注解</strong>‌：需要手动编写XML配置文件，并通过XML配置文件来管理bean的创建和依赖关系。</li><li>‌<strong>加注解</strong>‌：通过注解来定义bean，Spring框架在启动时会扫描这些注解并自动创建和管理bean，减少了手动配置的工作量。</li></ul></li></ol><hr><h1 id="常用注解及解释"><a href="#常用注解及解释" class="headerlink" title="常用注解及解释"></a>常用注解及解释</h1><h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><ul><li>‌**<code>@Component</code>**‌：用于把当前类对象存入Spring容器中。<code>@Controller、@Service、@Repository</code>都可以称为@Component，它们分别用于控制层、业务层和数据访问层。</li><li>‌**<code>@Autowired</code>**‌：自动按照类型注入Spring容器中的bean。它可以作用在变量、setter方法或构造函数上。</li><li>‌**<code>@Qualifier</code>**‌：在按照类型注入的基础上，通过名称进行注入。通常与<code>@Autowired</code>一起使用，用于解决相同类型bean的注入冲突。</li><li>‌**<code>@Inject</code>**‌：由<code>JSR-330</code>提供，用法与<code>@Autowired</code>相似，但它是Java标准的一部分，而@Autowired是Spring特有的。</li><li>‌**<code>@Resource</code>**‌：由<code>JSR-250</code>提供，按照bean的id进行注入，可以独立使用。</li><li>‌**<code>@Primary</code>**‌：当存在多个相同类型的bean时，标记首选的bean进行注入。</li></ul><h2 id="Java配置类相关注解"><a href="#Java配置类相关注解" class="headerlink" title="Java配置类相关注解"></a>Java配置类相关注解</h2><ul><li>‌**<code>@Configuration</code>**‌：声明当前类为配置类，相当于传统的XML配置文件。</li><li>‌**<code>@Bean</code>**‌：注解在方法上，声明当前方法的返回值为一个bean，替代XML中的<code>&lt;bean&gt;</code>标签。</li><li>‌**<code>@ComponentScan</code>**‌：用于指定Spring在创建容器时要扫描的包，以找到带有<code>@Component、@Repository、@Service、@Controller</code>等注解的类，并注册为bean。</li></ul><h2 id="切面（AOP）相关注解"><a href="#切面（AOP）相关注解" class="headerlink" title="切面（AOP）相关注解"></a>切面（AOP）相关注解</h2><ul><li>‌**<code>@Aspect</code>**‌：声明一个切面。</li><li>‌**<code>@After</code>**‌：在目标方法执行之后执行。</li><li>‌**<code>@Before</code>**‌：在目标方法执行之前执行。</li><li>‌**<code>@Around</code>**‌：在目标方法执行之前和之后执行，可以围绕目标方法创建一个“拦截器”。</li><li>‌**<code>@PointCut</code>**‌：声明一个切点，即指定哪些方法将被增强。</li></ul><h2 id="配置和环境相关注解"><a href="#配置和环境相关注解" class="headerlink" title="配置和环境相关注解"></a>配置和环境相关注解</h2><ul><li>‌**<code>@Value</code>**‌：用于注入基本类型和String类型的数据，支持使用<code>Spring EL</code>表达式。</li><li>‌**<code>@Profile</code>**‌：指定组件在哪个环境的情况下才能被注册到容器中。</li><li>‌**<code>@Conditional</code>**‌：通过实现Condition接口，并重写<code>matches</code>方法，从而决定该bean是否被实例化。</li></ul><h2 id="其他常用注解"><a href="#其他常用注解" class="headerlink" title="其他常用注解"></a>其他常用注解</h2><ul><li>‌**<code>@Lazy</code>**‌：用于延迟初始化bean，即只有在第一次使用时才会创建和初始化。</li><li>‌**<code>@Scope</code><strong>‌：用于指定bean的作用范围，如</strong>单例（singleton）或多例（prototype）**。</li><li>‌**<code>@EnableAsync</code>**‌：在配置类中通过此注解开启对异步任务的支持。</li><li>‌**<code>@Async</code>**‌：在实际执行的bean方法使用该注解来声明其是一个异步任务。</li><li>‌**<code>@EnableScheduling</code>**‌：在配置类上使用，开启计划任务的支持。</li><li>‌**<code>@Scheduled</code>**‌：用于声明一个定时任务。</li></ul>]]></content>
    
    
    <summary type="html">在Spring框架中，注解是一种非常重要的特性，它极大地简化了配置和开发过程。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="Spring" scheme="https://southernfish.github.io/categories/Framwork/Spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>使用多线程解决问题</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-thread-impl/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-thread-impl/</id>
    <published>2025-06-23T12:25:36.000Z</published>
    <updated>2025-06-24T14:24:28.354Z</updated>
    
    <content type="html"><![CDATA[<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同<a href="https://baike.baidu.com/item/%E4%B8%80%E6%97%B6%E9%97%B4/3618565?fromModule=lemma_inlink">一时间</a>执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括<a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/10375153?fromModule=lemma_inlink">对称多处理机</a>、<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A0%B8%E5%BF%83/1013410?fromModule=lemma_inlink">多核心</a>处理器以及<a href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87%E7%BA%A7%E5%A4%9A%E5%A4%84%E7%90%86/924724?fromModule=lemma_inlink">芯片级多处理</a>或<a href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B/22689341?fromModule=lemma_inlink">同时多线程</a>处理器。在一个程序中，这些独立运行的程序片段叫作“<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fromModule=lemma_inlink">线程</a>”（Thread），利用它编程的概念就叫作“多线程处理” 。本文简单记录一些关于线程、多线程的问题。本文记录了关于一些常见多线程业务问题处理。</p><h2 id="多线程问题-1"><a href="#多线程问题-1" class="headerlink" title="多线程问题 1"></a>多线程问题 1</h2><p><strong>问题：</strong>100个线程并发向1个银行账户中存入1元钱,并在全部完成后，打印银行账户的金额。</p><p><strong>思路：</strong>创建100个线程（<code>线程池</code>）；保证线程安全，同一时刻只有一个线程对账户进行操作（<code>Lock</code> 或者 <code>synchronized</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种加锁 synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance + money;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种锁 lock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="comment">// 获得账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁 存钱方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        reentrantLock.lock;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newBalance = balance + money;</span><br><span class="line">            balance = newBalance;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">          reentrantLock.unlock();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存钱的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSaveAccount</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TheadSaveAccount</span><span class="params">(Account account, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁 整个账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            account.deposit(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadSave</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.execute( <span class="keyword">new</span> <span class="title class_">TheadSaveAccount</span>(account, <span class="number">1</span>) );</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (service.isTerminated()) &#123;</span><br><span class="line">            System.out.println(account.getBalance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多线程是并行化的一种形式，或者是拆分工作以便同时进行处理。线程化的程序将工作拆分到多个软件线程，而不是将大量工作交给单个内核。这些线程由不同的 CPU 内核并行处理，以节省时间。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>RestfulApi</title>
    <link href="https://southernfish.github.io/2025/06/23/framwork/RestfulApi/"/>
    <id>https://southernfish.github.io/2025/06/23/framwork/RestfulApi/</id>
    <published>2025-06-23T08:16:36.000Z</published>
    <updated>2025-06-24T14:24:28.352Z</updated>
    
    <content type="html"><![CDATA[<p>RESTful（Representational State Transfer，表述性状态转移）是一种基于HTTP协议的架构风格，利用URI、HTTP方法（如GET、POST、PUT、DELETE等）以及表示层数据格式（如JSON）来创建具有高度可扩展性的服务‌。其核心原则包括资源导向设计、无状态通信、标准HTTP方法使用（GET/POST/PUT/DELETE）以及统一接口规范，广泛应用于微服务、移动应用和物联网等领域。</p><h2 id="什么是-RESTful-API"><a href="#什么是-RESTful-API" class="headerlink" title="什么是 RESTful API"></a>什么是 RESTful API</h2><ul><li><code>REST API</code>是<strong>一种应用程序编程接口</strong>（API 或 Web API），遵循一组关于应用程序如何使用 HTTP 方法相互通信的架构规则。 <code>RESTful Web</code> 服务使用 REST API 协议，因此有时也称为 RESTful API。</li><li>REST 通常用于构建 Web API，<strong>允许客户端与服务器之间通过 HTTP 协议进行交互</strong>。</li><li><code>REST</code> 并不是一种协议或标准，而是一组指导原则，旨在帮助开发人员创建可扩展、性能良好且易于维护的 Web 服务。</li><li><strong>REST 的核心思想</strong>是通过一组简单、统一的接口来管理和操作服务器上的资源。</li></ul><h2 id="资源Resource"><a href="#资源Resource" class="headerlink" title="资源Resource"></a><strong>资源</strong>Resource</h2><p>资源可以被视为 Web 服务中的“实体”或“对象”，它可以是用户、订单、文件等任何<strong>具有唯一标识符的事物</strong>。每个资源都由一个 URI（<code>Uniform Resource Identifier</code>，统一资源标识符）标识。<br><strong>资源的表示（Representations）</strong><br>资源可以有多种不同的表示形式，例如 <code>JSON、XML、HTML</code> 等。当客户端请求资源时，<strong>服务器会以特定的表示形式返回资源</strong>。表示形式通常通过 <code>HTTP</code> 头中的 <code>Content-Type</code> 指定，例如 <code>application/json</code> 表示 JSON 格式。</p><h2 id="URI（统一资源标识符）"><a href="#URI（统一资源标识符）" class="headerlink" title="URI（统一资源标识符）"></a>URI（统一资源标识符）</h2><p><code>URI(Uniform Resource Identifier)</code>，URI既可以看成是资源的地址，也可以看成是资源的名称，它是<strong>用于标识资源的唯一地址，每个资源都应该有一个唯一的 URI</strong>，这个 URI 可以看作是资源的“地址“，如<code>api/user/profile/get</code>：表示获取用户信息。<br>URI 应该是<strong>稳定的</strong>，不应该因为资源内部状态的变化而发生变化。URI 应该是<strong>自解释的</strong>，即可以从 URI 大致了解所表示的资源。</p><h2 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h2><p>在 REST 中，HTTP 方法<strong>用于指定对资源执行的操作</strong>。每种方法都应该在其相应的上下文中使用。<strong>常用的 HTTP 方法包括</strong>：</p><ul><li><code>GET</code>：检索资源。请求不会改变服务器状态。</li><li><code>POST</code>：创建资源或在现有资源中执行子资源的创建操作。</li><li><code>PUT</code>：更新资源。通常用于更新整个资源。</li><li><code>PATCH</code>：部分更新资源。通常用于更新资源的部分字段。</li><li><code>DELETE</code>：删除资源。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250624142317574.png" alt="image-20250624142317574"></p><h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><p>在<strong>非RESTful风格的API</strong>中，查询和删除一般使用<code>GET</code>方式请求，更新和插入一般使用<code>POST</code>请求。从请求方式上无法知道API具体是干嘛的，所有<strong>在URL上都会有操作的动词</strong>来表示API进行的动作，例如：<code>query，add，update，delete</code>等。而<strong>RESTful风格的API</strong>则要求<strong>在URL上都以名词的方式出现</strong>，从几种请求方式上就可以看出想要进行的操作，这点与非RESTful风格的API形成鲜明对比。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /collection：从服务器查询资源的列表（数组）</span><br><span class="line">GET /collection/resource：从服务器查询单个资源</span><br><span class="line">POST /collection：在服务器创建新的资源</span><br><span class="line">PUT /collection/resource：更新服务器资源</span><br><span class="line">DELETE /collection/resource：从服务器删除资源</span><br></pre></td></tr></table></figure><table><thead><tr><th>HTTP Method</th><th>安全性</th><th>幂等性</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>安全</td><td>幂等</td><td>读操作安全，查询一次多次结果一致</td></tr><tr><td>POST</td><td>非安全</td><td>非幂等</td><td>写操作非安全，每多插入一次都会出现新结果</td></tr><tr><td>PUT</td><td>非安全</td><td>幂等</td><td>写操作非安全，一次和多次更新结果一致</td></tr><tr><td>DELETE</td><td>非安全</td><td>幂等</td><td>写操作非安全，一次和多次删除结果一致</td></tr></tbody></table><p><strong>安全性</strong>是指方法不会修改资源状态，即<strong>读的为安全的，写的操作为非安全的</strong>。而<strong>幂等性</strong>的意思是<strong>操作一次和操作多次的最终效果相同</strong>，客户端重复调用也只返回同一个结果。</p><h2 id="RESTful-API设计规范"><a href="#RESTful-API设计规范" class="headerlink" title="RESTful API设计规范"></a>RESTful API设计规范</h2><h3 id="URL设计规范"><a href="#URL设计规范" class="headerlink" title="URL设计规范"></a>URL设计规范</h3><p>URL为统一资源定位器，接口属于服务端资源，首先要通过URL这个定位到资源才能访问，一个完整的<code>URL</code>组成由以下几个部分构成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">URI</span> = scheme <span class="string">&quot;://&quot;</span> host  <span class="string">&quot;:&quot;</span>  port <span class="string">&quot;/&quot;</span> path [ <span class="string">&quot;?&quot;</span> query ][ <span class="string">&quot;#&quot;</span> fragment ]</span><br></pre></td></tr></table></figure><ul><li><code>scheme</code>：指底层用的协议，如<code>http</code>、<code>https</code>、<code>ftp</code></li><li><code>host</code>：服务器的IP地址或者域名</li><li><code>port</code>： 端口，http默认为<code>80</code>端口</li><li><code>path</code>：访问资源的路径，就是各种web 框架中定义的<code>route</code>路由</li><li><code>query</code>： 查询字符串，为发送给服务器的参数，在这里更多发送数据分页、排序等参数。</li><li><code>fragment</code>： 锚点，定位到页面的资源</li></ul><p>在设计API时URL的path是需要认真考虑的，而RESTful对path的设计做了一些规范，通常一个<code>RESTful API</code>的path组成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;</span><br></pre></td></tr></table></figure><ul><li><code>version</code>：API版本号，有些版本号放置在头信息（<code>headers</code>）中也可以，通过控制版本号有利于应用迭代。</li><li><code>resources</code>：资源，RESTful API推荐用小写英文单词的复数形式。</li><li><code>resource_id</code>：资源的id，访问或操作该资源。</li></ul><p>有时候可能资源级别较大，其下还可细分很多<code>子资源</code>也可以灵活设计URL的path，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/&#123;subresources&#125;/&#123;subresource_id&#125;</span><br></pre></td></tr></table></figure><p>有时可能增删改查无法满足业务要求，可以在URL末尾加上<code>action</code>，其中action就是对资源的操作。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/action</span><br></pre></td></tr></table></figure><h3 id="RESTful-API的URL具体设计规范"><a href="#RESTful-API的URL具体设计规范" class="headerlink" title="RESTful API的URL具体设计规范"></a>RESTful API的URL具体设计规范</h3><ul><li><p>不用大写字母，所有单词使用英文且小写。</p></li><li><p>连字符用中杠<code>&quot;-&quot;</code>而不用下杠<code>&quot;_&quot;</code></p></li><li><p>正确使用 <code>&quot;/&quot;</code>表示层级关系，URL的层级不要过深，并且越靠前的层级应该相对越稳定</p></li><li><p>结尾不要包含正斜杠分隔符<code>&quot;/&quot;</code></p></li><li><p>URL中不出现动词，用请求方式表示动作</p></li><li><p>资源表示用复数不要用单数</p></li><li><p>不要使用文件扩展名</p></li></ul><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a><strong>返回结果</strong></h2><h3 id="请求的处理执行结果"><a href="#请求的处理执行结果" class="headerlink" title="请求的处理执行结果"></a>请求的处理执行结果</h3><p>使用各类状态码来表示，状态码主要分为五大类：</p><table><thead><tr><th>状态码</th><th>表示意义</th></tr></thead><tbody><tr><td>1xx</td><td>相关信息</td></tr><tr><td>2xx</td><td>操作成功</td></tr><tr><td>3xx</td><td>重定向</td></tr><tr><td>4xx</td><td>客户端错误</td></tr><tr><td>5xx</td><td>服务器错误</td></tr></tbody></table><h3 id="响应的返回结果"><a href="#响应的返回结果" class="headerlink" title="响应的返回结果"></a>响应的返回结果</h3><p>响应结果包含<strong>状态码</strong>和<strong>返回数据</strong>两个部分。状态码同请求结果一致，<strong>返回结果</strong>针对不同操作，服务器向用户返回数据，基本都是返回<code>JSON</code>格式数据给客户端</p><p>参考原文链接：<a href="https://blog.csdn.net/weixin_46598480/article/details/142847343">Restful API</a></p>]]></content>
    
    
    <summary type="html">‌RESTful API是一种基于HTTP协议的架构风格，用于构建高效、可扩展的Web服务接口。‌</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="RestfulApi" scheme="https://southernfish.github.io/categories/Framwork/RestfulApi/"/>
    
    
    <category term="RestfulApi" scheme="https://southernfish.github.io/tags/RestfulApi/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务</title>
    <link href="https://southernfish.github.io/2025/06/23/framwork/spring-transaction/"/>
    <id>https://southernfish.github.io/2025/06/23/framwork/spring-transaction/</id>
    <published>2025-06-23T07:52:36.000Z</published>
    <updated>2025-06-24T14:24:28.353Z</updated>
    
    <content type="html"><![CDATA[<p>事务是一组操作的集合，是一个不可分割的操作。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。所以这组操作要么同时成功，要么同时失败。我们在进行程序开发时，也会有事务的需求。</p><h1 id="Spring事务基本信息"><a href="#Spring事务基本信息" class="headerlink" title="Spring事务基本信息"></a>Spring事务基本信息</h1><h2 id="Spring事务在解决什么问题"><a href="#Spring事务在解决什么问题" class="headerlink" title="Spring事务在解决什么问题"></a>Spring事务在解决什么问题</h2><ol><li><strong>‌数据一致性‌：</strong>在分布式系统中，多个服务或组件可能需要同时操作同一数据，事务确保这些操作要么全部成功，要么全部失败，从而保持数据的一致性。</li><li><strong>并发控制‌：</strong>在多用户并发访问的情况下，事务可以控制对共享资源的访问，避免数据冲突和损坏。</li><li><strong>故障恢复‌：</strong>当操作过程中发生错误时，事务可以回滚到操作前的状态，确保系统不会处于不一致的状态。</li></ol><h2 id="Spring事务的实现原理"><a href="#Spring事务的实现原理" class="headerlink" title="Spring事务的实现原理"></a>Spring事务的实现原理</h2><p>Spring事务的实现<strong>基于<code> AOP</code> （面向切面编程）和 动态代理</strong> 。Spring通过代理机制对目标对象进行包装，插入事务管理的逻辑，包括开启事务、提交事务和回滚事务等。具体来说：</p><ul><li>‌<strong>动态代理</strong>‌：Spring使用 <code>JDK动态代理</code> 或 <code>CGLIB动态代理</code> 来创建代理对象。</li><li>‌<strong>AOP</strong>‌：通过切面编程，在方法调用前后插入事务管理的逻辑。</li></ul><h2 id="Spring事务的配置和使用"><a href="#Spring事务的配置和使用" class="headerlink" title="Spring事务的配置和使用"></a>Spring事务的配置和使用</h2><p>在Spring中配置事务主要通过注解<code>@Transactional</code>来实现。该注解可以应用于类或方法上，指示该方法需要事务管理。</p><hr><h1 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h1><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><p><code>@Transactional</code>是Spring框架中用于<strong>声明式事务管理的关键注解</strong>，其<em>核心功能</em>是确保标注的方法或类在数据库操作中遵循ACID原则（原子性、一致性、隔离性、持久性），实现要么全部成功提交，要么全部回滚的机制。通过AOP（面向切面编程）实现，在方法执行前开启事务，执行后根据结果提交或回滚。‌‌参考文章 <a href="https://juejin.cn/post/7473315367490781195">深入解析 @Transactional——Spring 事务管理的核心</a></p><h2 id="Spring-事务默认的回滚规则"><a href="#Spring-事务默认的回滚规则" class="headerlink" title="Spring 事务默认的回滚规则"></a>Spring 事务默认的回滚规则</h2><p>只有未捕获的 <code>RuntimeException</code>（运行时异常）或 <code>Error</code> 才会触发回滚，而普通的 <code>Exception</code>（检查异常）不会触发回滚。</p><p>若你希望所有异常都能回滚，可加上 <code>rollbackFor = Exception.class</code>，避免出现“事务看起来生效了，但并没有真正回滚”的情况。</p><h2 id="常见属性配置"><a href="#常见属性配置" class="headerlink" title="常见属性配置"></a>常见属性配置</h2><table><thead><tr><th>属性</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>propagation</td><td>控制事务传播行为（如REQUIRED、REQUIRES_NEW）</td><td>@Transactional(propagation = Propagation.REQUIRED)</td></tr><tr><td>isolation</td><td>设置事务隔离级别（如READ_COMMITTED）</td><td>@Transactional(isolation = Isolation.READ_COMMITTED)</td></tr><tr><td>rollbackFor</td><td>指定触发回滚的异常类型</td><td>@Transactional(rollbackFor = Exception.class)</td></tr><tr><td>timeout</td><td>定义事务超时时间（秒）</td><td>@Transactional(timeout = 30)</td></tr></tbody></table><h2 id="Spring事务为什么会失效"><a href="#Spring事务为什么会失效" class="headerlink" title="Spring事务为什么会失效"></a>Spring事务为什么会失效</h2><ol><li><p><strong>try-catch导致的事务失效</strong></p><p>Spring 只有在方法抛出异常时，才会触发回滚。如果你在 catch 里吞掉了异常，那事务也就不会回滚了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePersonById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 触发异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//  catch 里吞掉了异常，Spring 感知不到异常的发生</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发生异常，但事务未回滚&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手动抛出异常</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePersonById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 触发异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;手动抛出异常，确保事务回滚&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异常自然传播</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePersonById</span><span class="params">(Long id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 事务会回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法不是public</strong></p><p><code>@Transactional</code> 只会作用于 <strong>public 方法</strong>，如果你加在 <code>private</code> 或 <code>protected</code> 方法上，事务不会生效。因为Spring 事务是通过 <strong>代理机制</strong> 实现的，而 JDK 动态代理只能代理 <code>public</code> 方法，所以其他访问级别的方法都不行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123; &#125; <span class="comment">// 事务不会生效</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123; &#125; <span class="comment">// 事务不会生效</span></span><br></pre></td></tr></table></figure></li><li><p><strong>同一类里，方法互相调用</strong></p><p>这里 <code>deleteDept</code> 方法调用了 <code>deleteEmp</code>，但 <code>deleteEmp</code> 上的 <code>@Transactional</code> <strong>不会生效</strong>！原因是：Spring 的事务是基于<strong>代理</strong>的，<code>this.deleteEmp(id)</code> 直接调用了本类的方法，没有经过 Spring 代理，所以事务不会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.deleteEmp(id); <span class="comment">// 事务不会生效！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteEmp</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        empMapper.delByDeptId(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的处理方法应是<strong>通过 Spring 管理的 Bean 调用</strong>(如下)，或者使用 <code>ApplicationContext</code> 获取代理对象，再调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptServiceImpl self;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDept</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        self.deleteEmp(id); <span class="comment">// 事务生效！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteEmp</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        empMapper.delByDeptId(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据库引擎不支持事务</strong></p><p>如果你用的 MySQL <strong>表引擎是 MyISAM</strong>，事务是不可能生效的，因为 MyISAM <strong>根本不支持事务</strong>！要确保你的表是 InnoDB：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">WHERE</span> Name <span class="operator">=</span> <span class="string">&#x27;dept&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dept ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Transactional的传播机制"><a href="#Transactional的传播机制" class="headerlink" title="@Transactional的传播机制"></a>@Transactional的传播机制</h2><p>@Transactional注解<strong>支持多种事务传播机制</strong>，这些机制定义了事务的行为方式。通过<code>Propagation</code>配置，主要的传播机制及含义如下： </p><table><thead><tr><th>传播类型</th><th>含义</th></tr></thead><tbody><tr><td>Propagation.REQUIRED</td><td>如果当前已有事务则加入当前事务，否则开启新的事务</td></tr><tr><td>Propagation.REQUIRED_NEW</td><td>无论当前是否有事务都开启新的事务；如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>Propagation.SUPPORTED</td><td>如果当前事务存在就加入事务，否则以非事务运行</td></tr><tr><td>Propagation.NOT_SUPPORTED</td><td>始终以非事务方式执行；如果当前存在事务，则挂起当前事务</td></tr><tr><td>Propagation.NEVER</td><td>不使用事务，如果当前事务存在，则抛出异常</td></tr><tr><td>Propagation.MANDATORY</td><td>当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</td></tr><tr><td>Propagation.NESTED</td><td>父子（嵌套）事务，父提交子提交，父回滚全回滚，子回滚不影响父事务</td></tr></tbody></table><p>这些传播机制提供了灵活的事务控制选项，可以根据不同的业务需求选择合适的事务行为，避免事务的方法过于长，一个事务里面调用的库表越多，就越有可能造成死锁，所以我们要根据具体的需要拆分使用。例如:</p><ul><li>在需要<em>确保操作完全独立于其他事务时，可以使用REQUIRES_NEW</em>；</li><li>在<em>不需要事务时，可以使用NOT_SUPPORTED或NEVER</em>；</li><li>在<em>需要嵌套事务时，可以使用NESTED</em>等</li></ul><p>避免事务的方法过于长，一个事务里面调用的库表越多，就越有可能造成死锁，所以我们要根据具体的需要拆分使用</p><h2 id="高吞吐量下使用-Transactional注解导致性能降低"><a href="#高吞吐量下使用-Transactional注解导致性能降低" class="headerlink" title="高吞吐量下使用@Transactional注解导致性能降低"></a>高吞吐量下使用<code>@Transactional</code>注解导致性能降低</h2><ol><li><p><strong>批量处理</strong></p><p>尽可能将多个数据库操作合并到单个事务中。例如，可以使用JDBC的<code>batch updates</code>或者在<code>ORM框架</code>（如Spring Data JPA, Hibernate）中利用其批量操作功能。 示例（<code>Spring Data JPA</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchSave</span><span class="params">(List&lt;Entity&gt; entities)</span> &#123;</span><br><span class="line">    entityRepository.saveAll(entities);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>减少事务范围</strong> </p><p>尽量减小@Transactional注解覆盖的方法范围。只在确实需要事务控制的代码块上使用@Transactional。例如，只在服务层而非控制器层使用事务。 </p></li><li><p> <strong>异步事务处理</strong> </p></li></ol><p>   对于非阻塞操作，可以考虑将事务逻辑移至异步处理中。例如，使用<code>@Async</code>注解来异步执行事务操作，但这通常需要额外的配置来确保事务的正确管理。示例（Spring <code>@Async</code>）：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncTransactionalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行事务操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>优化数据库配置</strong></p><ul><li><p><strong>索引优化</strong>：确保数据库表上有适当的索引，以加快查询和插入速度。</p></li><li><p><strong>连接池优化</strong>：使用高效的数据库连接池（如<code>HikariCP</code>），并合理配置其参数（如最大连接数、连接超时时间等）。</p></li><li><p><strong>读写分离</strong>：对于读多写少的应用，可以考虑实现数据库的读写分离。</p></li></ul></li><li><p><strong>避免大事务</strong></p><ul><li>避免在单个事务中处理大量数据。如果可能，将大事务拆分成多个小事务。</li></ul></li><li><p><strong>使用乐观锁或悲观锁</strong></p><ul><li>在高并发场景下，使用乐观锁或悲观锁可以减少锁的竞争，提高并发性能。乐观锁通常用于写操作较少的情况，而悲观锁则适用于写操作较多的情况。</li></ul></li></ol><hr><h1 id="Transactional大事务处理"><a href="#Transactional大事务处理" class="headerlink" title="@Transactional大事务处理"></a>@Transactional大事务处理</h1><p> 此处转载自原文 <a href="https://blog.csdn.net/huangchong0107/article/details/136652281">Springboot @Transactional大事务处理的几点建议</a></p><h2 id="什么是大事务"><a href="#什么是大事务" class="headerlink" title="什么是大事务"></a><strong>什么是大事务</strong></h2><p>总体任务对应的事务<a href="https://so.csdn.net/so/search?q=%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4&spm=1001.2101.3001.7020">运行时间</a>比较长，长时间未提交的事务</p><h2 id="大事务的危害"><a href="#大事务的危害" class="headerlink" title="大事务的危害"></a><strong>大事务的危害</strong></h2><ul><li>并发情况下，数据库连接池资源占满。大事务提交不及时，导致连接资源释放缓慢。</li><li>数据库死锁和锁等待。<code>innodb</code>引擎背景下，事务如果占用了排他锁，会容易导致并发情况下数据死锁或者锁等待。</li><li>大事务Rt时间长，容易导致接口超时。</li><li>大事务回滚时间长。</li><li>数据库主从架构下，数据同步延迟</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><ul><li><p><strong>将声明式事务的@Transactional方式 合理的替换为 编程式事务TransactionTemplate 的方式</strong><br>声明式事务的粒度最小是整个方法，可能会导致业务里不必要的逻辑都加了事务。编程式事务细化需要加事务的逻辑上，形成实际有用的事务块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// ....  业务代码</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//回滚</span></span><br><span class="line">                transactionStatus.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>将查询放在事务方法外</strong><br>使用@Transactional 又想避免产生大事务，需对方法进行拆分，将不需要事务管理的逻辑与事务操作分开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTestService</span>&#123;</span><br><span class="line">    <span class="comment">// 避免同一个类内部方法相互调用，实例方法调用代理方法而导致事务失效</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTestService service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        service.save(dto);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//事务操作</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">        paramDao.insert(dto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>避免跨服务间的远程调用</strong><br>服务间的通讯及服务之间的调用时间 受网络环境和远端接口Rt时间的影响，可能会比较耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例：</span></span><br><span class="line"><span class="comment">// 事务操作</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用了其他服务</span></span><br><span class="line">    otherRemoteApi();</span><br><span class="line">    paramDao.insert(dto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改为：</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(ParamDto dto)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用了其他服务</span></span><br><span class="line">    otherRemoteApi();</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                  paramDao.insert(dto);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//回滚</span></span><br><span class="line">                transactionStatus.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>事务中不应该一次性处理太多的数据，可以使用分批执行</strong></p></li><li><p><strong>事务中的方法可以根据业务使用异步执行</strong></p></li></ul>]]></content>
    
    
    <summary type="html">Spring事务是一组操作的集合，是一个不可分割的操作。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。</summary>
    
    
    
    <category term="Framwork" scheme="https://southernfish.github.io/categories/Framwork/"/>
    
    <category term="Spring" scheme="https://southernfish.github.io/categories/Framwork/Spring/"/>
    
    
    <category term="Spring Boot" scheme="https://southernfish.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>并发编程</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-concurrency/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-concurrency/</id>
    <published>2025-06-23T06:29:36.000Z</published>
    <updated>2025-06-24T14:24:28.353Z</updated>
    
    <content type="html"><![CDATA[<p>并发，在<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA/128842?fromModule=lemma_inlink">处理机</a>上运行，但任一个时刻点上只有一个程序在处理机上运行。本文转载自<a href="https://blog.csdn.net/linxiaosongXXDDDGS/article/details/147779420">Java并发编程详解</a>。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程的本质"><a href="#线程的本质" class="headerlink" title="线程的本质"></a>线程的本质</h3><p><strong>线程是轻量级进程：</strong>在同一个进程中，多个线程共享内存空间（堆、方法区），但每个线程拥有独立的栈和程序计数器（PC）。<br>并发 vs 并行：</p><ul><li><strong>并发：</strong>线程在单核CPU上交替执行（时间片轮转）。</li><li><strong>并行：</strong>多核CPU上线程真正同时运行</li></ul><h3 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：继承Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running by extending Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：实现Runnable接口（推荐，避免单继承限制，在Java中，类只能继承一个父类（单继承），但可以实现多个接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running by implementing Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式1 启动线程（调用start()，而非run()！直接调用run()只是普通方法调用，不会创建新线程）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Runnable</code>优势总结：</p><ul><li><strong>解耦任务与线程：</strong>Runnable表示任务逻辑，<code>Thread</code>表示线程载体，符合面向对象的职责分离原则。</li><li><strong>资源共享：</strong>多个线程可共享同一个Runnable实例（例如售票系统的共享票池）。</li><li><strong>灵活组合：</strong>可与线程池（<code>ExecutorService</code>）、<code>Lambda表达式</code>等现代特性无缝结合。</li></ul><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ol><li>新建（<code>New</code>）：线程对象已创建，但未调用<code>start()</code>。</li><li>就绪（<code>Runnable</code>）：调用<code>start()</code>后，等待CPU调度。</li><li>运行（<code>Running</code>）：获得CPU时间片，执行<code>run()</code>方法。</li><li>阻塞（<code>Blocked</code>）：因等待锁、I/O操作或<code>sleep()</code>等暂停执行。</li><li>终止（<code>Terminated</code>）：<code>run()</code>执行完毕或发生未捕获异常。</li></ol><h2 id="线程同步锁机制"><a href="#线程同步锁机制" class="headerlink" title="线程同步锁机制"></a>线程同步锁机制</h2><h3 id="1、竞态条件（Race-Condition）"><a href="#1、竞态条件（Race-Condition）" class="headerlink" title="1、竞态条件（Race Condition）"></a>1、竞态条件（Race Condition）</h3><p>当多个线程同时访问共享资源且未正确同步时，结果依赖于线程执行顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 典型竞态条件示例：不安全的计数器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 非原子操作（实际为 read-modify-write）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、同步解决方案"><a href="#2、同步解决方案" class="headerlink" title="2、同步解决方案"></a>2、同步解决方案</h3><ul><li><p><code>synchronized</code> 关键字：</p><ul><li><strong>同步方法</strong>：锁对象为当前实例（<code>this</code>）或类对象（静态方法）。</li><li><strong>同步代码块</strong>：显式指定锁对象（任意对象）。</li></ul></li><li><p><strong>Lock 接口</strong>（更灵活，支持超时、公平锁）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeCounterWithLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、volatile-关键字"><a href="#3、volatile-关键字" class="headerlink" title="3、volatile 关键字"></a>3、volatile 关键字</h3><ul><li><strong>保证可见性</strong>：对<code>volatile</code>变量的修改立即对其他线程可见。</li><li><strong>禁止指令重排序</strong>：防止编译器和CPU优化导致的执行顺序错乱。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toggleFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = !flag; <span class="comment">// 非原子操作，volatile仅保证可见性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a>线程间的协作</h2><h3 id="1、-wait-、notify-、notifyAll"><a href="#1、-wait-、notify-、notifyAll" class="headerlink" title="1、 wait()、notify()、notifyAll()"></a>1、 wait()、notify()、notifyAll()</h3><ul><li><p>Object类的核心方法：</p><ul><li><p><code>wait()</code>：释放锁并进入等待状态。</p></li><li><p><code>notify()</code>：随机唤醒一个等待线程。</p></li><li><p><code>notifyAll()</code>：唤醒所有等待线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> item)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">            wait(); <span class="comment">// 缓冲区满，等待消费者消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(item);</span><br><span class="line">        System.out.println(<span class="string">&quot;生产: &quot;</span> + item + <span class="string">&quot;，当前队列大小: &quot;</span> + queue.size());</span><br><span class="line">        notifyAll(); <span class="comment">// 通知消费者可以消费</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者线程逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            wait(); <span class="comment">// 缓冲区空，等待生产者生产</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;消费: &quot;</span> + item + <span class="string">&quot;，剩余队列大小: &quot;</span> + queue.size());</span><br><span class="line">        notifyAll(); <span class="comment">// 通知生产者可以生产</span></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Producer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟消费耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2、Condition-接口"><a href="#2、Condition-接口" class="headerlink" title="2、Condition 接口"></a>2、Condition 接口</h3><ul><li>与<code>Lock</code>配合使用，提供更精细的线程等待与唤醒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> item)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                notFull.await(); <span class="comment">// 等待&quot;非满&quot;条件</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(item);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产: &quot;</span> + item + <span class="string">&quot;，队列大小: &quot;</span> + queue.size());</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 触发&quot;非空&quot;条件</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                notEmpty.await(); <span class="comment">// 等待&quot;非空&quot;条件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费: &quot;</span> + item + <span class="string">&quot;，剩余队列大小: &quot;</span> + queue.size());</span><br><span class="line">            notFull.signal(); <span class="comment">// 触发&quot;非满&quot;条件</span></span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AdvancedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvancedBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建生产者线程（Lambda实现Runnable）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                    Thread.sleep(<span class="number">800</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a><a href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">并发编程</a></h1><h2 id="并发工具类-java-util-concurrent"><a href="#并发工具类-java-util-concurrent" class="headerlink" title="并发工具类(java.util.concurrent)"></a>并发工具类(java.util.concurrent)</h2><h3 id="1、Executor-框架"><a href="#1、Executor-框架" class="headerlink" title="1、Executor 框架"></a>1、Executor 框架</h3><ul><li><p><strong>线程池管理</strong>：避免频繁创建/销毁线程的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建固定大小的线程池（4个线程）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交10个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由 &quot;</span> </span><br><span class="line">                    + Thread.currentThread().getName() + <span class="string">&quot; 执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池（不再接受新任务）</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、并发集合"><a href="#2、并发集合" class="headerlink" title="2、并发集合"></a>2、并发集合</h3><ul><li><p><strong>线程安全容器</strong>：避免手动同步。</p><ul><li><p><code>CopyOnWriteArrayList</code>：读多写少场景。</p></li><li><p><code>ConcurrentHashMap</code>：高并发哈希表。</p></li><li><p><code>BlockingQueue</code>：阻塞队列（如<code>LinkedBlockingQueue</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap 示例</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个写线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key-&quot;</span> + threadId + <span class="string">&quot;-&quot;</span> + j;</span><br><span class="line">                    map.put(key, j);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;写线程 &quot;</span> + threadId + <span class="string">&quot; 完成&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建读线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前Map大小: &quot;</span> + map.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、原子类（Atomic）"><a href="#3、原子类（Atomic）" class="headerlink" title="3、原子类（Atomic）"></a>3、原子类（Atomic）</h3><ul><li><p>基于CAS（Compare-And-Swap）保证原子性，实现无锁线程安全。</p></li><li><p>性能优于<code>synchronized</code>，适用于高并发场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count.incrementAndGet(); <span class="comment">// 原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count.get()); <span class="comment">// 正确输出20000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、CountDownLatch-与-CyclicBarrier"><a href="#4、CountDownLatch-与-CyclicBarrier" class="headerlink" title="4、CountDownLatch 与 CyclicBarrier"></a>4、CountDownLatch 与 CyclicBarrier</h3><ul><li><p><strong>CountDownLatch</strong>：等待多个任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TASK_COUNT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(TASK_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动多个任务线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= TASK_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 完成&quot;</span>);</span><br><span class="line">                latch.countDown(); <span class="comment">// 计数器减1    多个线程调用 latch.countDown()</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待所有任务完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务已完成，继续主线程逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>CyclicBarrier</strong>：多个线程相互等待至屏障点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; System.out.println(<span class="string">&quot;All threads reached barrier&quot;</span>));</span><br><span class="line"><span class="comment">// 每个线程调用 barrier.await()</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="典型陷阱"><a href="#典型陷阱" class="headerlink" title="典型陷阱"></a>典型陷阱</h2><h3 id="1、死锁（Deadlock）"><a href="#1、死锁（Deadlock）" class="headerlink" title="1、死锁（Deadlock）"></a>1、死锁（Deadlock）</h3><p>四个必要条件：</p><ol><li><strong>互斥</strong>：资源只能被一个线程持有。</li><li><strong>占有且等待</strong>：线程持有资源并等待其他资源。</li><li><strong>不可抢占</strong>：资源不能被强制释放。</li><li><strong>循环等待</strong>：多个线程形成环形等待链。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死锁示例</span></span><br><span class="line"><span class="comment">// Thread 1: lock A → try lock B</span></span><br><span class="line"><span class="comment">// Thread 2: lock B → try lock A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程1：先获取lockA，再请求lockB</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 持有lockA&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1 获取lockB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2：先获取lockB，再请求lockA</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 持有lockB&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 获取lockA&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：破坏任一条件，如按固定顺序获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免死锁（统一锁顺序）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockSolution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有线程按相同顺序获取锁（先lockA后lockB）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; acquireLocks(lockA, lockB, <span class="string">&quot;线程1&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; acquireLocks(lockA, lockB, <span class="string">&quot;线程2&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">acquireLocks</span><span class="params">(Object firstLock, Object secondLock, String threadName)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (firstLock) &#123;</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; 持有 &quot;</span> + firstLock);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (secondLock) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">&quot; 获取 &quot;</span> + secondLock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、活锁（Livelock）"><a href="#2、活锁（Livelock）" class="headerlink" title="2、活锁（Livelock）"></a>2、活锁（Livelock）</h3><p>线程不断重试失败的操作（如谦让式资源释放），但无法推进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 活锁示例：两个线程互相让出CPU</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryLock(lockA)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryLock(lockB)) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; unlock(lockA); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.yield(); <span class="comment">// 让出CPU但未解决问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LivelockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">active</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Runnable task, Worker otherWorker)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!active) &#123;</span><br><span class="line">                <span class="keyword">if</span> (otherWorker.active) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;让出执行权...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    active = <span class="literal">true</span>;</span><br><span class="line">                    task.run();</span><br><span class="line">                    active = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    active = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; worker1.work(() -&gt; System.out.println(<span class="string">&quot;Worker1执行任务&quot;</span>), worker2)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; worker2.work(() -&gt; System.out.println(<span class="string">&quot;Worker2执行任务&quot;</span>), worker1)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、资源竞争与性能问题"><a href="#3、资源竞争与性能问题" class="headerlink" title="3、资源竞争与性能问题"></a>3、资源竞争与性能问题</h3><p>资源竞争和性能问题是并发编程中的核心挑战之一。以下通过具体示例展示资源竞争导致的数据错误，以及不同锁策略对性能的影响，并给出优化方案。</p><ul><li><strong>锁粒度</strong>：粗粒度锁（简单但低效） vs 细粒度锁（复杂但高效）。</li><li><strong>锁分离</strong>：如<code>ReadWriteLock</code>分离读锁与写锁。</li></ul><p><strong>示例1：资源竞争导致数据错误（未同步的计数器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeCounterExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count++; <span class="comment">// 非原子操作：read → modify → write</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动两个线程同时修改count</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预期结果：20000，实际结果可能小于20000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count); <span class="comment">// 结果不确定，因线程竞争而异</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ul><li><p><code>count++</code> 是非原子操作，实际包含以下步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int tmp = count;  // Step 1: 读取当前值</span><br><span class="line">tmp = tmp + 1;    // Step 2: 修改值</span><br><span class="line">count = tmp;      // Step 3: 写回新值</span><br></pre></td></tr></table></figure></li><li><p>当两个线程同时执行时，可能出现以下时序：</p><ul><li>线程A读取<code>count=100</code> → 线程B读取<code>count=100</code> → 线程A写入<code>101</code> → 线程B写入<code>101</code></li><li>最终结果为<code>101</code>，而非预期的<code>102</code>。</li></ul></li></ul><p><strong>示例2：粗粒度锁的性能问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoarseLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 粗粒度锁：锁住整个循环</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Final count: <span class="number">200000</span></span><br><span class="line">耗时: 120ms  <span class="comment">// 实际时间因机器性能而异，但明显较长</span></span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ul><li><strong>粗粒度锁</strong>：将整个循环包裹在<code>synchronized</code>块内，每次循环都会获取/释放锁。</li><li><strong>性能问题</strong>：频繁的锁竞争导致大量线程上下文切换，CPU时间浪费在锁管理而非实际计算。</li></ul><p><strong>示例3：细粒度锁优化（减少锁范围）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FineGrainedLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">localCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                localCount++; <span class="comment">// 先在线程本地累加</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 仅对最终合并操作加锁</span></span><br><span class="line">                count += localCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Final count: <span class="number">200000</span></span><br><span class="line">耗时: 5ms  <span class="comment">// 性能显著提升</span></span><br></pre></td></tr></table></figure><p><strong>优化分析</strong>：</p><ul><li><strong>细粒度锁</strong>：线程先在本地变量<code>localCount</code>中累加，最后仅对合并操作加锁。</li><li><strong>性能提升</strong>：锁竞争频率从每次循环减少到每线程一次，大幅降低同步开销。</li></ul><p><strong>示例4：锁分离（读写锁优化）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 写线程（频繁修改数据）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                rwLock.writeLock().lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    value++;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>); <span class="comment">// 模拟写操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    rwLock.writeLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读线程（频繁读取数据）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">reader</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                rwLock.readLock().lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;读取 value: &quot;</span> + value);</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>); <span class="comment">// 模拟读操作耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    rwLock.readLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动2个写线程和4个读线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(reader).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化分析</strong>：</p><ul><li><strong>读写锁分离：</strong><ul><li><strong>读锁（共享锁）</strong>：允许多个线程同时读数据。</li><li><strong>写锁（独占锁）</strong>：仅允许单个线程写数据，且与读锁互斥。</li></ul></li><li><strong>适用场景</strong>：读多写少（如缓存系统），通过减少锁竞争提升吞吐量。</li></ul><hr><h1 id="关键性总结"><a href="#关键性总结" class="headerlink" title="关键性总结"></a>关键性总结</h1><ol><li><strong>资源竞争问题</strong>：<ul><li><strong>表现</strong>：多线程同时修改共享数据导致结果错误（如计数器值不准确）。</li><li><strong>解决方案</strong>：使用同步机制（<code>synchronized</code>、<code>Lock</code>）保证原子性。</li></ul></li><li><strong>性能优化策略</strong>：<ul><li><strong>减少锁粒度</strong>：仅对必要代码块加锁（如示例3的本地累加优化）。</li><li><strong>锁分离</strong>：读写锁（<code>ReadWriteLock</code>）区分读写操作，提升并发度。</li><li><strong>无锁编程</strong>：使用原子类（<code>AtomicInteger</code>）或并发容器（<code>ConcurrentHashMap</code>）。</li></ul></li><li><strong>性能测试建议</strong>：<ul><li>对比不同锁策略的耗时（如示例2和示例3的耗时差异）。</li><li>使用性能分析工具（如<code>JProfiler</code>、<code>VisualVM</code>）定位瓶颈。</li></ul></li></ol><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol><li>**优先使用高层并发工具:**如<code>Executor</code>、<code>ConcurrentHashMap</code>。</li><li><strong>避免过早优化：</strong>仅在性能瓶颈出现时考虑低层同步。</li><li><strong>测试并发代码：</strong>使用压力测试工具（如<code>JMeter</code>）和静态分析工具（如<code>FindBugs</code>）。</li><li><strong>遵循不变性（Immutability）：</strong>使用<code>final</code>字段和不可变对象（如<code>String</code>）。</li></ol>]]></content>
    
    
    <summary type="html">并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="Concurrency" scheme="https://southernfish.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>List</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-list/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-list/</id>
    <published>2025-06-23T06:15:36.000Z</published>
    <updated>2025-06-24T14:24:28.354Z</updated>
    
    <content type="html"><![CDATA[<p>List 是 Java 集合框架中的有序列表，元素按插入顺序存储，支持通过索引（从 0 开始）访问。类似数组，但提供动态增删功能，避免数组手动扩容和元素移动的繁琐。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="List的接口方法"><a href="#List的接口方法" class="headerlink" title="List的接口方法"></a>List的接口方法</h2><p>List接口继承自<code>Collection</code>接口，提供了额外的功能来处理索引位置上的元素。与Set、Map不同，List允许包含重复的元素，并且可以通过索引来访问或修改特定位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 核心接口方法 */</span></span><br><span class="line">add(E e) <span class="comment">// 添加指定元素到列表末尾。</span></span><br><span class="line">add(<span class="type">int</span> index, E element)<span class="comment">// 在指定索引处插入指定元素。</span></span><br><span class="line">remove(<span class="type">int</span> index) <span class="comment">// 移除指定索引处的元素。</span></span><br><span class="line">get(<span class="type">int</span> index) <span class="comment">// 获取指定索引处的元素。</span></span><br><span class="line">set(<span class="type">int</span> index, E element) <span class="comment">// 替换指定索引处的元素。</span></span><br><span class="line">size() <span class="comment">// 返回列表中的元素数量。</span></span><br><span class="line"><span class="comment">/* 其他常用方法 */</span> </span><br><span class="line">isEmpty() <span class="comment">// 判断列表是否为空。</span></span><br><span class="line">contains(Object o) <span class="comment">// 检查列表是否包含指定元素。</span></span><br><span class="line">indexOf(Object o) <span class="comment">// 返回指定元素首次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">lastIndexOf(Object o) <span class="comment">// 返回指定元素最后一次出现的索引，如果不存在则返回-1。</span></span><br><span class="line">subList(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex) <span class="comment">// 获取从fromIndex（包括）到toIndex（不包括）之间的子列表</span></span><br></pre></td></tr></table></figure><h2 id="主要实现类"><a href="#主要实现类" class="headerlink" title="主要实现类"></a>主要实现类</h2><ol><li><p><code>ArrayList</code></p><p>ArrayList是最常用的List实现之一，它基于动态数组实现，支持随机访问，查询效率高，但插入和删除效率较低。<br><strong>特点</strong>：支持快速随机访问。非线程安全。初始容量为10，每次扩容时增长50%。<br><strong>使用场景</strong>：适用于频繁读取而不经常修改的数据集合。</p></li><li><p><code>LinkedList</code></p><p>LinkedList是另一个重要的List实现，它基于双向链表实现，对于插入和删除操作具有较高的性能，但对于随机访问效率较低。<br><strong>特点</strong>：支持高效的插入和删除操作。非线程安全。可以作为堆栈、队列或双端队列使用。<br><strong>使用场景</strong>：适用于频繁进行插入和删除操作的数据集合。</p></li><li><p><code>Vector</code></p><p>早期线程安全集合类，通过方法级<code>synchronized</code>实现同步。默认扩容增长一倍。<br><strong>特点</strong>：线程安全同步锁导致并发效率低下（方法都使用了 synchronized）。性能低（主要用于同步开销）。遗留类，不推荐使用</p></li><li><p>三者对比</p><table><thead><tr><th></th><th>ArrayList</th><th>LinkedList</th><th>Vector</th></tr></thead><tbody><tr><td>底层结构</td><td>动态数组</td><td>双向链表</td><td>动态数组</td></tr><tr><td>线程安全</td><td>不安全</td><td>不安全</td><td>安全，方法都加了<code>Synchronized</code></td></tr><tr><td>是否允许重复元素</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>是否有序</td><td>是</td><td>是</td><td>是</td></tr><tr><td>随机访问</td><td>快O(1)，索引访问</td><td>慢O(n)，需遍历链表</td><td>快O(1)，但因同步影响性能较低</td></tr><tr><td>插入/删除</td><td>慢O(n)，需移动元素</td><td>快O(1)，只需修改指针</td><td>慢，同步开销大</td></tr><tr><td>扩容机制</td><td>默认增长50%</td><td>无需扩容，动态添加节点</td><td>默认翻倍容量</td></tr><tr><td>加载因子</td><td>1</td><td>无</td><td>1</td></tr></tbody></table></li></ol><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ol><li><p><code>for</code>循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：可以灵活控制索引。支持随机访问（适合 ArrayList）。</span></span><br><span class="line"><span class="comment">// 缺点：对于 LinkedList 来说效率较低（因为每次都要从头开始查找元素）。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Index: &quot;</span> + i + <span class="string">&quot;, Value: &quot;</span> + list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：简洁易读。适用于所有实现了 Iterable 接口的集合类。</span></span><br><span class="line"><span class="comment">// 缺点：无法获取索引。不能修改集合结构（如删除元素会抛出异常）。</span></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Item: &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Iterator</code>。可以安全地在遍历时进行删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(item)) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 安全删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="去重方式"><a href="#去重方式" class="headerlink" title="去重方式"></a>去重方式</h2><ol><li><p>利用 <code>HashSet</code> 或 <code>LinkedHashSet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet 不保留顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出顺序可能不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashSet 保留插入顺序</span></span><br><span class="line">List&lt;Integer&gt; uniqueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(list));</span><br><span class="line">System.out.println(uniqueList);  <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Stream.distinct()</code>，Java 8+ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; uniqueList = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(uniqueList);</span><br></pre></td></tr></table></figure></li></ol><h2 id="List-与数组的转换"><a href="#List-与数组的转换" class="headerlink" title="List 与数组的转换"></a>List 与数组的转换</h2><ul><li><p>List 转数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无类型参数：丢失类型信息</span></span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line"><span class="comment">// 带类型参数：推荐，自动匹配类型</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 函数式写法</span></span><br><span class="line">String[] array = list.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li><li><p>数组转 List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(array);（只读）</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));（可修改）</span><br></pre></td></tr></table></figure></li></ul><h2 id="List-的元素判断机制"><a href="#List-的元素判断机制" class="headerlink" title="List 的元素判断机制"></a>List 的元素判断机制</h2><p>List的 <code>contains(Object o)</code> 和 <code>indexOf(Object o)</code> 方法通过 <code>equals()</code>而非 <code>==</code> 判断元素是否相等。</p><hr><h1 id="List的安全类"><a href="#List的安全类" class="headerlink" title="List的安全类"></a>List的安全类</h1><p>在单线程应用中，通常采取<code>new ArrayList()</code>，指定一个List集合，用于存放可重复的数据。但<code>ArrayList</code>是不安全的集合。多线程操作同一集合对象信息，往往会出现<code>java.util.ConcurrentModificationException</code>异常报错信息。</p><h2 id="Java的安全类Vector"><a href="#Java的安全类Vector" class="headerlink" title="Java的安全类Vector"></a>Java的安全类Vector</h2><p>java提供了<code>java.util.Vector</code>类，多线程下不会出现<code>java.util.ConcurrentModificationException</code>报错信息。因为采取了 <code>synchronized</code> 针对方法执行调用者加锁，保证add操作的多线程安全性！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建lists集合</span></span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUC下的安全List集合"><a href="#JUC下的安全List集合" class="headerlink" title="JUC下的安全List集合"></a>JUC下的安全List集合</h2><ol><li><code>Collections.synchronizedList(new ArrayList&lt;&gt;());</code>。该方法返回具有同步包装器的List，保证了对List的操作是安全的。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&quot;</span> + lists);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">( <span class="meta">@NotNull</span> List&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(list <span class="keyword">instanceof</span> RandomAccess ? </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) : </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">synchronizedList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断传入的 list 集合类型，判断类型是否为 java.util.RandomAccess，如果是则采取java.util.Collections.SynchronizedRandomAccessList构造集合，如果不是则采取java.util.Collections.SynchronizedList构造集合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码中对应的add操作逻辑如下所示。采取synchronized同步代码块的方式，对数据的add操作实现加锁！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>&#123; </span><br><span class="line">    synchron1zed (mutex) &#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>new CopyOnWriteArrayList();</code>。该类中所有修改操作都在一个独立的副本上进行，不会影响原始数据，保证了线程安全。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启十个线程增加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                lists.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&quot;</span>+lists);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates an empty list</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyonWriteArrayList</span><span class="params">()</span>&#123; setArray(<span class="keyword">new</span> <span class="title class_">object</span>[<span class="number">0</span>]); &#125;</span><br><span class="line"><span class="comment">// add 逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[]elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copy0f(elements, len +<span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong><code>add</code>逻辑如下所示</strong><br>  1、调用add方法后，拿到<code>java.util.concurrent.locks.ReentrantLock</code>对象信息。<br>  2、调用 <code>lock.lock()</code> 拿到锁！<br>  3、将原数组对象<code>copy</code>操作，并创建<code>原数组大小+1</code>的新数组。<br>  4、将新数据放入新数组中。<br>  5、任何操作<code>finally</code>，都进行锁的释放！</p><p>原文链接：<a href="https://blog.csdn.net/qq_47980550/article/details/148012216">java基础——java集合list详解</a>、<a href="https://blog.csdn.net/qq_38322527/article/details/114703142">JUC中的List安全类集合</a></p>]]></content>
    
    
    <summary type="html">List是 Java 集合框架中的有序列表，元素按插入顺序存储，支持通过索引（从 0 开始）访问。类似数组，但提供动态增删功能，避免数组手动扩容和元素移动的繁琐。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Set</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-set/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-set/</id>
    <published>2025-06-23T05:49:36.000Z</published>
    <updated>2025-06-24T14:24:28.354Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的Set是集合框架（Collection Framework）的核心接口之一，用于存储无序且唯一的元素。主要实现类包括HashSet（基于哈希表）、LinkedHashSet（维护插入顺序）和TreeSet（基于红黑树排序），三者分别适用于快速查找、保持插入顺序和自然排序的场景。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>List是有序集合的根接口，Set是无序集合的根接口，无序也就意味着元素不重复。更严格地说，Set集合不包含一对元素e1和e2 ，使得e1.equals(e2) ，并且最多一个空元素。<br>使用Set存储的特点与List相反：<strong>元素无序、不可重复</strong>。常用的实现方式：HashSet、LinkedHashSet和TreeSet。</p><table><thead><tr><th>具体实现</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashSet</td><td>底层数据结构是哈希表，可以存储null元素，效率高</td><td>线程不安全，需要重写hashCode()和equals()来保证元素唯一性</td></tr><tr><td>LinkedHashSet</td><td>底层数据结构是链表和哈希表(链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性)，效率高</td><td>线程不安全</td></tr><tr><td>TreeSet</td><td>底层数据结构是二叉树，元素唯一且已经排好序</td><td>需要重写hashCode和equals()来保证元素唯一性</td></tr></tbody></table><p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的<code>hashCode()</code>方法来得到该对象的hashCode值，然后根据hashCode值来决定该对象在HashSet中存储位置。简单的说，<strong>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等</strong>。<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p><p>在使用Set存储数据时，为保障元素唯一性，常常要重写hashCode。重写hashCode方法时，尽量遵循以下原则：</p><ul><li>相同的对象返回相同的hashCode值。</li><li>不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。</li><li>尽量的让hashCode值散列开（用异或运算可使结果的范围更广）。</li></ul><p>原文链接：<a href="https://blog.csdn.net/m0_37741420/article/details/112407684">Java集合（四）Set的常用实现类</a></p><hr><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>HashSet是一个无序集合，其底层结构是HashMap，简单来说，HashSet是value是固定值（<code>Object PRESENT = new Object()</code>）的HashMap。HashSet的特点(<strong>底层是HashMap/元素无序且不能重复/线程不安全</strong>)：</p><ul><li><p>HashSet的<strong>底层实现是HashMap</strong>（HashSet的值存放于HashMap的key上，HashMap的value是一个统一的值）。</p></li><li><p>HashSet中的<strong>元素无序且不能重复</strong>（从插入HashSet元素的顺序和遍历HashSet的顺序对比可以看出：遍历顺序和存入到Set的顺序并不一致）。</p></li><li><p>HashSet是<strong>线程不安全</strong>的。如果要保证线程安全，其中一种方法是将其改造成线程安全的类，示例：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>(...));</span><br></pre></td></tr></table></figure></li><li><p>HashSet<code>允许存入null</code></p></li></ul><h2 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h2><p>把对象加入HashSet时，HashSet会<strong>先计算对象的hashcode值来判断对象加入的位置</strong>，同时也会与Set中其他元素的hashcode值作比较，如果没有相同的hashcode，HashSet会假设对象没有重复出现。如果发现有相同hashcode值的对象，这时会调用<code>equals</code>方法来检查<strong>hashcode相等的对象是否真的相同</strong>。如果两者相同，HashSet就不再存储该元素。<code>hashCode()</code>与 <code>equals()</code>的相关规定：</p><ul><li>如果两个对象相等，则hashcode一定也是相同的；</li><li>两个对象相等，对两个equals方法返回true；</li><li>两个对象有相同的hashcode值，它们也不一定是相等的；</li><li>如果equals方法被覆盖过，则hashCode方法也必须被覆盖；</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ul><h2 id="HashSet的使用"><a href="#HashSet的使用" class="headerlink" title="HashSet的使用"></a>HashSet的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> <span class="comment">// 默认初始容量为16，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> <span class="comment">// 指定初始容量，负载因子为0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> <span class="comment">// 指定初始容量和负载因子</span></span><br><span class="line"><span class="comment">/* 增、删、包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断Set是否为空    </span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> <span class="comment">//获取迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回此集合中的元素数        </span></span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>LinkedHashSet是有序集合，其底层是通过LinkedHashMap来实现的，LinkedHashMap其实也就是value是固定值的LinkedHashMap。因此LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。LinkedHashSet继承了HashSet。LinkedHashSet的特点(<strong>底层是LinkedHashMap/线程不安全/元素有序</strong>)：</p><ul><li><p>底层是用LinkedHashMap来实现的。</p></li><li><p>线程不安全 。</p></li><li><p>元素有序，是按照插入的顺序排序的。</p></li><li><p>最多只能存一个null。</p></li><li><p>不支持按访问顺序对元素排序</p><p>LinkedHashSet所有的构造方法都是调用HashSet的同一个构造方法：（accessOrder = false）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>TreeSet是一个有序集合，基于TreeMap实现。TreeSet特点(支持元素排序/线程不安全/):</p><ul><li><p>TreeSet支持元素的自然排序和按照在创建时指定的Comparator比较器(外比较器)进行排序</p><ul><li><p>TreeSet使用二叉树原理对新增对象按照指定顺序排序，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</p></li><li><p>TreeSet中存储自定义类的对象时， 自定义的类必须实现Comparable接口，并且覆写相应<code>compareTo()</code>函数。</p></li><li><p>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的。自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。</p></li><li><p>在重写compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>  <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(student s)</span> &#123;</span><br><span class="line">        <span class="comment">// 主要条件：按照年龄从小到大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="built_in">this</span>.age - s.age;</span><br><span class="line">        <span class="comment">//次要条件：年龄相同时，按照姓名的字母顺序排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num == <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(s.name) : num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comparabledemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;student&gt; tree = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;student&gt;();</span><br><span class="line">        <span class="type">student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;wuer&quot;</span>,<span class="number">27</span>);</span><br><span class="line">        <span class="type">student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;weuers&quot;</span>,<span class="number">250</span>);</span><br><span class="line">        tree.add(s1);</span><br><span class="line">        tree.add(s2);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>TreeSet的基本操作（增删）的时间复杂度是log(n) 。</p></li><li><p>TreeSet是非线程安全的。</p></li><li><p>TreeSet的迭代器是fail-fast策略的。</p></li><li><p>TreeSet中元素不允许为null，不允许重复值。</p></li></ul><h2 id="TreeSet的使用"><a href="#TreeSet的使用" class="headerlink" title="TreeSet的使用"></a>TreeSet的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> <span class="comment">// 创建一个空的 TreeSet，使用自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> <span class="comment">// 指定比较器，如果比较器是 null 将使用自然排序</span></span><br><span class="line"><span class="comment">/* 增 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="comment">// 添加一个元素</span></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">// 添加集合中的元素</span></span><br><span class="line"><span class="comment">/* 删 */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> <span class="comment">// 检索和删除最小（第一个）元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> <span class="comment">// 检索和删除最大（最后）元素</span></span><br><span class="line"><span class="comment">/* 包含 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">/* 获取特殊元素 */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">last</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">first</span><span class="params">()</span> <span class="comment">// 返回此TreeSet中存在的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">floor</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中小于或者等于给定元素的最大元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">ceiling</span><span class="params">(E e)</span> <span class="comment">// 返回在这个集合中大于或者等于给定元素的最小元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">higher</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中大于某个元素的最小的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">lower</span><span class="params">(E e)</span> <span class="comment">// 返回此集合中小于某个元素的最大的元素   </span></span><br><span class="line"><span class="comment">/* 其他方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 获取TreeSet元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 判断TreeSet是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 清空TreeSet</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中的Set是集合框架（Collection Framework）的核心接口之一，用于存储无序且唯一的元素。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Map</title>
    <link href="https://southernfish.github.io/2025/06/23/java/java-map/"/>
    <id>https://southernfish.github.io/2025/06/23/java/java-map/</id>
    <published>2025-06-23T02:45:36.000Z</published>
    <updated>2025-06-24T14:24:28.354Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。其核心实现包括数组+链表（JDK1.7及之前）或数组+链表+红黑树（JDK1.8及之后），通过哈希冲突解决机制（链地址法）和动态扩容优化性能。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><a href="https://so.csdn.net/so/search?q=Collection%E6%8E%A5%E5%8F%A3&spm=1001.2101.3001.7020">Collection接口</a>的实现类中存储的是具体的单个元素，Map中存储的是键值对。常用的Map实现类有：HashMap、LinkedHashMap、TreeMap、HashTable和ConcurrentHashMap。</p><table><thead><tr><th>实现类</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashMap</td><td>基于哈希表实现，查询快，效率高</td><td>元素存储时无序，非线程安全</td></tr><tr><td>LinkedHashMap</td><td>基于哈希表和链表实现，可以保留元素插入时的顺序</td><td>非线程安全</td></tr><tr><td>TreeMap</td><td>存储的元素有序</td><td>非线程安全</td></tr><tr><td>HashTable</td><td>线程安全，不允许null值</td><td>效率低</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>线程安全，性能较好</td><td></td></tr></tbody></table><p>原文链接：<a href="https://blog.csdn.net/m0_37741420/article/details/112424663">Java集合（三）Map的常用实现类</a></p><hr><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><code>HashMap</code>是基于哈希表实现的键值对存储结构，HashMap的核心实现结合了<code>数组</code>、<code>链表</code>和<code>红黑树</code>。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>数组</code>：默认初始容量为16，数组的每个位置称为一个桶(<code>Bucket</code>)。容量始终为<strong>2的幂次方</strong>(如16、32)，便于通过位运算快速定位索引。<br><code>链表</code>：当多个键的哈希值冲突时，这些键值对以链表形式存储在同一个桶中（链地址法）。<br><code>红黑树</code>：当链表长度超过阈值（默认8）且数组容量≥64时，链表会转换为<code>红黑树</code>，以提高查找效率（从<code>O(n)</code>优化为<code>O(log n)</code>）。</p><h3 id="哈希函数与索引定位"><a href="#哈希函数与索引定位" class="headerlink" title="哈希函数与索引定位"></a>哈希函数与索引定位</h3><p>HashMap通过哈希函数将键映射到数组的索引位置。具体步骤如下：</p><ol><li><p>调用键的<code>hashCode()</code>方法获取哈希值。</p></li><li><p><strong>扰动处理：</strong>将高16位与低16位异或<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，减少哈希碰撞概率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>(n-1) &amp; hash</code>计算桶位置，等价于<code>hash % n</code>，但性能更高‌。</p></li></ol><h3 id="冲突处理机制"><a href="#冲突处理机制" class="headerlink" title="冲突处理机制"></a>冲突处理机制</h3><ol><li><p><strong>链地址法：</strong>冲突的键值对以链表形式链接。在JDK 8之前采用头插法，JDK 8之后采用尾插法以避免多线程下的死循环问题‌</p></li><li><p><strong>红黑树转换：</strong></p><ol><li><p>当链表长度≥8且数组容量≥64时，链表会转换为红黑树‌。</p></li><li><p>红黑树节点数≤6时，退化为链表</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/java/image-20250623125725272.png" alt="image-20250623125725272"></p></li></ol></li></ol><h3 id="动态扩容机制"><a href="#动态扩容机制" class="headerlink" title="动态扩容机制"></a>动态扩容机制</h3><p>HashMap的扩容机制基于负载因子（默认值为0.75）。当元素数量超过<code>容量乘以负载因子</code>时，比如<strong>当数组添加到16*0.75=12时</strong>，HashMap会自动触发扩容，扩容为自身的两倍：16*2=32。扩容步骤如下：</p><ol><li>创建一个新的数组，<code>容量为原容量的两倍</code>（保持2的幂次方）。</li><li>重新计算所有元素的位置并放入新数组的对应位置，利用高位快速判断元素是否需要移动（如原索引为<code>oldIndex</code>，新索引可能为<code>oldIndex</code>或<code>oldIndex + oldCapacity</code>）。</li><li>扩容后，链表或红黑树可能会被拆分到不同的桶中‌</li></ol><h2 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h2><ol><li><strong>插入（put</strong>）<ol><li>计算键的哈希值并定位桶索引。</li><li>桶为空：直接插入新节点。</li><li>桶非空：遍历链表或红黑树，若存在相同键（通过<code>equals</code>判断），则更新值；否则追加节点。</li><li>触发扩容：插入后检查元素总数是否超过阈值。</li></ol></li><li><strong>查询（get）</strong>：根据哈希值定位桶，遍历链表或红黑树，通过<code>equals</code>匹配键。</li></ol><h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><ul><li><p><strong>遍历EntrySet（键值对）</strong>：支持通过<code>iterator.remove()</code>安全删除元素(优点)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>遍历KeySet（仅键）</strong>：性能低于<code>EntrySet</code>遍历，需多次调用<code>get()</code>（缺点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;K&gt; keyIterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">// 需要额外查询值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for-each循环"></a>for-each循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历EntrySet</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历键</span></span><br><span class="line"><span class="keyword">for</span> (K key : map.keySet()) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span> (V value : map.values()) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式遍历（Java-8-）"><a href="#Lambda表达式遍历（Java-8-）" class="headerlink" title="Lambda表达式遍历（Java 8+）"></a>Lambda表达式遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach( (key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value) );</span><br></pre></td></tr></table></figure><h3 id="Stream-API遍历（Java-8-）"><a href="#Stream-API遍历（Java-8-）" class="headerlink" title="Stream API遍历（Java 8+）"></a>Stream API遍历（Java 8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程遍历</span></span><br><span class="line">map.entrySet().stream().forEach(entry -&gt; ...);</span><br><span class="line"><span class="comment">// 多线程遍历</span></span><br><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; ...);</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table><thead><tr><th><strong>遍历方式</strong></th><th><strong>时间复杂度</strong></th><th><strong>适用场景</strong></th><th><strong>线程安全</strong></th></tr></thead><tbody><tr><td>EntrySet迭代器</td><td>O(n)</td><td>需要删除元素</td><td>需手动同步</td></tr><tr><td>EntrySet for-each</td><td>O(n)</td><td>常规遍历</td><td>需手动同步</td></tr><tr><td>KeySet遍历</td><td>O(n)（性能较低）</td><td>仅需键</td><td>需手动同步</td></tr><tr><td>Lambda表达式</td><td>O(n)</td><td>代码简洁性优先</td><td>需手动同步</td></tr><tr><td>Stream API</td><td>O(n)</td><td>大数据量处理或并行计算</td><td>需手动同步</td></tr></tbody></table><p><strong>推荐选择</strong>：</p><ul><li><strong>需键值对</strong>：优先使用<code>entrySet()</code>（迭代器或for-each）。</li><li><strong>仅需键或值</strong>：直接遍历<code>keySet()</code>或<code>values()</code>。</li><li><strong>代码简洁性</strong>：Java 8+环境下推荐Lambda表达式。</li><li><strong>线程安全</strong>：改用<code>ConcurrentHashMap</code>或使用同步包装类。</li></ul><h2 id="HashMap安全"><a href="#HashMap安全" class="headerlink" title="HashMap安全"></a>HashMap安全</h2><h3 id="HashMap线程不安全的表现"><a href="#HashMap线程不安全的表现" class="headerlink" title="HashMap线程不安全的表现"></a>HashMap线程不安全的表现</h3><ol><li><strong>数据覆盖（丢失）</strong><br> <strong>场景：</strong>多线程同时调用 <code>put()</code> 方法插入数据。<br> <strong>原因：</strong>两个线程同时计算哈希值并定位到同一个桶(bucket)时，若该位置为空，可能发生数据覆盖。<strong>无锁导致复合操作非原子性</strong>。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设线程A和线程B同时执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> (table[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line">    table[bucket] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value); <span class="comment">// 可能被覆盖</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK 1.8 的数据覆盖问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapUnsafeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Map size: &quot;</span> + map.size()); <span class="comment">// 结果可能小于 1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>链表成环</strong>（JDK 1.7 的经典问题）<br> <strong>场景：</strong>多线程同时触发 <code>resize()</code>（扩容）。<br> <strong>原因：</strong>JDK 1.7 的 HashMap 使用<strong>头插法</strong>迁移链表，<strong>并发扩容时可能导致链表成环</strong>，后续的 <code>get()</code>操作触发死循环</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7 的扩容代码（简化）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程A执行到这里挂起</span></span><br><span class="line">            e.next = newTable[bucket]; <span class="comment">// 线程B先执行，导致链表成环</span></span><br><span class="line">            newTable[bucket] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>size 不准确</strong><br> <strong>场景：</strong>多线程同时调用 <code>put()</code> 或 <code>remove()</code>。<br> <strong>原因：</strong>size 变量是非原子操作（如 size++），并发修改可能导致最终值错误。<strong>非原子操作 + 无可见性保证</strong>。</li></ol><h3 id="HashMap线程不安全的根本原因"><a href="#HashMap线程不安全的根本原因" class="headerlink" title="HashMap线程不安全的根本原因"></a>HashMap线程不安全的根本原因</h3><ol><li><strong>无同步机制</strong><br>HashMap 的设计目标是单线程高性能，未对多线程操作进行同步（如 <code>synchronized</code> 或 <code>CAS</code>）。<br>关键操作（<code>put()、get()、resize()</code>）没有锁保护。</li><li><strong>可见性问题</strong><br>多线程修改共享变量（如 <code>table、size</code>）时，未使用 <code>volatile</code> 关键字，可能导致一个线程的修改对其他线程不可见。</li><li><strong>复合操作非原子性</strong><br>例如 <code>put()</code> 操作包含多个步骤（计算哈希、定位桶、插入节点），多线程交叉执行时可能破坏内部结构。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用线程安全的替代类<pre><code>`Collections.synchronizedMap()`：通过包装类对所有方法加锁（性能较差）。`ConcurrentHashMap`：分段锁（JDK 1.7）或 CAS + synchronized（JDK 1.8），高并发性能更好。</code></pre></li><li>避免多线程直接操作 HashMap<br>  限制为单线程使用，或通过副本、消息队列等方式隔离并发访问。</li></ol><hr><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>在<code>jdk1.7</code>版本<ul><li>ConcurrentHashMap的数据结构是由一个<code>Segment</code>数组和多个<code>HashEntry</code>组成。</li><li>主要实现原理是实现了<strong>锁分离</strong>的思路，采用<strong>分段锁的机制</strong>，实现并发的更新操作。</li><li>底层采用<strong>数组+链表</strong>的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。</li><li>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到 的锁分离技术。每一个Segment元素存储的是HashEntry 数组+链表（若干个桶），这个和HashMap的数据存储结构一样。</li><li>HashEntry用来封装映射表的键值对，每个桶是由若干个HashEntry对象链接起来的链表。</li></ul></li><li>在<code>jdk1.8</code>后<ul><li>取消了Segment类，直接用table数组存储键值对。采用<code>Node + CAS + Synchronized</code>来保证并发安全。</li><li>Node数据结构比较简单，就是一个链表，但是只允许对数据进行查找，不允许进行修改。</li><li>当HashEntry对象组成的链表长度超过8时，或数组长度小于64 就会扩容，则链表转换为红黑树，提升性能。底层变更为<strong>数组＋链表＋红黑树</strong>。</li></ul></li></ul><h2 id="底层原理（jdk1-8）"><a href="#底层原理（jdk1-8）" class="headerlink" title="底层原理（jdk1.8）"></a>底层原理（jdk1.8）</h2><ol><li><p>Node节点数字用的是<code>volatile</code>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap使用volatile修饰节点数组，保证其可见性，禁止指令重排。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>ConcurrentHashMap的<code>put()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put()方法直接调用putVal()方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以直接看putVal()方法。</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            tab = initTable();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法并未用synchronized修饰。<strong>put过程如下：</strong><br>（1）根据 key 计算出 hashcode，然后开始遍历 table；<br>（2）判断是否需要初始化；<br>（3）f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。<br>（4）如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。<br>（5）如果都不满足，则利用 synchronized 锁写入数据。<br>（6）如果数量大于 TREEIFY_THRESHOLD ，则要转换为红黑树。</p></li><li><p>ConcurrentHashMap的<code>get()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap的get()方法是不加锁的，方法内部也没加锁。</span></span><br><span class="line"><span class="comment">// 因为table有`volatile`关键字修饰，保证每次获取值都是最新的。</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure><p>get方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头节点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get过程如下：</strong><br>（1）首先根据key计算出来的 hashcode 寻址，如果就在桶上那么直接返回值，<br>（2）如果是红黑树那就按照树的方式获取值，<br>（3）都不满足那就按照链表的方式遍历获取值。</p></li></ol><p>原文链接：<a href="https://blog.csdn.net/FAQEW/article/details/146542959">HashMap底层原理</a>、<a href="https://blog.csdn.net/winterPassing/article/details/148248794">HashMap安全性问题</a>、<a href="https://blog.csdn.net/qq_42077317/article/details/138009817">Java中的ConcurrentHashMap原理详解</a></p>]]></content>
    
    
    <summary type="html">HashMap是基于哈希表实现的键值对存储结构，提供高效的插入和查询操作（平均时间复杂度O(1)），允许null键/值，非线程安全，且不保证元素顺序。</summary>
    
    
    
    <category term="java" scheme="https://southernfish.github.io/categories/java/"/>
    
    
    <category term="集合框架" scheme="https://southernfish.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的较难题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-hard/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-hard/</id>
    <published>2025-06-22T13:30:36.000Z</published>
    <updated>2025-06-24T14:24:28.351Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些较难的题目。</p><h2 id="找出两个正序数组的中位数"><a href="#找出两个正序数组的中位数" class="headerlink" title="找出两个正序数组的中位数"></a>找出两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 (归并、快速排序 n.log(n))。假设 nums1 和 nums2 不会同时为空。<br>示例 1: nums1 = [1, 3]   nums2 = [2]       则中位数是 2.0<br>示例 2: nums1 = [1, 2]   nums2 = [3, 4]   则中位数是 (2 + 3)/2 = 2.5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">problem1</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 偶数个 排序后 找下标 (nums1.length + nums2.length) / 2 和 (nums1.length + nums2.length) / 2 - 1</span></span><br><span class="line">    <span class="keyword">if</span>((nums1.length + nums2.length) % <span class="number">2</span> == <span class="number">0</span> )&#123; </span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 相同长度部分</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// right</span></span><br><span class="line">                    right = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot; -&gt;&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// right</span></span><br><span class="line">                    right = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组1 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// right</span></span><br><span class="line">                right = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组2 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// right</span></span><br><span class="line">                right = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left + right) <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 奇数个 找下标 (nums1.length + nums2.length - 1) / 2        </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 相同长度部分</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                    left = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组1 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums1[i] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length &amp;&amp; count &lt; (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123; <span class="comment">// 数组2 多的部分</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == (nums1.length + nums2.length) / <span class="number">2</span> + <span class="number">1</span>)&#123;  <span class="comment">// left</span></span><br><span class="line">                left = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(nums2[j] +<span class="string">&quot; ( 第&quot;</span>+ count +<span class="string">&quot;个 )&quot;</span> + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持’-’和’-’的正则表达式匹配"><a href="#支持’-’和’-’的正则表达式匹配" class="headerlink" title="支持’.’和’*’的正则表达式匹配"></a>支持’.’和’*’的正则表达式匹配</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持<code> &#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。<code>&#39;.&#39; </code>匹配任意单个字符；<code>&#39;*&#39; </code>匹配零个或多个前面的那一个元素所谓匹配，是要涵盖整个字符串 s的，而不是部分字符串。<br>说明：s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 <em>。<br>示例 1：输入: s = “aa”    p = “a”   输出: false。解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2：输入: s = “aa”    p = “a</em>“   输出: true。<br>    解释: ‘<em>‘ 代表可匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3：输入: s = “ab”    p = “.</em>“   输出: true。解释: “.<em>“ 表示可匹配零个或多个（’</em>‘）任意字符（’.’）。<br>示例 4：输入: s = “aab”    p = “c<em>a</em>b”  输出: true。<br>    解释: 因为 ‘<em>‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5：输入:s = “mississippi”  p = “mis</em>is<em>p</em>.”  输出: false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem2</span><span class="params">(String s, String p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) &amp;&amp; (p.length() == <span class="number">0</span> || p == <span class="literal">null</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>((p == <span class="literal">null</span> &amp;&amp; s != <span class="literal">null</span>) || (p != <span class="literal">null</span> &amp;&amp; s == <span class="literal">null</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode hard</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的中等难度题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-medium/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-medium/</id>
    <published>2025-06-22T12:30:36.000Z</published>
    <updated>2025-06-24T14:24:28.351Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些中等难度的题目。</p><h2 id="基础数据类型定义"><a href="#基础数据类型定义" class="headerlink" title="基础数据类型定义"></a>基础数据类型定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode1 next;</span><br><span class="line"></span><br><span class="line">    ListNode1(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode1</span><span class="params">(<span class="type">int</span> val , ListNode1 next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode1 <span class="title function_">reverseLink</span><span class="params">(ListNode1 head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode1</span> <span class="variable">head1</span> <span class="operator">=</span> head, next1 = head.next, prev1 = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            head1.next = prev1;</span><br><span class="line">            prev1 = head1;</span><br><span class="line">            head1 = next1;</span><br><span class="line">            next1 = head1.next;  <span class="comment">// next1 = next1.next;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>给出两个非空链表来表示两个非负的整数。其中，它们各自的位数是按照<code>逆序</code>的方式存储的，并且它们的每个节点只能存储一位数字。<br>如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。假设除了数字 0 之外，这两个数都不会以 0 开头。<br>示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)；输出：7 -&gt; 0 -&gt; 8。原因：342 + 465 = 807</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, re = head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            re.val = (p1.val + p2.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p1.val + p2.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 == <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;     <span class="comment">// p2 长</span></span><br><span class="line">            re.val = (p2.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p2.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 == <span class="literal">null</span>) &#123;   <span class="comment">// p1 长</span></span><br><span class="line">            re.val = (p1.val + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (p1.val + temp) / <span class="number">10</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">            re.val = temp;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">            re.next = <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">            re = re.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            re.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem_pre</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, re = head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> || p2 != <span class="literal">null</span> || temp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (p1 != <span class="literal">null</span> ? p1.val : <span class="number">0</span>)  + (p2 != <span class="literal">null</span> ? p2.val : <span class="number">0</span>) + temp;</span><br><span class="line">        temp = sum / <span class="number">10</span>;</span><br><span class="line">        re.next = <span class="keyword">new</span> <span class="title class_">ListNode1</span>(sum % <span class="number">10</span>);</span><br><span class="line">        p1 = p1 != <span class="literal">null</span> ?  p1.next : <span class="literal">null</span>;</span><br><span class="line">        p2 = p2 != <span class="literal">null</span> ?  p2.next : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不含重复字符的最长子串长度"><a href="#不含重复字符的最长子串长度" class="headerlink" title="不含重复字符的最长子串长度"></a>不含重复字符的最长子串长度</h2><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。  请注意，你的答案必须是子串的长度。<br>示例 1: 输入: “abcabcbb”。输出: 3。解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2: 输入: “bbbbb”。输出: 1。解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3: 输入: “pwwkew”。输出: 3。解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String strSrc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strSrc.equals(<span class="string">&quot;&quot;</span>) || strSrc.length() == <span class="number">0</span> || strSrc.length() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;源字符串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;的最长子串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;长度为 &gt;&gt; &quot;</span> + strSrc.length());</span><br><span class="line">        <span class="keyword">return</span> strSrc.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + strSrc.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> subStr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> maxStr.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strSrc.length(); ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; subStr.length(); j++) &#123;  <span class="comment">// 和子串的全部字符比较</span></span><br><span class="line">            <span class="keyword">if</span> (strSrc.charAt(i) == subStr.charAt(j)) &#123; <span class="comment">// 有重复字符 回退 子串长度-1 位 当前字符为新子串 指针下一位</span></span><br><span class="line">                count++;</span><br><span class="line">                i = i - subStr.length() + <span class="number">1</span>;</span><br><span class="line">                subStr = <span class="string">&quot;&quot;</span> + strSrc.charAt(i);</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == subStr.length() &amp;&amp; flag &amp;&amp; i &lt; strSrc.length()) &#123; <span class="comment">// 比完没有重复字符  当前字符串加入字符集</span></span><br><span class="line">            subStr = subStr + strSrc.charAt(i);</span><br><span class="line">            maxStr = maxStr.length() &lt; subStr.length() ? subStr : maxStr;</span><br><span class="line">            maxLen = maxStr.length();</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;源字符串&lt;&quot;</span> + strSrc + <span class="string">&quot;&gt;的最长子串&lt;&quot;</span> + maxStr + <span class="string">&quot;&gt;长度为 &gt;&gt; &quot;</span> + maxLen);</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>) || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + s.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> subStr.length();</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; subStr.length(); j++) &#123;  <span class="comment">// 和子串的全部字符比较</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == subStr.charAt(j)) &#123; <span class="comment">// 有重复字符 回退 子串长度-1个位置 取当前字符为新子串 指针下一位</span></span><br><span class="line">                i = i - subStr.length() + <span class="number">1</span>;</span><br><span class="line">                subStr = <span class="string">&quot;&quot;</span> + s.charAt(i);</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == subStr.length() &amp;&amp; flag &amp;&amp; i &lt; s.length()) &#123; <span class="comment">// 比完没有重复字符  当前字符串加入字符集</span></span><br><span class="line">            subStr = subStr + s.charAt(i);</span><br><span class="line">            maxLen = maxLen &gt; subStr.length() ? maxLen : subStr.length();</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找出字符串中最长回文子串"><a href="#找出字符串中最长回文子串" class="headerlink" title="找出字符串中最长回文子串"></a>找出字符串中最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：输入: “babad”。输出: “bab”。注意: “aba” 也是一个有效答案。<br>示例 2：输入: “cbbd”。输出: “bb”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> dp[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 枚举所有子串长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; s.length(); l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123; <span class="comment">// 枚举子串的起始位置 i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + l; <span class="comment">// 通过 j=i+l 得到子串的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= s.length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = (s.charAt(i) == s.charAt(j));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断回文串长度</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; l + <span class="number">1</span> &gt; result.length())&#123;</span><br><span class="line">                result = s.substring(i, j + <span class="number">1</span>); <span class="comment">// 取值为左闭右开区间 [ start, end )</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将给定字符串按给定行数Z字排列"><a href="#将给定字符串按给定行数Z字排列" class="headerlink" title="将给定字符串按给定行数Z字排列"></a>将给定字符串按给定行数Z字排列</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。具体示例如下图所示。请你实现这个将字符串进行指定行数变换的函数： <code>string convert(string s, int numRows);</code></p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250622221010005.png" alt="image-20250622221010005"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*官方解答</span></span><br><span class="line"><span class="comment">按顺序遍历字符串 s；</span></span><br><span class="line"><span class="comment">res[i] += c： 把每个字符 c 填入对应行s_i；</span></span><br><span class="line"><span class="comment">i += flag： 更新当前字符 c 对应的行索引；</span></span><br><span class="line"><span class="comment">flag = - flag： 在达到 ZZ 字形转折点时，执行反向*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StringBuilder&gt;();  <span class="comment">// 每一行的字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        rows.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, flag = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123; <span class="comment">// 所有字符串</span></span><br><span class="line">        rows.get(i).append(c); <span class="comment">// 实际上 遍历了rows数组</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == numRows - <span class="number">1</span>)&#123; <span class="comment">// 转折点 反向遍历</span></span><br><span class="line">            flag = -flag;</span><br><span class="line">        &#125;</span><br><span class="line">        i += flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(StringBuilder row : rows) &#123;</span><br><span class="line">        res.append(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串转整数的实现函数-atoi"><a href="#字符串转整数的实现函数-atoi" class="headerlink" title="字符串转整数的实现函数 atoi"></a>字符串转整数的实现函数 atoi</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的<strong>转化规则如下</strong>：<br>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br>提示：本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。<br>示例 1: 输入: “42”。输出: 42。<br>示例 2: 输入: “   -42”。输出: -42<br>    解释: 第一个非空白字符为 ‘-‘是一个负号。尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3: 输入: “4193 with words”  输出: 4193。解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4: 输入: “words and 987”。输出: 0。解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。<br>示例 5: 输入: “-91283472332”。输出: -2147483648。解释: 数字”-91283472332”超过32位有符号整数范围。返回 INT_MIN (−231) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span> || str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, flag = <span class="number">0</span>; <span class="comment">// flag 表示有没有数字</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">numStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; numStr.length() == <span class="number">0</span>) &#123; <span class="comment">// 忽略有效字符前面的空格</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; (str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span> || str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            &amp;&amp; (str.charAt(i) != <span class="string">&#x27;-&#x27;</span> &amp;&amp; str.charAt(i) != <span class="string">&#x27;+&#x27;</span>)) &#123; <span class="comment">// 排除第一个有效字符不是 + - 0到9的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; numStr.length() == <span class="number">1</span> &amp;&amp; (str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)) &#123; </span><br><span class="line">            <span class="comment">// + - 后面不是0-9的数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span> &amp;&amp; (str.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || str.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)) &#123; <span class="comment">// 一串有效值后遇到了非数字字符</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; (str.charAt(i) == <span class="string">&#x27;-&#x27;</span> || str.charAt(i) == <span class="string">&#x27;+&#x27;</span>)) &#123; <span class="comment">// 第一个字符是 + -</span></span><br><span class="line">            numStr = numStr + str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            numStr = numStr + str.charAt(i);</span><br><span class="line">            target = target <span class="number">10</span> + (str.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!numStr.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; numStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        target = <span class="number">0</span> - target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span> || target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> numStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span> ? (<span class="type">int</span>) Math.pow(-<span class="number">2</span>, <span class="number">31</span>) : (<span class="type">int</span>) Math.pow(<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大容量的容器"><a href="#最大容量的容器" class="headerlink" title="最大容量的容器"></a>最大容量的容器</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code>。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。<br>示例：输入：[1,8,6,2,5,4,8,3,7]。输出：49</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="literal">null</span> || height.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bottomLen, target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            bottomLen = j - i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> bottomLen Math.min(height[i], height[j]);</span><br><span class="line">            target = Math.max(target, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符:I，V，X，L，C，D和M。<br>字符（数值）对应关系：I（1）、V（5）、X（10）、L（50）、C（100）、D（500）、M（1000）<br>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：<br>I可以放在V(5)        和X(10)       的左边，来表示 4        和9。<br>X可以放在L(50)     和C(100)     的左边，来表示 40     和90。<br>C可以放在D(500)  和M(1000)  的左边，来表示 400  和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1到 3999 的范围内<br>示例 1: 输入:”III”            输出: 3<br>示例 2: 输入:”IV”            输出: 4<br>示例 3: 输入:”IX”                输出: 9<br>示例 4: 输入:”LVIII”            输出: 58         解释: L = 50, V= 5, III = 3。<br>示例 5: 输入:”MCMXCIV”      输出: 1994         解释: M = 1000, CM = 900, XC = 90, IV = 4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String sub[] = &#123;<span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;M&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> cons[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">900</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cons.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num / cons[i] == <span class="number">0</span>) &#123; <span class="comment">// 不能匹配当前了 则匹配较小的</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num / cons[i] != <span class="number">0</span>) &#123; <span class="comment">// 减去已经匹配的</span></span><br><span class="line">            target = target + sub[i];</span><br><span class="line">            num -= cons[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中三数之和为0的三元组"><a href="#数组中三数之和为0的三元组" class="headerlink" title="数组中三数之和为0的三元组"></a>数组中三数之和为0的三元组</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。<br>示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2] ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; problem8(int[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; re = new ArrayList&lt;&gt;();</span><br><span class="line">    // 找出所有的三元组 [a, b, c] 对应的指针分别为 i j k</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    Arrays.<span class="built_in">sort</span>(nums);  // 从小到大排序</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;//  跳过数组中的重复元素</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = n - 1; // c对应的指针初始指向数组的最右端</span><br><span class="line">        <span class="keyword">for</span> (int j = i + 1; j &lt; nums.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;//  跳过数组中的重复元素</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &gt; j &amp;&amp; nums[i] + nums[j] + nums[k] &gt; 0) &#123;  // 保证 b 的指针在 c 的指针的左侧</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果指针重合，随着 b增大 不再存在满足 a+b+c=0 并且 b &lt; c 的 c</span><br><span class="line">            <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == 0) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                list.add(nums[j]);</span><br><span class="line">                list.add(nums[k]);</span><br><span class="line">                re.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中与给定值最接近的三数之和"><a href="#数组中与给定值最接近的三数之和" class="headerlink" title="数组中与给定值最接近的三数之和"></a>数组中与给定值最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br>示例：输入：nums = [-1,2,1,-4], target = 1    输出：2。解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。<br>提示：3 &lt;= nums.length &lt;= 10^3；-10^3 &lt;= nums[i] &lt;= 10^3；-10^4 &lt;= target &lt;= 10^4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 每个三元组 [a, b, c] 对应的指针分别为 i j k</span></span><br><span class="line">    Arrays.sort(nums);  <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">3</span>) &#123; <span class="comment">// 只有三位数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res - target == <span class="number">0</span>) &#123; <span class="comment">// 前三位之和为target</span></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// c对应的指针初始指向数组的最右端</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; j) &#123; <span class="comment">// 保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (temp == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(res - target) &gt;= Math.abs(temp - target)) &#123;</span><br><span class="line">                res = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (temp &gt; target) &#123; <span class="comment">// 当前和比目标值较大 第三个数减小 右往左</span></span><br><span class="line">                k = k - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">                    k = k - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; target) &#123; <span class="comment">// 当前和比目标值较小 第二个数增大 左往右</span></span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123; <span class="comment">// 跳过数组中的重复元素</span></span><br><span class="line">                    j = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拼音九键中给定两数字对应字符串列表"><a href="#拼音九键中给定两数字对应字符串列表" class="headerlink" title="拼音九键中给定两数字对应字符串列表"></a>拼音九键中给定两数字对应字符串列表</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话(拼音九键)按键相同）。<br>注意： 1 不对应任何字母。示例：输入：”23”。输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">problem</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    List&lt;String&gt; re = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (digits.length() == <span class="number">0</span> || digits.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> digit[] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    String corr[] = &#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;!@#&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    re = findCombination(re, corr, digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findCombination</span><span class="params">(List&lt;String&gt; re, String[] corr, String digits, <span class="type">int</span> index, String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">        re.add(s);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">    <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> corr[c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">        findCombination(re, corr, digits, index + <span class="number">1</span>, s + letters.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转每对括号间的子串"><a href="#反转每对括号间的子串" class="headerlink" title="反转每对括号间的子串"></a>反转每对括号间的子串</h2><p>给出一个字符串 s（仅含有小写英文字母和括号）。请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。注意，结果中不应包含任何括号。<br>示例 1：输入：s = “(abcd)”。输出：”dcba”<br>示例 2：输入：s = “(u(love)i)”。输出：”iloveu”。解释：先反转子字符串 “love” ，然后反转整个字符串。<br>示例 3：输入：s = “(ed(et(oc))el)”。输出：”leetcode”。解释：先反转子字符串 “oc” ，接着反转 “etco” ，然后反转整个字符串。<br>提示：1 &lt;= s.length &lt;= 2000；s 中只有小写英文字母和括号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            reverse(arr, stack.pop() + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="string">&#x27;)&#x27;</span> &amp;&amp; arr[i] != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = tmp;</span><br><span class="line">        right--;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode medium</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的简单题</title>
    <link href="https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-easy/"/>
    <id>https://southernfish.github.io/2025/06/22/algorithm/java-algorithm-easy/</id>
    <published>2025-06-22T11:58:36.000Z</published>
    <updated>2025-06-24T14:24:28.351Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些<a href="https://leetcode.cn/">LeetCode</a>的一些简单的题目</p><h2 id="基础数据类型定义"><a href="#基础数据类型定义" class="headerlink" title="基础数据类型定义"></a>基础数据类型定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode1 next;</span><br><span class="line">    ListNode1() &#123;&#125;</span><br><span class="line">    ListNode1(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode1(<span class="type">int</span> val, ListNode1 next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode1</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode1 left;</span><br><span class="line">     TreeNode1 right;</span><br><span class="line">    </span><br><span class="line">     TreeNode1(<span class="type">int</span> x) &#123;</span><br><span class="line">         val = x;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和为目标值的两数在数组中的下标"><a href="#和为目标值的两数在数组中的下标" class="headerlink" title="和为目标值的两数在数组中的下标"></a>和为目标值的两数在数组中的下标</h2><p>给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>示例: nums = [2, 7, 11, 15], target = 9。因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] problem(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> result[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32位整数反转"><a href="#32位整数反转" class="headerlink" title="32位整数反转"></a>32位整数反转</h2><p>给出一个 <code>32位</code>的有符号整数，你需要将这个整数中每位上的数字进行反转。注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为<code>[−231, 231− 1]</code>。请根据这个假设，如果反转后整数溢出那么就返回 0。<br>示例 1: 输入: 123   输出: 321<br>示例 2: 输入: -123  输出: -321<br>示例 3: 输入: 120   输出: 21</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;     </span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// int  溢出问题</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;        <span class="comment">// 1534236469</span></span><br><span class="line">        len = (x + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        len = (x + <span class="string">&quot;&quot;</span>).length() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target += tempMath.pow(<span class="number">10</span>, len - <span class="number">1</span>);</span><br><span class="line">        len = len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println((<span class="type">int</span>)Math.pow(<span class="number">2</span>, <span class="number">31</span>) + <span class="string">&quot; --- &quot;</span> + Math.pow(<span class="number">2</span>, <span class="number">31</span>));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) target == target ? <span class="type">int</span>(target) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target = target10 + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) || (target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((target &gt; Math.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) || (target &lt; Math.pow(-<span class="number">2</span>, <span class="number">31</span>))) ? <span class="number">0</span> : (<span class="type">int</span>) target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回文数判断"><a href="#回文数判断" class="headerlink" title="回文数判断"></a>回文数判断</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>示例 1: 输入: 121  输出: true<br>示例 2: 输入: -121 输出: false  解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3: 输入: 10    输出: false  解释: 从右向左读, 为 01 。因此它不是一个回文数。<br><strong>进阶:</strong> 能不将整数转为字符串来解决这个问题吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) &#123; <span class="comment">// 负数都不是回文数  除0以外的整十数都不是回文数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> x + <span class="string">&quot;&quot;</span>; </span><br><span class="line">    System.out.println(src.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = src.length() - <span class="number">1</span>; i &lt;= src.length() / <span class="number">2</span> &amp;&amp; j &gt;= src.length() / <span class="number">2</span>; i++, j--) &#123;</span><br><span class="line">        System.out.println(src.charAt(i) + <span class="string">&quot;&lt;----&gt;&quot;</span> + src.charAt(j));</span><br><span class="line">        <span class="keyword">if</span> (src.charAt(i) != src.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不使用字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) &#123; <span class="comment">// 负数都不是回文数  除0以外的整十数都不是回文数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (x + <span class="string">&quot;&quot;</span>).length() / <span class="number">2</span>, target = <span class="number">0</span>, isEven = (x + <span class="string">&quot;&quot;</span>).length() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        target += (<span class="type">int</span>) tempMath.pow(<span class="number">10</span>, count - <span class="number">1</span>);</span><br><span class="line">        count = count - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;--&gt;&quot;</span> + target);</span><br><span class="line">    <span class="keyword">if</span> (isEven == <span class="number">0</span> &amp;&amp; target != x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEven == <span class="number">1</span> &amp;&amp; target != (x / <span class="number">10</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>罗马数字包含以下七种字符:I，V，X，L，C，D和M。<br>字符（数值）对应关系：I（1）、V（5）、X（10）、L（50）、C（100）、D（500）、M（1000）<br>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：<br>I可以放在V(5)        和X(10)       的左边，来表示 4        和9。<br>X可以放在L(50)     和C(100)     的左边，来表示 40     和90。<br>C可以放在D(500)  和M(1000)  的左边，来表示 400  和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1到 3999 的范围内<br>示例 1: 输入:”III”            输出: 3<br>示例 2: 输入:”IV”            输出: 4<br>示例 3: 输入:”IX”                输出: 9<br>示例 4: 输入:”LVIII”            输出: 58         解释: L = 50, V= 5, III = 3。<br>示例 5: 输入:”MCMXCIV”      输出: 1994         解释: M = 1000, CM = 900, XC = 90, IV = 4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        char constant[] = &#123;&#x27;I&#x27;,&#x27;V&#x27;,&#x27;X&#x27;,&#x27;L&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;M&#x27;&#125;;</span></span><br><span class="line">    <span class="type">int</span> cons[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">SRC</span> <span class="operator">=</span> <span class="string">&quot;IVXLCDM&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s.charAt(i) == <span class="string">&#x27;I&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;V&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;X&#x27;</span>)) ||</span><br><span class="line">                (s.charAt(i) == <span class="string">&#x27;X&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;L&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;C&#x27;</span>)) ||</span><br><span class="line">                (s.charAt(i) == <span class="string">&#x27;C&#x27;</span> &amp;&amp; (s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;D&#x27;</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;M&#x27;</span>))) &#123;</span><br><span class="line">            target += cons[SRC.indexOf(s.charAt(i + <span class="number">1</span>))] - cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target += cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        target += cons[SRC.indexOf(s.charAt(i))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串数组的最长公共前缀"><a href="#字符串数组的最长公共前缀" class="headerlink" title="字符串数组的最长公共前缀"></a>字符串数组的最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。 说明: 所有输入只包含小写字母a-z。<br>如果不存在公共前缀，返回空字符串””。<br>示例 1: 输入: [“flower”,”flow”,”flight”]  输出: “fl”<br>示例 2: 输入: [“dog”,”racecar”,”car”]     输出: “” 解释: 输入不存在公共前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(strs[i].length(), prefix.length()); <span class="comment">// 比较直到较小长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 字符比较 下标</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; len &amp;&amp; prefix.charAt(index) == strs[i].charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        prefix = prefix.substring(<span class="number">0</span>, index); <span class="comment">// 取公共前缀</span></span><br><span class="line">        <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123; <span class="comment">// 前缀已经为空 则退出比较</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效字符串判定"><a href="#有效字符串判定" class="headerlink" title="有效字符串判定"></a>有效字符串判定</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>    左括号必须用相同类型的右括号闭合。<br>    左括号必须以正确的顺序闭合。<br>    注意空字符串可被认为是有效字符串。<br>示例 1: 输入: “()”  输出: true<br>示例 2: 输入: “()[]{}”    输出: true<br>示例 3: 输入: “(]”   输出: false<br>示例 4: 输入: “([)]”   输出: false<br>示例 5: 输入: “{[]}” 输出: true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 空串合法</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个字符为右括号 或者 串长为奇数 非法</span></span><br><span class="line">    <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">&#x27;)&#x27;</span> || s.charAt(<span class="number">0</span>) == <span class="string">&#x27;]&#x27;</span> || s.charAt(<span class="number">0</span>) == <span class="string">&#x27;&#125;&#x27;</span> || s.length() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//左括号进栈  右括号出栈 判断是否合法</span></span><br><span class="line">    <span class="type">char</span> stack[] = <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span> || s.charAt(i) == <span class="string">&#x27;[&#x27;</span> || s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack[top++] = s.charAt(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> stack[--top];</span><br><span class="line">            <span class="keyword">if</span> ((temp == <span class="string">&#x27;(&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) || (temp == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;]&#x27;</span>) ||</span><br><span class="line">                        (temp == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27;&#125;&#x27;</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="number">0</span>) &#123;  <span class="comment">// 栈不空 非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个升序链表"><a href="#合并两个升序链表" class="headerlink" title="合并两个升序链表"></a>合并两个升序链表</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过 拼接给定的两个链表的所有节点 组成的。<br>示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4; 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 l1, ListNode1 l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span> &amp;&amp; l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2, h;</span><br><span class="line">    <span class="keyword">if</span> (p1.val &lt; p2.val) &#123;</span><br><span class="line">        h = p1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h = p2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">head</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt; p2.val) &#123;</span><br><span class="line">            h.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123; <span class="comment">// l1剩下的</span></span><br><span class="line">        h.next = p1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span>) &#123; <span class="comment">// l2 剩下的</span></span><br><span class="line">        h.next = p2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序数组原地去重"><a href="#排序数组原地去重" class="headerlink" title="排序数组原地去重"></a>排序数组原地去重</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 【原地】修改输入数组 并在使用 O(1) 额外空间的条件下完成。<br>示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>      不需要考虑数组中超出新长度后面的元素。<br>示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。       不需要考虑数组中超出新长度后面的元素。<br>说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:<br>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br><code>int len = removeDuplicates(nums);</code><br>// 在函数里修改输入数组对于调用者是可见的。根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br><code>for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] != nums[i]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原地删除数组中特定值"><a href="#原地删除数组中特定值" class="headerlink" title="原地删除数组中特定值"></a>原地删除数组中特定值</h2><p>给你一个数组 nums和一个值 val，你需要 原地 移除所有数值等于val的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>       你不需要考虑数组中超出新长度后面的元素。<br>示例2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>       注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。<br>说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:<br>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br><code>int len = removeElement(nums, val);</code><br>// 在函数里修改输入数组对于调用者是可见的。根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br><code>for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现strStr-函数"><a href="#实现strStr-函数" class="headerlink" title="实现strStr()函数"></a>实现strStr()函数</h2><p>给定一个haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。<br>示例 1: 输入: haystack = “hello”, needle = “ll”   输出: 2<br>示例 2: 输入: haystack = “aaaaa”, needle = “bba”  输出: -1<br>说明: 当needle是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当needle是空字符串时我们应当返回 0 。这与C语言的<code>strstr()</code>以及 Java的<code>indexOf()</code>定义相符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem10</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span> || needle.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haystack.length() &lt; needle.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> haystack.length() - needle.length() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; diff; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; needle.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123; <span class="comment">// 不匹配 退出比较</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.length()) &#123; <span class="comment">// 比完 第一次找到匹配的needle  退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == diff) &#123; <span class="comment">// 比完 没找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在排序数组中找目标值"><a href="#在排序数组中找目标值" class="headerlink" title="在排序数组中找目标值"></a>在排序数组中找目标值</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。<br>示例 1: 输入: [1,3,5,6], 5      输出: 2<br>示例 2: 输入: [1,3,5,6], 2      输出: 1<br>示例 3: 输入: [1,3,5,6], 7      输出: 4<br>示例 4: 输入: [1,3,5,6], 0      输出: 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target || (i == <span class="number">0</span> &amp;&amp; nums[i] &gt; target)) &#123; <span class="comment">// 原数组中找到了  target 或者比第一个还小</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] &lt; target &amp;&amp; nums[i + <span class="number">1</span>] &gt; target) &#123;  </span><br><span class="line">            <span class="comment">// 插在数组的第 2 到第 nums.length-1个位置</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length; <span class="comment">// 插到第 nums.length 个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h2><p>外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：<br><code>1（1）、2（11）、3（21）、4（1211）、5（111221）</code><br><code>1</code>读作”one 1”(“一个一”),即11。<code>11</code>读作”two 1”(“两个一”）,即21。<code>21</code>读作”one 2”,”one 1”（”一个二”,”一个一”), 即1211。<br>给定一个正整数 n（1 ≤n≤ 30），输出外观数列的第 n 项。<strong>注意：</strong>整数序列中的每一项将表示为一个字符串。<br>示例 1: 输入: 1 输出: “1”        解释：这是一个基本样例。<br>示例 2: 输入: 4  输出: “1211”<br>解释：当 n = 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，”2” 可以读作 “12”，也就是出现频次 = 1 而 值 = 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;  <span class="comment">// 首项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123; <span class="comment">// 第二项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 推导</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">nextStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>, index = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; str.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(index) == str.charAt(j)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextStr = nextStr + count + str.charAt(index);</span><br><span class="line">                    index = j;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str.length()) &#123; <span class="comment">// 比到了最后</span></span><br><span class="line">                nextStr = nextStr + count + str.charAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            str = nextStr;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; ---&gt;&gt; &quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大连续数组"><a href="#最大连续数组" class="headerlink" title="最大连续数组"></a>最大连续数组</h2><p>给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6。解释:连续子数组[4,-1,2,1] 的和最大，为6。<br>进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> nums[<span class="number">0</span>], max = target, index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        target += nums[i];</span><br><span class="line">        max = max &gt; target ? max : target;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.length - <span class="number">1</span> &amp;&amp; index &lt; nums.length) &#123; <span class="comment">// 已经最后 回退</span></span><br><span class="line">            System.out.println(index + <span class="string">&quot; --&gt; &quot;</span> + max);</span><br><span class="line">            i = index++ - <span class="number">1</span>; <span class="comment">// 执行完后 i会加1;</span></span><br><span class="line">            target = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    <span class="comment">/*考虑分治的方法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算字符串中最后一个单词的长度"><a href="#计算字符串中最后一个单词的长度" class="headerlink" title="计算字符串中最后一个单词的长度"></a>计算字符串中最后一个单词的长度</h2><p>给定一个仅包含大小写字母和空格’ ‘的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。如果不存在最后一个单词，请返回 0。说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。<br>示例: 输入: “Hello World”  输出: 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem14</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 从后往前看第一个单词的长度</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组代表一个数字，做加一计算"><a href="#数组代表一个数字，做加一计算" class="headerlink" title="数组代表一个数字，做加一计算"></a>数组代表一个数字，做加一计算</h2><p>给定一个由整数组成的 【非空数组】 所表示的 【非负整数】 ，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。<br>示例1: 输入: [1,2,3]       输出: [1,2,4]        解释: 输入数组表示数字 123。<br>示例2: 输入: [4,3,2,1]    输出: [4,3,2,2]     解释: 输入数组表示数字 4321。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] problem(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == digits.length - <span class="number">1</span> &amp;&amp; (digits[i] + <span class="number">1</span> &lt; <span class="number">10</span>)) &#123; <span class="comment">// 最后一位没有进位</span></span><br><span class="line">            digits[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> digits[i];</span><br><span class="line">            <span class="keyword">if</span> (i == digits.length - <span class="number">1</span>) &#123; <span class="comment">// 最后一位有进位</span></span><br><span class="line">                digits[i] = (digits[i] + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                digits[i] = (pre + temp) % <span class="number">10</span>;</span><br><span class="line">                temp = (pre + temp) / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;  <span class="comment">// 最后一位数有进位</span></span><br><span class="line">        <span class="type">int</span>[] re = <span class="keyword">new</span> <span class="title class_">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        re[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digits.length; i++) &#123;</span><br><span class="line">            re[i + <span class="number">1</span>] = digits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制相加"><a href="#二进制相加" class="headerlink" title="二进制相加"></a>二进制相加</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 【非空】 字符串且只包含数字1和0。<br>示例 1: 输入: a = “11”, b = “1”              输出: “100”<br>示例 2: 输入: a = “1010”, b = “1011”   输出: “10101”<br>提示：每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。 <code>1 &lt;= a.length, b.length &lt;= 10^4</code>。字符串如果不是 “0” ，就都不含前导零。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">problem</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">re</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>, temp = <span class="number">0</span>; <span class="comment">// temp 是进位</span></span><br><span class="line">    <span class="comment">// char型的数字 转 int：  char - &#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        re = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + (b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + (b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;  <span class="comment">// a 剩下的</span></span><br><span class="line">        re = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((a.charAt(i) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123; <span class="comment">// b 剩下的</span></span><br><span class="line">        re = ((b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) % <span class="number">2</span> + re;</span><br><span class="line">        temp = ((b.charAt(j) - <span class="string">&#x27;0&#x27;</span>) + temp) / <span class="number">2</span>;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123; <span class="comment">// 最后还有进位</span></span><br><span class="line">        re = temp + re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现int-sqrt-int-x-函数"><a href="#实现int-sqrt-int-x-函数" class="headerlink" title="实现int sqrt(int x)函数"></a>实现int sqrt(int x)函数</h2><p>计算并返回x的平方根，其中x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<br>示例 1: 输入: 4   输出: 2<br>示例 2: 输入: 8   输出: 2。说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> (<span class="type">int</span>)Math.exp(<span class="number">0.5</span> Math.log(x));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>)(ans + <span class="number">1</span>) (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种 二分查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, e = x;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e) &#123;     <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (e - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>)mid mid &lt;= x) &#123; <span class="comment">// 右边  (long long)mid  mid</span></span><br><span class="line">            target = mid;</span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 左边</span></span><br><span class="line">            e = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种 牛顿迭代</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">C</span> <span class="operator">=</span> x, x0 = x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">// 牛顿迭代   比二分快</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">xi</span> <span class="operator">=</span> <span class="number">0.5</span> (x0 + C / x0);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(x0 - xi) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x0 = xi;</span><br><span class="line">    &#125;</span><br><span class="line">    target = (<span class="type">int</span>) x0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="爬楼梯算法"><a href="#爬楼梯算法" class="headerlink" title="爬楼梯算法"></a>爬楼梯算法</h2><p>假设你正在爬楼梯。需要n阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。有多少种不同方法可以爬到楼顶？注意：给定 n 是正整数。<br>示例 1：输入： 2  输出： 2。解释： 有两种方法可以爬到楼顶。（1 阶 + 1 阶）、（2 阶）<br>示例 2：输入： 3  输出： 3。解释： 有三种方法可以爬到楼顶。（1 阶 + 1 阶 + 1 阶）、（1 阶 + 2 阶）、（2 阶 + 1 阶）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        target = test_math(n);       // 排列组合</span></span><br><span class="line">    target = test_dynamicProgram(n); <span class="comment">// 滚动数组</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test_math</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 排列组合中的排列  排列： A(n,m)=n×（n-1）...（n-m+1）=n!/（n-m）!(n为下标,m为上标）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> n, count2 = <span class="number">0</span>, target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count1 - <span class="number">2</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count1 - <span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">// 全2</span></span><br><span class="line">            target += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count2++; <span class="comment">// 2的个数</span></span><br><span class="line">            count1 = count1 - <span class="number">2</span>;</span><br><span class="line">            target += combination(count1 + count2, count2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target + <span class="number">1</span>; <span class="comment">// 加一个全 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合   C(n,m) = A(n,m) / m!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combination</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n - m + <span class="number">1</span>); i &lt;= n; i++) &#123; <span class="comment">// A(n,m)=n*(n-1)...(n-m+1)=n! / (n-m)!</span></span><br><span class="line">        target *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">// C(n,m) = A(n,m) / m!</span></span><br><span class="line">        target /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划的转移方程：</strong>用 <code>f(x)</code> 表示爬到<code>第 x 级台阶</code>的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，故可列出如下式子：<code>f(x) = f(x−1) + f(x−2)</code>。它意味着爬到第 x级台阶的方案数是爬到<code>第 x−1 级台阶</code>的方案数和爬到<code>第 x−2 级台阶</code>的方案数的和。因为每次只能爬 11 级或 22 级，所以 <code>f(x)</code>只能从 <code>f(x−1) </code>和 <code>f(x−2)</code> 转移过来，要统计方案总数，就需要对这两项的贡献求和。<br><strong>边界条件：</strong>从第 0 级开始爬，从第 0 级爬到第 0 级可以看作只有一种方案，即 <code>f(0)=1</code>；从第 0 级到第 1 级也只有一种方案，即爬一级，<code>f(1)=1</code>。这两个作为边界条件就可以继续向后推导出第 n 级的正确结果。<br>不妨写几项来验证一下，根据转移方程得到 <code>f(2)=2</code>，<code>f(3)=3</code>，<code>f(4)=5</code>……把这些情况都枚举出来，发现计算的结果是正确的。<br>不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n) 的实现，但由于这里的 <code>f(x)</code> 只和 <code>f(x−1)</code> 与 <code>f(x−2)</code> 有关，所以可以用「<strong>滚动数组思想</strong>」把空间复杂度优化成 <code>O(1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test_dynamicProgram</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序链表去重"><a href="#排序链表去重" class="headerlink" title="排序链表去重"></a>排序链表去重</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br>示例1: 输入: 1-&gt;1-&gt;2             输出: 1-&gt;2<br>示例2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3  输出: 1-&gt;2-&gt;3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode1 <span class="title function_">problem</span><span class="params">(ListNode1 head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode1</span> <span class="variable">p</span> <span class="operator">=</span> head.next, pre = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val == pre.val) &#123;</span><br><span class="line">            pre.next = p.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两无序数组为一个有序数组"><a href="#合并两无序数组为一个有序数组" class="headerlink" title="合并两无序数组为一个有序数组"></a>合并两无序数组为一个有序数组</h2><p>给你两个有序整数数组nums1 和 nums2，请你将 nums2 合并到nums1中，使 nums1 成为一个有序数组。<br>说明：初始化nums1 和 nums2 元素数量分别为m 和 n 。设nums1有足够的空间（空间大小大于或等于m + n）保存 nums2 中元素。<br>示例：输入: nums1 = [1,2,3,0,0,0], m = 3；nums2 = [2,5,6], n = 3。输出:[1,2,2,3,5,6]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">problem</span><span class="params">(<span class="type">int</span>[] num1, <span class="type">int</span> m, <span class="type">int</span>[] num2, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m + j &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1[i] &gt; num2[j])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + j; k &gt;= i; k--)&#123; <span class="comment">// 第i+1个元素到第m+j个元素依次后移</span></span><br><span class="line">                <span class="keyword">if</span>(k == i)&#123;</span><br><span class="line">                    num1[i] = num2[j]; <span class="comment">// 插入元素</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    num1[k] = num1[k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)&#123;  <span class="comment">// num2 还有剩</span></span><br><span class="line">        num1[i++] = num2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断两个二叉树是否相同"><a href="#判断两个二叉树是否相同" class="headerlink" title="判断两个二叉树是否相同"></a>判断两个二叉树是否相同</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/algorithm/image-20250622221035975.png" alt="image-20250622221035975"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">problem</span><span class="params">(TreeNode1 p, TreeNode1 q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode1 p, TreeNode1 q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="comment">// 两棵树同时为 null 则相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="comment">// 其中一棵树为 null 则不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p.val != q.val) <span class="comment">// 根节点不同 则不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); <span class="comment">// 左子树 右子树都相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode easy</summary>
    
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://southernfish.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Linux备份数据到本地</title>
    <link href="https://southernfish.github.io/2025/06/21/linux/linux-database-backup/"/>
    <id>https://southernfish.github.io/2025/06/21/linux/linux-database-backup/</id>
    <published>2025-06-21T11:23:36.000Z</published>
    <updated>2025-06-24T14:24:28.355Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录了将Linux中数据库数据备份到本地是实现流程。</p><h2 id="安装下载命令"><a href="#安装下载命令" class="headerlink" title="安装下载命令"></a>安装下载命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装下载命令</span><br><span class="line">sudo yum install lrzsz</span><br><span class="line">sz filename  下载</span><br><span class="line">rz filename  上传</span><br></pre></td></tr></table></figure><h2 id="登录到MySQL"><a href="#登录到MySQL" class="headerlink" title="登录到MySQL"></a>登录到MySQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h2 id="查看所有用户及权限"><a href="#查看所有用户及权限" class="headerlink" title="查看所有用户及权限"></a>查看所有用户及权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT User, Host FROM mysql.user;</span><br></pre></td></tr></table></figure><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">USE your_database_name;</span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><h2 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p mysql &gt; mysql_dump.sql</span><br><span class="line">mysqldump -u username -p mydatabase &gt; mydatabase_dump.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中：</span></span><br><span class="line"><span class="comment"># username 是你的MySQL用户名。</span></span><br><span class="line"><span class="comment"># -p 选项会提示你输入密码。</span></span><br><span class="line"><span class="comment"># mydatabase 是要导出的数据库名称。</span></span><br><span class="line"><span class="comment"># mydatabase_dump.sql 是导出的文件名。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux备份数据到本地</summary>
    
    
    
    <category term="Linux" scheme="https://southernfish.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://southernfish.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker命令</title>
    <link href="https://southernfish.github.io/2025/06/21/docker/docker-commands/"/>
    <id>https://southernfish.github.io/2025/06/21/docker/docker-commands/</id>
    <published>2025-06-21T08:20:36.000Z</published>
    <updated>2025-06-24T14:24:28.352Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一个用于创建、部署和管理容器的开源平台。在使用Docker时，有效地管理和监控容器是非常重要的，其中查看和解析Docker命令(command)是基本且关键的一步。本文将介绍一些关于Docker的命令。</p><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="Docker命令的格式"><a href="#Docker命令的格式" class="headerlink" title="Docker命令的格式"></a>Docker命令的格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker &lt;<span class="built_in">command</span>&gt;[options] [arguments]</span><br></pre></td></tr></table></figure><h2 id="Docker基础命令"><a href="#Docker基础命令" class="headerlink" title="Docker基础命令"></a>Docker基础命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker version           <span class="comment">#显示版本信息</span></span><br><span class="line">docker info              <span class="comment">#显示docker系统信息，包括容器、镜像</span></span><br><span class="line">docker stats             <span class="comment">#cpu/内存使用情况</span></span><br><span class="line">docker  [<span class="built_in">command</span>] --<span class="built_in">help</span>       <span class="comment">#帮助命令</span></span><br></pre></td></tr></table></figure><hr><h1 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h1><h2 id="查看本地镜像-images"><a href="#查看本地镜像-images" class="headerlink" title="查看本地镜像 images"></a>查看本地镜像 images</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">    -a, --all             <span class="comment"># 列出所有的镜像</span></span><br><span class="line">    -q, --quiet           <span class="comment"># 只显示的镜像的id</span></span><br><span class="line"><span class="comment"># 举例说明</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID           CREATED        SIZE</span><br><span class="line">centos              7         8652b9f0cb4c   2 months ago   204MB</span><br><span class="line"><span class="comment"># 解释</span></span><br><span class="line">    REPOSITORY  镜像仓库源</span><br><span class="line">    TAG         标签（版本）</span><br><span class="line">    IMAGE ID    镜像ID</span><br><span class="line">    CREATED     创建时间</span><br><span class="line">    SIZE        大小</span><br></pre></td></tr></table></figure><h2 id="搜索镜像-search"><a href="#搜索镜像-search" class="headerlink" title="搜索镜像 search"></a>搜索镜像 search</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search [镜像名]</span><br><span class="line">    --filter=STARS=3000                            <span class="comment"># 列出收藏数不小于指定值的镜像</span></span><br><span class="line">docker search centos                            <span class="comment"># 搜索centos镜像</span></span><br><span class="line">docker search --filter=STARS=3000 centos        <span class="comment"># 搜索收藏大于3000的centos镜像</span></span><br></pre></td></tr></table></figure><h2 id="下载镜像-pull"><a href="#下载镜像-pull" class="headerlink" title="下载镜像 pull"></a>下载镜像 pull</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull [镜像名]:[版本号]</span><br><span class="line">      -a, --all-tags                <span class="comment"># 下载所有镜像名的镜像</span></span><br><span class="line">docker pull nginx                    <span class="comment"># 下载nginx镜像，默认最新版</span></span><br><span class="line">docker pull nginx:1.14.0            <span class="comment"># 下载nginx镜像，版本为1.14.0</span></span><br><span class="line">docker pull -a nginx                <span class="comment"># 下载REPOSITORY为nginx的所有镜像</span></span><br></pre></td></tr></table></figure><h2 id="删除镜像-rmi"><a href="#删除镜像-rmi" class="headerlink" title="删除镜像 rmi"></a>删除镜像 rmi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">删除镜像 rmi</span><br><span class="line">docker rmi [镜像名或者镜像<span class="built_in">id</span>]</span><br><span class="line">    -f                                       <span class="comment"># 强制删除</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>                        <span class="comment"># 删除指定的镜像</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>    镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span>  <span class="comment"># 删除多个镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)         <span class="comment"># 删除全部的镜像</span></span><br></pre></td></tr></table></figure><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [镜像名或者镜像<span class="built_in">id</span>]                  <span class="comment"># 将镜像推送至远程仓库</span></span><br></pre></td></tr></table></figure><hr><h1 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h1><h2 id="启动容器-rmi"><a href="#启动容器-rmi" class="headerlink" title="启动容器 rmi"></a>启动容器 rmi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">启动容器 run</span><br><span class="line">docker run [镜像名]</span><br><span class="line">-d                                            <span class="comment"># 后台运行容器，并返回容器ID</span></span><br><span class="line">-i                                            <span class="comment"># 以交互模式运行容器，通常与 -t 同时使用；</span></span><br><span class="line">-P                                            <span class="comment"># 随机端口映射，容器内部端口随机映射到主机的端口</span></span><br><span class="line">-p                                            <span class="comment"># 指定端口映射，格式为：主机(宿主)端口:容器端口</span></span><br><span class="line">    -p ip:主机端口:容器端口</span><br><span class="line">    -p 主机端口:容器端口</span><br><span class="line">    -p 容器端口</span><br><span class="line">-t                                            <span class="comment"># 为容器重新分配一个伪输入终端，通常与 -i 同时使用（-it    交互模式运行）</span></span><br><span class="line">--name=<span class="string">&quot;nginx-lb&quot;</span>                            <span class="comment"># 为容器指定一个名称</span></span><br><span class="line">--dns 8.8.8.8                                <span class="comment"># 指定容器使用的DNS服务器，默认和宿主一致</span></span><br><span class="line">--dns-search example.com                    <span class="comment"># 指定容器DNS搜索域名，默认和宿主一致</span></span><br><span class="line">-h <span class="string">&quot;hostname&quot;</span>                                <span class="comment"># 指定容器的hostname</span></span><br><span class="line">-e username=<span class="string">&quot;ritchie&quot;</span>                        <span class="comment"># 设置环境变量</span></span><br><span class="line">--env-file=[]                                <span class="comment"># 从指定文件读入环境变量；</span></span><br><span class="line">--cpuset=<span class="string">&quot;0-2&quot;</span> or --cpuset=<span class="string">&quot;0,1,2&quot;</span>            <span class="comment"># 绑定容器到指定CPU运行；</span></span><br><span class="line">-m                                             <span class="comment"># 设置容器使用内存最大值；</span></span><br><span class="line">--net=<span class="string">&quot;bridge&quot;</span>                                 <span class="comment"># 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span></span><br><span class="line">--<span class="built_in">link</span>=[]                                    <span class="comment"># 添加链接到另一个容器</span></span><br><span class="line">--expose=[]                                 <span class="comment"># 开放一个端口或一组端口；</span></span><br><span class="line">--volume , -v                                 <span class="comment"># 绑定一个卷</span></span><br><span class="line">docker run -it centos /bin/bash               <span class="comment"># 启动并进入容器</span></span><br><span class="line">docker run -it -v 主机目录：容器内目录           <span class="comment"># 挂载目录</span></span><br></pre></td></tr></table></figure><h2 id="查看容器信息-ps"><a href="#查看容器信息-ps" class="headerlink" title="查看容器信息 ps"></a>查看容器信息 ps</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [CONTAINER ID or CONTAINER NAME]</span><br><span class="line">-a                        <span class="comment"># 列出当前正在运行的容器+历史运行过的容器</span></span><br><span class="line">-n=?                    <span class="comment"># 显示最近创建的容器</span></span><br><span class="line">-q                        <span class="comment"># 只显示容器的ID</span></span><br><span class="line">docker ps                <span class="comment"># 显示正在运行的容器</span></span><br><span class="line">docker ps -n=3          <span class="comment"># 显示最近三个创建的容器</span></span><br></pre></td></tr></table></figure><h2 id="退出容器-exit"><a href="#退出容器-exit" class="headerlink" title="退出容器 exit"></a>退出容器 exit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">退出容器 <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span>            <span class="comment"># 直接容器停止并退出</span></span><br><span class="line">Ctrl + P + Q    <span class="comment"># 容器不停止退出</span></span><br></pre></td></tr></table></figure><h2 id="删除容器-rm"><a href="#删除容器-rm" class="headerlink" title="删除容器 rm"></a>删除容器 rm</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span>                          <span class="comment"># 删除指定容器，不能删除正在运行的容器   </span></span><br><span class="line">docker <span class="built_in">rm</span> --f 容器<span class="built_in">id</span>                     <span class="comment"># 删除正在运行的容器    </span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)            <span class="comment"># 删除全部的容器</span></span><br><span class="line">docker ps -q -a|xargs docker <span class="built_in">rm</span>         <span class="comment"># 删除全部的容器</span></span><br></pre></td></tr></table></figure><h2 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动和停止容器的操作</span><br><span class="line">docker start 容器<span class="built_in">id</span>        <span class="comment"># 启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span>      <span class="comment"># 重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>         <span class="comment"># 停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span>         <span class="comment"># 强制停止当前的容器</span></span><br></pre></td></tr></table></figure><h2 id="查看容器日志-logs"><a href="#查看容器日志-logs" class="headerlink" title="查看容器日志 logs"></a>查看容器日志 logs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --<span class="built_in">tail</span> 10 8e633673e3c2     <span class="comment"># 查看容器id为8e633673e3c2的容器，最新10条日志</span></span><br><span class="line">    -f                 <span class="comment"># 跟踪日志输出</span></span><br><span class="line">    --since         <span class="comment"># 显示某个开始时间的所有日志</span></span><br><span class="line">    -t                 <span class="comment"># 显示时间戳</span></span><br><span class="line">    --<span class="built_in">tail</span>             <span class="comment"># 仅列出最新N条容器日志</span></span><br><span class="line">docker logs -tf --<span class="built_in">tail</span> 10 8e633673e3c2</span><br></pre></td></tr></table></figure><h2 id="查看容器中的进程信息-top"><a href="#查看容器中的进程信息-top" class="headerlink" title="查看容器中的进程信息 top"></a>查看容器中的进程信息 top</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [容器<span class="built_in">id</span>]        <span class="comment"># 显示容器的进程信息</span></span><br></pre></td></tr></table></figure><h2 id="查看镜像的元数据-inspect"><a href="#查看镜像的元数据-inspect" class="headerlink" title="查看镜像的元数据 inspect"></a>查看镜像的元数据 inspect</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [容器<span class="built_in">id</span>]</span><br><span class="line">    -f             <span class="comment"># 指定返回值的模板文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器ip</span></span><br><span class="line">[root@layman ~]<span class="comment"># docker inspect -f  &#x27;&#123;&#123;.NetworkSettings.Networks.redis.IPAMConfig.IPv4Address&#125;&#125;&#x27; 0233</span></span><br><span class="line">172.31.38.16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器环境变量</span></span><br><span class="line">[root@layman ~]<span class="comment"># docker inspect -f &#x27;&#123;&#123;.Config.Env&#125;&#125;&#x27; 0233</span></span><br><span class="line">[PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin REDIS_VERSION=5.0.9 REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-5.0.9.tar.gz REDIS_DOWNLOAD_SHA=53d0ae164cd33</span><br><span class="line">536c3d4b720ae9a128ea6166ebf04ff1add3b85f1242090cb85]</span><br></pre></td></tr></table></figure><h2 id="进入容器-exec-attach"><a href="#进入容器-exec-attach" class="headerlink" title="进入容器 exec attach"></a>进入容器 exec attach</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash        <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line">docker attach 容器<span class="built_in">id</span>                    <span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure><hr><h1 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h1><h2 id="docker-run-与-docker-start区别"><a href="#docker-run-与-docker-start区别" class="headerlink" title="docker run 与 docker start区别"></a>docker run 与 docker start区别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run 只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令docker start 即可；</span><br><span class="line">docker run相当于执行两步操作：将镜像放入容器（docker create）,然后将容器启动，变成运行时容器（docker start）；</span><br><span class="line">docker start的作用是，重新启动已存在的镜像。</span><br></pre></td></tr></table></figure><h2 id="Docker-run的基本流程"><a href="#Docker-run的基本流程" class="headerlink" title="Docker run的基本流程"></a>Docker run的基本流程</h2><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621155307829.png" alt="image-20250621155307829"></p><h2 id="挂载卷-v"><a href="#挂载卷-v" class="headerlink" title="挂载卷 -v"></a>挂载卷 -v</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span>                      <span class="comment"># 查看所有的volume的情况</span></span><br><span class="line">-v 容器内路径                           <span class="comment"># 匿名挂载</span></span><br><span class="line">-v 卷名：容器内路径                       <span class="comment"># 具名挂载</span></span><br><span class="line">-v /宿主机路径：容器内路径               <span class="comment"># 指定路径挂载</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx     <span class="comment"># 只读权限</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx     <span class="comment"># 可读可写</span></span><br><span class="line"><span class="comment"># 没有指定目录的情况下都是在“/var/lib/docker/volumes/xxxx/_data&quot;下</span></span><br><span class="line"></span><br><span class="line">构建 build</span><br><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t layman/dockerfile .</span><br><span class="line">-f     <span class="comment"># 指定要使用的Dockerfile路径</span></span><br><span class="line">-t     <span class="comment"># 镜像的名字及标签</span></span><br><span class="line"></span><br><span class="line">查看docker网络 network</span><br><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span>                            <span class="comment"># 查看所有容器的网络状态</span></span><br><span class="line">docker network inspect [NETWORK ID]        <span class="comment"># 查看一个详细信息</span></span><br><span class="line">docker network <span class="built_in">rm</span> [NETWORK ID]            <span class="comment"># 可以移除一个网络</span></span><br><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">--driver bridge                自定义网络模式，使用桥接</span><br><span class="line">--subnet 192.168.0.0/16        设置子网地址</span><br><span class="line">--gateway 192.168.0.1        设置出口网关</span><br><span class="line">mynet                        自己定义的一个网络名字</span><br><span class="line"><span class="comment"># 查看网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line">加入网络 connect</span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建-build"><a href="#构建-build" class="headerlink" title="构建 build"></a>构建 build</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t layman/dockerfile .</span><br><span class="line">-f     <span class="comment"># 指定要使用的Dockerfile路径</span></span><br><span class="line">-t     <span class="comment"># 镜像的名字及标签</span></span><br></pre></td></tr></table></figure><h2 id="查看docker网络-network"><a href="#查看docker网络-network" class="headerlink" title="查看docker网络 network"></a>查看docker网络 network</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span>                            <span class="comment"># 查看所有容器的网络状态</span></span><br><span class="line">docker network inspect [NETWORK ID]        <span class="comment"># 查看一个详细信息</span></span><br><span class="line">docker network <span class="built_in">rm</span> [NETWORK ID]            <span class="comment"># 可以移除一个网络</span></span><br><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">--driver bridge                自定义网络模式，使用桥接</span><br><span class="line">--subnet 192.168.0.0/16        设置子网地址</span><br><span class="line">--gateway 192.168.0.1        设置出口网关</span><br><span class="line">mynet                        自己定义的一个网络名字</span><br><span class="line"><span class="comment"># 查看网络详细信息</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入网络 connect</span></span><br><span class="line">docker network connect mynet tomcat01</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker</summary>
    
    
    
    <category term="Containerization Platform" scheme="https://southernfish.github.io/categories/Containerization-Platform/"/>
    
    
    <category term="Docker" scheme="https://southernfish.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://southernfish.github.io/2025/06/21/docker/docker/"/>
    <id>https://southernfish.github.io/2025/06/21/docker/docker/</id>
    <published>2025-06-21T06:15:36.000Z</published>
    <updated>2025-06-24T14:24:28.352Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一组平台即服务（PaaS）的产品。它基于操作系统层级的虚拟化技术，将软件与其依赖项打包为容器。托管容器的软件称为Docker引擎。Docker能够帮助开发者在轻量级容器中自动部署应用程序，并使得不同容器中的应用程序彼此隔离，高效工作。</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="参考文档链接"><a href="#参考文档链接" class="headerlink" title="参考文档链接"></a>参考文档链接</h2><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a>   </p><p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p><code>Docker</code> 是基于Go语言开发的开源项目，是开源的容器化平台，旨在简化应用程序的开发、部署和运行过程。它提供了一种轻量级、可移植和自包含的容器化环境，使开发人员能够在不同的计算机上以一致的方式构建、打包和分发应用程序。<br><strong>核心概念：</strong></p><ul><li><strong>容器（<code>Container</code>）：</strong>容器是 Docker 的<strong>基本部署单元</strong>。它是一个轻量级的、独立的运行时环境，包含应用程序及其相关依赖。容器利用 Linux 内核的命名空间和控制组技术，实现了隔离性和资源管理，使得应用程序在不同的容器中运行不会相互影响。</li><li><strong>镜像（<code>Image</code>）：</strong>镜像是用于<strong>创建容器的模板</strong>。它包含了一个完整的文件系统，其中包括应用程序运行所需的所有文件、依赖和配置信息。镜像是不可变的，通过 Docker 镜像可以创建多个相同的容器实例。</li><li><strong>镜像仓库（<code>Image Registry</code>）：</strong>镜像仓库是用于<strong>存储和分发 Docker 镜像的地方</strong>。最常用的公共镜像仓库是 <code>Docker Hub</code>，上面有大量的官方和社区共享的镜像。也可以搭建私有的镜像仓库，用于存放自己的镜像。</li><li><strong><code>Dockerfile</code>：</strong>Dockerfile 是一种<strong>文本文件</strong>，用于<strong>定义 Docker 镜像的构建过程</strong>。它包含了一系列的指令，用于<strong>指定基础镜像、安装软件、拷贝文件、配置环境等</strong>。通过 Dockerfile，可以自动化地构建镜像，确保镜像的一致性和可重复性。</li></ul><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621152126465.png" alt="image-20250621152126465"></p><p><strong>Docker 的优势</strong>：<code>轻量性、可移植性和灵活性</code>。通过使用 Docker，开发人员可以更轻松地创建一个可靠的开发环境、快速部署应用程序、实现弹性扩展和服务编排等。同时，它也提供了<code>生态系统丰富的工具和服务</code>，例如容器编排工具 <code>Docker Compose</code> 和容器编排平台 <code>Kubernetes</code>，使得容器化应用的管理更加便捷和高效。</p><p><strong>Linux容器技术：</strong></p><ul><li>Docker是在Linuk容器(<code>Linux Containers</code>)技术的基础上发展起来的。</li><li>LUX把单个操作系统的资源划分到多个孤立的组里，在孤立的组里平衡有冲突的资源使用需求。与虚拟机相比，这种通过划分组来平衡资源冲突的方式代价更小，它不需要指令级别模拟也不需要即使编译。</li><li><strong>容器直接在本地CPU上运行</strong>。</li></ul><h3 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h3><ul><li><strong>更快的交付和部署。</strong>开发人员使用镜像构建标准开发环境，运维和测试人员使用镜像来获得和开发人员相同的运行环境。开发环境和测试运维环境无缝对接，节约开发、测试、部署时间。</li><li><strong>更高效的资源利用。</strong>相较于虚拟机Docker不需要额外的<code>Hypervisor</code>支持，Docker是<strong>内核级别的虚拟化</strong>，实现更高的性能。</li><li><strong>更简单的更新管理。</strong>使用<code>Dockerfile</code>，通过简单的修改就可以代替大量的更新操作。</li></ul><h2 id="Docker与虚拟化"><a href="#Docker与虚拟化" class="headerlink" title="Docker与虚拟化"></a>Docker与虚拟化</h2><p><strong>虚拟化：</strong>虚拟化是对计算机资源的抽象，是为了更好的管理计算机资源。让同时运行在一个计算机上的多个进程以为自己能够独占当前操作系统资源。<br><strong>有三种类型的虚拟化：</strong>仿真、半虚拟化、基于容器的虚拟化<br><strong>Docker虚拟化与虚拟机比较</strong></p><ul><li><strong>Docker不是虚拟化方法</strong>。它依赖于实际实现基于容器的虚拟化或操作系统级虚拟化的其他工具。</li><li><strong>Docker是操作系统级的虚拟化</strong>，内核通过创建多个虚拟操作系统实例来隔离进程。虚拟机是硬件辅助虚拟化，虚拟的是整个硬件。</li><li>虚拟机需要模拟一个独立的<code>OS Kernel</code>而Docker不需要，与虚拟机映像相比，容器状态(<code>Docker或LXC映像</code>)的<strong>大小很小</strong>，因此容器映像很容易分发</li><li>虚拟机需要一个虚拟机管理程序如<code>VMware</code>，而Docker只需要一个Docker引擎，<strong>后者的开销更小</strong>。</li><li><strong>Docker更快秒级，虚拟机分钟级别</strong></li><li>Docker<strong>对系统资源需求更少</strong>。<ul><li>主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求。容器中的资源管理是通过cgroup实现的。Cgroups不允许容器消耗比分配给它们更多的资源。</li></ul></li><li>Docker通过类似<code>Git</code>理念来方便用户获取、分发更新镜像</li><li>Docker通过<code>dockerfile</code>实现灵活的创建、部署机制</li></ul><p><strong>虚拟机和Docker本质的区别</strong>在于虚拟化的方式不同，虚拟机是一种硬件级别的虚拟化，通过软件去模拟硬件系统，并且虚拟机里需要虚拟OS Kernel。Docker是一种容器，是一种隔离机制，是软件级别的模拟。</p><p>虚拟机技术：资源占用十分多、冗余步骤多、启动慢；容器技术：不是模拟一个完整的OS</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151302533.png" alt="image-20250621151302533"></p><h2 id="Docker为什么比VM快"><a href="#Docker为什么比VM快" class="headerlink" title="Docker为什么比VM快"></a>Docker为什么比VM快</h2><p>1、Docker比VM有更少的抽象层<br>2、Docker利用的是宿主机的内核，VM需要的是Guest OS<br>故新建一个容器的时候，docker无需像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而docker利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151312130.png" alt="image-20250621151312130"></p><table><thead><tr><th></th><th>Docker容器</th><th>LXC</th><th>VM</th></tr></thead><tbody><tr><td>虚拟化类型</td><td>OS虚拟化</td><td>OS虚拟化</td><td>硬件虚拟化</td></tr><tr><td>性能</td><td>=物理机性能</td><td>=物理机性能</td><td>5%-20%损耗</td></tr><tr><td>隔离性</td><td>NS隔离</td><td>NS隔离</td><td>强</td></tr><tr><td>QoS</td><td>Cgroup 弱</td><td>Cgroup 弱</td><td>强</td></tr><tr><td>安全性</td><td>中</td><td>差</td><td>强</td></tr><tr><td>GuestOS</td><td>只支持Linux&lt;</td><td>只支持Linux&lt;</td><td>全部</td></tr><tr><td>可迁移性</td><td>强</td><td>弱</td><td>强</td></tr></tbody></table><h2 id="docker是怎么工作的"><a href="#docker是怎么工作的" class="headerlink" title="docker是怎么工作的?"></a>docker是怎么工作的?</h2><p>一个完整的Docker由<code>DockerClient</code>客户端、<code>Docker Daemon</code>守护进程、<code>Docker Image</code>镜像、<code>DockerContainer</code>容器四部分组成<br>Docker是一个<code>Client-Server</code>结构的系统，，<strong>docker client负责处理用户输入的各种命令</strong>，比如docker build、docker run，真正工作的其实是server，也就是docker daemon，值得注意的是，<strong>docker client和docker daemon可以运行在同一台机器上</strong>。<br>Docker守护进程运行在主机上，然后通过<code>Socket</code>连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p><p><img src="https://raw.githubusercontent.com/SouthernFish/ImageHostServer/main/docker/image-20250621151356904.png" alt="image-20250621151356904"></p><h2 id="基本的Docker使用工作流程是怎样的？"><a href="#基本的Docker使用工作流程是怎样的？" class="headerlink" title="基本的Docker使用工作流程是怎样的？"></a>基本的Docker使用工作流程是怎样的？</h2><ol><li><strong>构建镜像：</strong>Dockerfile是镜像的源代码；用其创建镜像</li><li><strong>推送镜像到注册表：</strong>将镜像上传到 <code>Docker Hub</code> 或<code>私有注册表</code>中。</li><li><strong>拉取镜像：</strong>通过 <code>docker pull</code> 从注册表中拉取镜像。</li><li><strong>运行容器：</strong>使用镜像创建并启动容器。</li><li><strong>管理容器：</strong>使用 Docker 客户端命令管理正在运行的容器(例如查看日志、停止容器、查看资源使用情况等)。</li><li><strong>网络与存储：</strong>容器之间通过 Docker 网络连接，数据通过 <code>Docker 卷</code>或<code>绑定挂载</code>进行持久化。</li></ol><h2 id="什么是docker-compose？"><a href="#什么是docker-compose？" class="headerlink" title="什么是docker-compose？"></a>什么是docker-compose？</h2><p><code>docker-compose</code>就是一个编排同时管理多个容器的工具，与它配对使用的是一个<code>docker-compose.yaml</code>文件，<code>docker-compose</code>命令必须在一个包含<code>docker-compose.yaml</code>文件目录下才能使用。且当下docker-compose命令<strong>只能管理当前目录docker-compose文件中所涉及的容器，安装在机器上的其他容器无法干扰</strong>。</p><p>docker-compose的大部分命令基本和docker的命令重合，他们唯一的区别是docker命令能管理机器上所有的容器和镜像文件，而docker-compose只能管理当前docker-compose文件所涉及的容器。</p><h2 id="如何在生产中监控Docker？"><a href="#如何在生产中监控Docker？" class="headerlink" title="如何在生产中监控Docker？"></a>如何在生产中监控Docker？</h2><p>Docker提供<code>docker status</code>和<code>docker事件</code>等工具来监控生产中的Docker。我们可以使用这些命令获取重要统计数据的报告。<br><strong>Docker统计数据：</strong>当我们使用容器ID调用docker status时，我们获得容器的CPU、内存使用情况等。它类似于Linux中<code>top</code>命令。<br><strong>Docker事件：</strong> Docker事件是一个命令，用于查看Docker守护进程中整改再进行的活动流。一些常见的Docker事件是：<code>attach</code>、<code>commit</code>、<code>die</code>、<code>datach</code>、<code>rename</code>、<code>destroy</code>。</p><h2 id="Docker安全么？"><a href="#Docker安全么？" class="headerlink" title="Docker安全么？"></a>Docker安全么？</h2><p>Docker<strong>利用了Linux内核中很多安全特性来保证不同容器之间的隔离，并且通过签名机制来对镜像进行验证</strong>。<br>Docker虽然隔离性无法与虚拟机相比，但仍然具有极高的安全性。</p><h2 id="Docker如何在非Linux系统中运行容器"><a href="#Docker如何在非Linux系统中运行容器" class="headerlink" title="Docker如何在非Linux系统中运行容器"></a>Docker如何在非Linux系统中运行容器</h2><p>通过添加到Linux内核版本2.6.24的<strong>名称空间功能</strong>，可以实现容器的概念。容器将其<code>ID</code><strong>添加到每个进程</strong>，并向每个系统调用添加新的访问控制检查。它由<code>clone</code>系统调用访问，该调用允许创建先前全局命名空间的单独实例。</p><hr><h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="什么是Docker镜像"><a href="#什么是Docker镜像" class="headerlink" title="什么是Docker镜像"></a>什么是Docker镜像</h2><p>Docker镜像是Docker容器的源代码。换句话说，Docker镜像用于创建容器。使用<code>build</code>创建镜像，用<code>run</code>启动时它们将生成容器。<br>镜像存储在Docker注册表（<code>docker hub</code>）中，<code>registry.hub.docker.com</code>因为它们可能变得非常大，镜像被设计为由其他镜像层组成，允许在通过网络传输镜像时发送最少量的数据。</p><h2 id="Docker镜像联合文件系统"><a href="#Docker镜像联合文件系统" class="headerlink" title="Docker镜像联合文件系统"></a>Docker镜像联合文件系统</h2><p><strong><code>UnionFS</code>（联合文件系统）：</strong>是一种分成，轻量级并且高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统的Docker镜像可以<strong>通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像</strong>。<br><strong>特性：</strong><code>一次同时加载多个文件系统</code>，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统进行叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h2 id="镜像与-UnionFS区别"><a href="#镜像与-UnionFS区别" class="headerlink" title="镜像与 UnionFS区别"></a>镜像与 UnionFS区别</h2><p>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。<br><code>Docker 镜像</code>其实<strong>本质就是一个压缩包</strong>，我们可以使用命令将一个 Docker 镜像中的文件导出，你可以看到这个镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说 Docker 镜像就是一个文件。</p><h2 id="什么是Docker-Hub"><a href="#什么是Docker-Hub" class="headerlink" title="什么是Docker Hub"></a>什么是Docker Hub</h2><p><code>Docker Hub</code>是一个基于云的在线存储库，Docker进行可以由其他用户发布和使用。<br><code>Docker hub</code>是一个基于云的注册表服务，允许链接到代码存储库，构建镜像并测试，存储手动推送的镜像以及指向Docker云的链接，以便将镜像部署到主机。它为整个开发流程中的容器镜像发现，分发和变更管理，用户和团队协作以及工作流自动化提供了集中资源。</p><hr><h1 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h1><h2 id="Docker容器可扩展到多远？"><a href="#Docker容器可扩展到多远？" class="headerlink" title="Docker容器可扩展到多远？"></a>Docker容器可扩展到多远？</h2><p>诸如<code>Foogle</code>和<code>Twitter</code>之类的大型Web部署以及诸如<code>Heroku</code>和<code>dotCloud</code>之类的平台提供商都基于容器技术运行，并行运行的容器数以十万甚至至数八百计。</p><h2 id="Docker容器退出时是否丢失数据"><a href="#Docker容器退出时是否丢失数据" class="headerlink" title="Docker容器退出时是否丢失数据"></a>Docker容器退出时是否丢失数据</h2><p>不、当Docker<strong>容器退出时，不会丢失数据</strong>。<br>应用程序写入磁盘的所有数据都会保留在其容器中<strong>直到明确删除该容器为止</strong>。即使在容器停止后，该容器的文件系统仍然存在。</p><h2 id="Docker容器有几种状态？"><a href="#Docker容器有几种状态？" class="headerlink" title="Docker容器有几种状态？"></a>Docker容器有几种状态？</h2><p>有四种状态：运行、已暂停、重新启动、已退出。</p><h2 id="容器内部机制"><a href="#容器内部机制" class="headerlink" title="容器内部机制"></a>容器内部机制</h2><p>每个容器都在自己的命名空间中运行，但使用与所有其他容器完全相同的内核。发生隔离是因为内核知道分配给进程的命名空间，并且在API调用期间确保进程只能访问其自己的命名空间中的资源。</p><h2 id="docker容器之间怎么隔离"><a href="#docker容器之间怎么隔离" class="headerlink" title="docker容器之间怎么隔离?"></a>docker容器之间怎么隔离?</h2><p>Linux中的<code>PID、IPC、网络</code>等资源是全局的，而<code>NameSpace机制</code>是一种资源隔离方案，在<strong>该机制下这些资源就不再是全局的</strong>了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰。<br>NameSpace技术可实现资源隔离，但进程仍可不受控的访问（CPU、内存、磁盘、网络等）系统资源，为了控制容器中进程对资源的访问，Docker采用<code>control groups</code>技术(也就是<code>cgroup</code>)<strong>控制容器中进程对系统资源的消耗</strong>，如限制某容器使用内存的上限、可在哪些CPU上运行等。这两项技术使容器像真正独立的操作系统。</p><h2 id="容器与主机之间的数据拷贝命令-docker-cp"><a href="#容器与主机之间的数据拷贝命令-docker-cp" class="headerlink" title="容器与主机之间的数据拷贝命令 docker cp"></a>容器与主机之间的数据拷贝命令 docker cp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> /www 96f7f14e99ab:/www/     <span class="comment"># 主机到容器</span></span><br><span class="line">docker <span class="built_in">cp</span> 96f7f14e99ab:/www /tmp    <span class="comment"># 容器到主机</span></span><br></pre></td></tr></table></figure><h2 id="进入容器的方法"><a href="#进入容器的方法" class="headerlink" title="进入容器的方法"></a>进入容器的方法</h2><ol><li><code>docker attach</code>，用于附加到正在运行的容器的标准输入、输出和错误流。<strong>不会启动新的进程</strong>。</li><li><code>docker exec</code>，如<code>docker exec -it 容器id /bin/bash</code>，此命令将以<strong>交互模式（-i）和终端（-t）的方式进入指定容器，并开启起一个新的终端</strong>。</li><li>通过 <code>docker run</code> 命令来进入容器。这种方式<strong>适用于需要在容器内执行命令而不是交互式操作的情况</strong>，使用 docker run 命令指定容器镜像和执行的命令，类似于直接进入容器</li></ol><h2 id="无状态或有状态应用程序谁更适合Docker容器"><a href="#无状态或有状态应用程序谁更适合Docker容器" class="headerlink" title="无状态或有状态应用程序谁更适合Docker容器"></a>无状态或有状态应用程序谁更适合Docker容器</h2><p>最好为<code>Docker Container</code>创建<strong>无状态应用程序</strong>。我们可以从应用程序中创建一个容器，并<strong>从应用程序中取出可配置的状态参数</strong>。现在我们可以<strong>在生产环境和具有不同参数的QA环境中运行相同的容器</strong>。这有助于在不同场景中重用相同的镜像。另外，无状态应用程序比有状态应用程序<strong>更容易使用Docker容器进行扩展</strong>。</p><hr><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Dockerfile中最常见的指令是什么"><a href="#Dockerfile中最常见的指令是什么" class="headerlink" title="Dockerfile中最常见的指令是什么"></a>Dockerfile中最常见的指令是什么</h2><ul><li><code>FROM</code>：指定基础镜像；</li><li><code>LABEL</code>：功能是为镜像指定标签；</li><li><code>RUN</code>：运行指定的命令；</li><li><code>CMD</code>：容器启动时要运行的命令。</li></ul><h2 id="Dockerfile中的命令COPY和ADD命令区别"><a href="#Dockerfile中的命令COPY和ADD命令区别" class="headerlink" title="Dockerfile中的命令COPY和ADD命令区别"></a>Dockerfile中的命令COPY和ADD命令区别</h2><p>一般而言，<code>ADD</code>和<code>COPY</code>在功能上类似，但是首选COPY。因为COPY比ADD更易懂。<strong>COPY仅支持将本地文件复制到容器中</strong>，而ADD具有一些功能（如仅限本地的tar提取和远程URL支持），这些功能并不是很明显。<br>因此，<strong>ADD最佳用途是将本地tar文件自动提取到镜像中</strong>，如<code>ADD rootfs.tar.xz /</code>。</p><h2 id="使用dockerfile构建apache容器服务"><a href="#使用dockerfile构建apache容器服务" class="headerlink" title="使用dockerfile构建apache容器服务"></a>使用dockerfile构建apache容器服务</h2><ol><li><p>基础镜像目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir apache</span></span><br><span class="line"><span class="comment"># cd apache</span></span><br></pre></td></tr></table></figure></li><li><p>编辑镜像dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim Dockerfile</span></span><br><span class="line"> </span><br><span class="line">FROM centos:7 <span class="comment"># 基于的基础镜像</span></span><br><span class="line">MAINTAINER The porject &lt;cloud-ops@centos.org&gt; <span class="comment"># 维护镜像的用户信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作指令安装apache软件</span></span><br><span class="line">RUN yum -y update    <span class="comment">#更新yum</span></span><br><span class="line">RUN yum -y install httpd</span><br><span class="line"></span><br><span class="line">EXPOSE 80 <span class="comment"># 开启80端口</span></span><br><span class="line">ADD index.html /var/www/html/index.html <span class="comment"># 复制网站首页文件</span></span><br><span class="line">ADD run.sh /run.sh <span class="comment"># 将执行脚本复制到镜像中</span></span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /run.sh <span class="comment"># 启动容器时执行脚本</span></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">&quot;/run.sh&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>编辑启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf /run/httpd/*</span><br><span class="line"><span class="built_in">exec</span> /usr/sbin/apachectl -D FOREGROUND</span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;web test&quot;</span> &gt; index.html</span><br></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t httpd:centos . (注意别忘 了末尾有&quot;.&quot;，且.前面有空格)</span></span><br></pre></td></tr></table></figure></li><li><p>镜像容器启动运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d -p 1216:80 httpd:centos</span></span><br></pre></td></tr></table></figure></li><li><p>测试验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl http://192.168.40.30:1216</span></span><br></pre></td></tr></table></figure></li></ol><p>参考链接：<a href="https://blog.csdn.net/ygq13572549874/article/details/136558153">Docker镜像及Dockerfile详解</a></p><h2 id="docker-构建一个服务的过程-node-js"><a href="#docker-构建一个服务的过程-node-js" class="headerlink" title="docker 构建一个服务的过程(node.js)"></a>docker 构建一个服务的过程(node.js)</h2><ol><li><p>编写应用代码。首先，你需要有一个应用代码。例如，一个简单的 Node.js 应用</p></li><li><p>创建 Dockerfile<br>在应用的根目录下创建一个名为 Dockerfile 的文件。Dockerfile 包含了一系列的指令，用于告诉 Docker 如何构建镜像。例如，对于 Node.js 应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方 Node.js 镜像作为基础镜像</span></span><br><span class="line">FROM node:14</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"><span class="comment"># 复制 package.json 和 package-lock.json (如果有) 到工作目录</span></span><br><span class="line">COPY package*.json ./</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">RUN npm install</span><br><span class="line"><span class="comment"># 复制项目文件到工作目录</span></span><br><span class="line">COPY . .</span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">EXPOSE 3000</span><br><span class="line"><span class="comment"># 定义容器启动时执行的命令</span></span><br><span class="line">CMD [ <span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span> ]</span><br></pre></td></tr></table></figure></li><li><p>构建 Docker 镜像。打开终端或命令行工具，导航到包含 Dockerfile 的目录，然后运行以下命令来构建 Docker 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-nodejs-app .</span><br><span class="line"><span class="comment"># 这里，-t 参数用于标记你的镜像，my-nodejs-app 是你的镜像名称，. 表示 Dockerfile 所在的当前目录。</span></span><br></pre></td></tr></table></figure></li><li><p>运行 Docker 容器。构建完成后，你可以使用以下命令来运行你的 Docker 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:3000 my-nodejs-app</span><br><span class="line"><span class="comment"># 这里，-p 参数将容器的 3000 端口映射到主机的 4000 端口。现在，如果你的机器上的任何程序访问 localhost:4000，它们将会看到你的 Node.js 应用运行。</span></span><br></pre></td></tr></table></figure></li><li><p>检查运行状态（可选）。可以使用以下命令来查看正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>停止并删除容器（可选）。当完成测试后，可以停止并删除容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;container_id&gt;  <span class="comment"># 使用 docker ps 获取 container_id</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;container_id&gt;    <span class="comment"># 使用 docker ps 获取 container_id 或 docker rm $(docker ps -aq) 来删除所有容器</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="部署相关"><a href="#部署相关" class="headerlink" title="部署相关"></a>部署相关</h1><h2 id="CI-CD聚焦代码集成与交付的自动化流程（Jenkins）"><a href="#CI-CD聚焦代码集成与交付的自动化流程（Jenkins）" class="headerlink" title="CI/CD聚焦代码集成与交付的自动化流程（Jenkins）"></a>CI/CD聚焦代码集成与交付的自动化流程（Jenkins）</h2><p>CI/CD 是指持续集成(<code>Continuous Integration</code>)和持续部署(<code>Continuous Deployment</code>)或持续交付(<code>Continuous Delivery</code>)<br><strong>持续集成(Continuous Integration)</strong><br>持续集成是一种软件开发实践，团队成员频繁地将他们的工作集成到共享的代码仓库中。<strong>其主要特点包括</strong>:</p><ol><li><code>频繁提交代码</code>：开发人员可以每天多次提交代码，确保代码库始终保持最新状态。</li><li><code>自动化构建</code>：每次提交后，自动触发构建过程，包括编译、测试、静态分析等</li><li><code>快速反馈</code>：如果构建失败或测试不通过，能够快速地向开发人员提供反馈，以便及时修复问题。</li></ol><p><strong>持续部署(Continuous Deployment)</strong><br>持续部署是在持续集成的基础上，将通过所有测试的代码自动部署到生产环境中。其<strong>特点如下</strong>:</p><ol><li><code>自动化流程</code>：从代码提交到生产环境的部署完全自动化，无需人工干预。</li><li><code>高频率部署</code>：可以实现频繁的部署，使得新功能能够快速地提供给用户,</li><li><code>风险控制</code>：需要有强大的测试和监控体系来确保部署的稳定性和可靠性。</li></ol><p><strong>持续交付(continuous Delivery)</strong><br>持续交付与持续部署类似，但不一定自动部署到生产环境，而是随时可以部署。重点在于确保软件随时处于可发布状态。</p><p><strong>CI/CD 好处包括:</strong></p><ol><li><code>提高开发效率</code>：减少手动操作和等待时间，加快开发周期。</li><li><code>尽早发现问题</code>：通过频繁的集成和测试，问题能够在早期被发现和解决。</li><li><code>降低风险</code>：减少了大规模部署时可能出现的问题，提高了软件的质量和稳定性。</li><li><code>增强团队协作</code>：促进团队成员之间的沟通和协作，提高团队的整体效率，</li></ol><h2 id="DevOps？"><a href="#DevOps？" class="headerlink" title="DevOps？"></a>DevOps？</h2><p>DevOps是涵盖开发与运维全生命周期协作的文化与实践体系。<br>DevOps是一种文化与方法论，旨在打破开发与运维的壁垒，通过自动化工具链、协作流程和共享责任，加速软件全生命周期交付。<br>DevOps覆盖更广包括需求规划、基础设施管理、监控反馈等全流程，强调团队协作、文化变革及工具整合。更强调“人+流程+工具”的系统性优化。<br><strong>技术优势：</strong>更快地解决问题<br><strong>商业利益：</strong>有更多时间可以增加价值（而不是修复/维护）</p>]]></content>
    
    
    <summary type="html">Docker</summary>
    
    
    
    <category term="Containerization Platform" scheme="https://southernfish.github.io/categories/Containerization-Platform/"/>
    
    
    <category term="Docker" scheme="https://southernfish.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://southernfish.github.io/2025/06/21/front-end/front-end-websocket/"/>
    <id>https://southernfish.github.io/2025/06/21/front-end/front-end-websocket/</id>
    <published>2025-06-21T05:33:36.000Z</published>
    <updated>2025-06-24T14:24:28.353Z</updated>
    
    <content type="html"><![CDATA[<p><strong>WebSocket</strong>是一种在单个<a href="https://baike.baidu.com/item/TCP/0?fromModule=lemma_inlink">TCP</a>连接上进行<a href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5/0?fromModule=lemma_inlink">全双工</a>通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><h2 id="WebSocket-的优势和适用场景是什么？"><a href="#WebSocket-的优势和适用场景是什么？" class="headerlink" title="WebSocket 的优势和适用场景是什么？"></a>WebSocket 的优势和适用场景是什么？</h2><ol><li><code>WebSocket</code> 提供了<strong>低延迟的实时通信能力</strong>，能够在服务器端有新数据时立即推送给客户端。</li><li><code>WebSocket</code> 支持<strong>客户端和服务器之间的双向通信</strong>，可以实现实时聊天、实时数据更新等场景</li><li><code>WebSocket</code> 使<strong>用长连接，相对于频繁的短连接请求，减少了网络开销</strong>。</li><li><code>WebSocket</code> 具备<strong>跨域通信</strong>的能力，可以跨域进行实时通信</li></ol><p><strong>适用场景：</strong>实时聊天应用、股票行情推送、实时协作编辑、多人游戏、实时数据监控等<strong>需要实时双向通信的场景</strong>。</p><h2 id="WebSocket-的连接建立过程是怎样的？"><a href="#WebSocket-的连接建立过程是怎样的？" class="headerlink" title="WebSocket 的连接建立过程是怎样的？"></a>WebSocket 的连接建立过程是怎样的？</h2><ol><li>客户端<strong>发送 <code>WebSocket</code> 握手请求</strong></li><li>服务器收到握手请求后，<strong>验证请求头的字段，并返回握手响应</strong></li><li>客户端收到握手响应后，<strong>验证响应头的字段，并生成一个 <code>Sec-WebSocket-Accept</code> 值进行验证</strong></li><li>验证通过后，<code>WebSocket</code> <strong>连接建立成功，客户端和服务器可以开始进行实时通信</strong></li></ol><h2 id="如何处理错误和关闭连接？"><a href="#如何处理错误和关闭连接？" class="headerlink" title="如何处理错误和关闭连接？"></a>如何处理错误和关闭连接？</h2><p>WebSocket 在<strong>出现错误时会触发 error 事件</strong>，可以通过<strong>设置 <code>onerror</code> 事件处理函数来处理错误。</strong>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket 错误:&#x27;</span>, error); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 WebSocket <strong>连接关闭时，会触发 close 事件</strong>，可以通过<strong>设置 <code>onclose</code> 事件处理函数</strong>来执行一些清理操作或重新连接等操作，可以通过<strong>调用 <code>close()</code> 方法来显式地关闭</strong> WebSocket 连接</p><h2 id="实际应用中，如何处理连接状态的变化和重连机制？"><a href="#实际应用中，如何处理连接状态的变化和重连机制？" class="headerlink" title="实际应用中，如何处理连接状态的变化和重连机制？"></a>实际应用中，如何处理连接状态的变化和重连机制？</h2><p>在 <code>onopen</code> 事件中，使用 <code>setInterval</code> 方法定时发送心跳数据包。如<strong>每 5000 毫秒发送一次心跳数据包</strong>，如下所示代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  heartcheck = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;HeartBeat&#x27;</span>); <span class="comment">// 发送心跳数据包</span></span><br><span class="line">  &#125;，<span class="number">5000</span>); <span class="comment">// 时间间隔，单位毫秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>onmessage</code>事件中，当接收到服务器返回的心跳响应或其他消息时，可以<strong>重置心跳定时器</strong>，以避免不必要的心跳发送。例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(heartcheck);<span class="comment">// 清除原来的心跳定时器</span></span><br><span class="line">  heartcheck=<span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;HeartBeat&#x27;</span>); <span class="comment">// 重新创建心跳定时器并发送心跳数据包</span></span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>onclose</code>和<code>onerror</code>事件中，需要<strong>清除心跳定时器</strong>，以避免在连接关闭后继续发送心跳数据包。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(heartcheck);<span class="comment">//清除心跳定时器</span></span><br><span class="line">&#125;;</span><br><span class="line">ws.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(heartcheck);<span class="comment">// 清除心跳定时器</span></span><br><span class="line">  <span class="comment">// 可以添加重连逻辑或其他错误处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">WebSocket</summary>
    
    
    
    <category term="front end" scheme="https://southernfish.github.io/categories/front-end/"/>
    
    
    <category term="WebSocket" scheme="https://southernfish.github.io/tags/WebSocket/"/>
    
  </entry>
  
</feed>
